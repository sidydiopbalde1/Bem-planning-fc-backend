
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Programme
 * 
 */
export type Programme = $Result.DefaultSelection<Prisma.$ProgrammePayload>
/**
 * Model Intervenant
 * 
 */
export type Intervenant = $Result.DefaultSelection<Prisma.$IntervenantPayload>
/**
 * Model DisponibiliteIntervenant
 * 
 */
export type DisponibiliteIntervenant = $Result.DefaultSelection<Prisma.$DisponibiliteIntervenantPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Salle
 * 
 */
export type Salle = $Result.DefaultSelection<Prisma.$SallePayload>
/**
 * Model Seance
 * 
 */
export type Seance = $Result.DefaultSelection<Prisma.$SeancePayload>
/**
 * Model Conflit
 * 
 */
export type Conflit = $Result.DefaultSelection<Prisma.$ConflitPayload>
/**
 * Model PeriodeAcademique
 * 
 */
export type PeriodeAcademique = $Result.DefaultSelection<Prisma.$PeriodeAcademiquePayload>
/**
 * Model JournalActivite
 * 
 */
export type JournalActivite = $Result.DefaultSelection<Prisma.$JournalActivitePayload>
/**
 * Model ActiviteAcademique
 * 
 */
export type ActiviteAcademique = $Result.DefaultSelection<Prisma.$ActiviteAcademiquePayload>
/**
 * Model IndicateurAcademique
 * 
 */
export type IndicateurAcademique = $Result.DefaultSelection<Prisma.$IndicateurAcademiquePayload>
/**
 * Model ResultatEtudiant
 * 
 */
export type ResultatEtudiant = $Result.DefaultSelection<Prisma.$ResultatEtudiantPayload>
/**
 * Model EvaluationEnseignement
 * 
 */
export type EvaluationEnseignement = $Result.DefaultSelection<Prisma.$EvaluationEnseignementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model RotationWeekend
 * 
 */
export type RotationWeekend = $Result.DefaultSelection<Prisma.$RotationWeekendPayload>
/**
 * Model DisponibiliteResponsable
 * 
 */
export type DisponibiliteResponsable = $Result.DefaultSelection<Prisma.$DisponibiliteResponsablePayload>
/**
 * Model RapportSupervision
 * 
 */
export type RapportSupervision = $Result.DefaultSelection<Prisma.$RapportSupervisionPayload>
/**
 * Model StatistiqueRotation
 * 
 */
export type StatistiqueRotation = $Result.DefaultSelection<Prisma.$StatistiqueRotationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  COORDINATOR: 'COORDINATOR',
  TEACHER: 'TEACHER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Semestre: {
  SEMESTRE_1: 'SEMESTRE_1',
  SEMESTRE_2: 'SEMESTRE_2',
  SEMESTRE_3: 'SEMESTRE_3',
  SEMESTRE_4: 'SEMESTRE_4',
  SEMESTRE_5: 'SEMESTRE_5',
  SEMESTRE_6: 'SEMESTRE_6'
};

export type Semestre = (typeof Semestre)[keyof typeof Semestre]


export const StatusProgramme: {
  PLANIFIE: 'PLANIFIE',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  SUSPENDU: 'SUSPENDU',
  ANNULE: 'ANNULE'
};

export type StatusProgramme = (typeof StatusProgramme)[keyof typeof StatusProgramme]


export const TypeDisponibilite: {
  DISPONIBLE: 'DISPONIBLE',
  INDISPONIBLE: 'INDISPONIBLE',
  PREFERENCE: 'PREFERENCE'
};

export type TypeDisponibilite = (typeof TypeDisponibilite)[keyof typeof TypeDisponibilite]


export const StatusModule: {
  PLANIFIE: 'PLANIFIE',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  REPORTE: 'REPORTE',
  ANNULE: 'ANNULE'
};

export type StatusModule = (typeof StatusModule)[keyof typeof StatusModule]


export const TypeSeance: {
  CM: 'CM',
  TD: 'TD',
  TP: 'TP',
  EXAMEN: 'EXAMEN',
  RATTRAPAGE: 'RATTRAPAGE'
};

export type TypeSeance = (typeof TypeSeance)[keyof typeof TypeSeance]


export const StatusSeance: {
  PLANIFIE: 'PLANIFIE',
  CONFIRME: 'CONFIRME',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  REPORTE: 'REPORTE',
  ANNULE: 'ANNULE'
};

export type StatusSeance = (typeof StatusSeance)[keyof typeof StatusSeance]


export const TypeConflit: {
  INTERVENANT_DOUBLE_BOOKING: 'INTERVENANT_DOUBLE_BOOKING',
  SALLE_DOUBLE_BOOKING: 'SALLE_DOUBLE_BOOKING',
  CHEVAUCHEMENT_HORAIRE: 'CHEVAUCHEMENT_HORAIRE',
  CONTRAINTE_CALENDAIRE: 'CONTRAINTE_CALENDAIRE',
  SURCHARGE_INTERVENANT: 'SURCHARGE_INTERVENANT',
  JOUR_NON_OUVRABLE: 'JOUR_NON_OUVRABLE'
};

export type TypeConflit = (typeof TypeConflit)[keyof typeof TypeConflit]


export const SeveriteConflit: {
  BASSE: 'BASSE',
  MOYENNE: 'MOYENNE',
  HAUTE: 'HAUTE',
  CRITIQUE: 'CRITIQUE'
};

export type SeveriteConflit = (typeof SeveriteConflit)[keyof typeof SeveriteConflit]


export const ActionType: {
  CREATION: 'CREATION',
  MODIFICATION: 'MODIFICATION',
  SUPPRESSION: 'SUPPRESSION',
  CONNEXION: 'CONNEXION',
  DECONNEXION: 'DECONNEXION',
  PLANIFICATION_AUTO: 'PLANIFICATION_AUTO',
  RESOLUTION_CONFLIT: 'RESOLUTION_CONFLIT',
  EXPORT_DONNEES: 'EXPORT_DONNEES',
  ALERTE: 'ALERTE'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]


export const StatutCampagne: {
  BROUILLON: 'BROUILLON',
  ENVOYEE: 'ENVOYEE',
  EN_COURS: 'EN_COURS',
  TERMINEE: 'TERMINEE',
  ANNULEE: 'ANNULEE'
};

export type StatutCampagne = (typeof StatutCampagne)[keyof typeof StatutCampagne]


export const TypeNotification: {
  MODIFICATION_PLANNING: 'MODIFICATION_PLANNING',
  CONFLIT_DETECTE: 'CONFLIT_DETECTE',
  MODULE_SANS_INTERVENANT: 'MODULE_SANS_INTERVENANT',
  PROGRAMME_EN_RETARD: 'PROGRAMME_EN_RETARD',
  MODULE_PROCHAIN: 'MODULE_PROCHAIN',
  EVALUATION_DISPONIBLE: 'EVALUATION_DISPONIBLE',
  SYSTEME: 'SYSTEME'
};

export type TypeNotification = (typeof TypeNotification)[keyof typeof TypeNotification]


export const PrioriteNotification: {
  BASSE: 'BASSE',
  NORMALE: 'NORMALE',
  HAUTE: 'HAUTE',
  URGENTE: 'URGENTE'
};

export type PrioriteNotification = (typeof PrioriteNotification)[keyof typeof PrioriteNotification]


export const StatutRotation: {
  PLANIFIE: 'PLANIFIE',
  CONFIRME: 'CONFIRME',
  EN_COURS: 'EN_COURS',
  TERMINE: 'TERMINE',
  TERMINE_SANS_RAPPORT: 'TERMINE_SANS_RAPPORT',
  ABSENT: 'ABSENT',
  ANNULE: 'ANNULE'
};

export type StatutRotation = (typeof StatutRotation)[keyof typeof StatutRotation]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Semestre = $Enums.Semestre

export const Semestre: typeof $Enums.Semestre

export type StatusProgramme = $Enums.StatusProgramme

export const StatusProgramme: typeof $Enums.StatusProgramme

export type TypeDisponibilite = $Enums.TypeDisponibilite

export const TypeDisponibilite: typeof $Enums.TypeDisponibilite

export type StatusModule = $Enums.StatusModule

export const StatusModule: typeof $Enums.StatusModule

export type TypeSeance = $Enums.TypeSeance

export const TypeSeance: typeof $Enums.TypeSeance

export type StatusSeance = $Enums.StatusSeance

export const StatusSeance: typeof $Enums.StatusSeance

export type TypeConflit = $Enums.TypeConflit

export const TypeConflit: typeof $Enums.TypeConflit

export type SeveriteConflit = $Enums.SeveriteConflit

export const SeveriteConflit: typeof $Enums.SeveriteConflit

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

export type StatutCampagne = $Enums.StatutCampagne

export const StatutCampagne: typeof $Enums.StatutCampagne

export type TypeNotification = $Enums.TypeNotification

export const TypeNotification: typeof $Enums.TypeNotification

export type PrioriteNotification = $Enums.PrioriteNotification

export const PrioriteNotification: typeof $Enums.PrioriteNotification

export type StatutRotation = $Enums.StatutRotation

export const StatutRotation: typeof $Enums.StatutRotation

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.programme`: Exposes CRUD operations for the **Programme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programmes
    * const programmes = await prisma.programme.findMany()
    * ```
    */
  get programme(): Prisma.ProgrammeDelegate<ExtArgs>;

  /**
   * `prisma.intervenant`: Exposes CRUD operations for the **Intervenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Intervenants
    * const intervenants = await prisma.intervenant.findMany()
    * ```
    */
  get intervenant(): Prisma.IntervenantDelegate<ExtArgs>;

  /**
   * `prisma.disponibiliteIntervenant`: Exposes CRUD operations for the **DisponibiliteIntervenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisponibiliteIntervenants
    * const disponibiliteIntervenants = await prisma.disponibiliteIntervenant.findMany()
    * ```
    */
  get disponibiliteIntervenant(): Prisma.DisponibiliteIntervenantDelegate<ExtArgs>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs>;

  /**
   * `prisma.salle`: Exposes CRUD operations for the **Salle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salles
    * const salles = await prisma.salle.findMany()
    * ```
    */
  get salle(): Prisma.SalleDelegate<ExtArgs>;

  /**
   * `prisma.seance`: Exposes CRUD operations for the **Seance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seances
    * const seances = await prisma.seance.findMany()
    * ```
    */
  get seance(): Prisma.SeanceDelegate<ExtArgs>;

  /**
   * `prisma.conflit`: Exposes CRUD operations for the **Conflit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conflits
    * const conflits = await prisma.conflit.findMany()
    * ```
    */
  get conflit(): Prisma.ConflitDelegate<ExtArgs>;

  /**
   * `prisma.periodeAcademique`: Exposes CRUD operations for the **PeriodeAcademique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PeriodeAcademiques
    * const periodeAcademiques = await prisma.periodeAcademique.findMany()
    * ```
    */
  get periodeAcademique(): Prisma.PeriodeAcademiqueDelegate<ExtArgs>;

  /**
   * `prisma.journalActivite`: Exposes CRUD operations for the **JournalActivite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JournalActivites
    * const journalActivites = await prisma.journalActivite.findMany()
    * ```
    */
  get journalActivite(): Prisma.JournalActiviteDelegate<ExtArgs>;

  /**
   * `prisma.activiteAcademique`: Exposes CRUD operations for the **ActiviteAcademique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActiviteAcademiques
    * const activiteAcademiques = await prisma.activiteAcademique.findMany()
    * ```
    */
  get activiteAcademique(): Prisma.ActiviteAcademiqueDelegate<ExtArgs>;

  /**
   * `prisma.indicateurAcademique`: Exposes CRUD operations for the **IndicateurAcademique** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IndicateurAcademiques
    * const indicateurAcademiques = await prisma.indicateurAcademique.findMany()
    * ```
    */
  get indicateurAcademique(): Prisma.IndicateurAcademiqueDelegate<ExtArgs>;

  /**
   * `prisma.resultatEtudiant`: Exposes CRUD operations for the **ResultatEtudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResultatEtudiants
    * const resultatEtudiants = await prisma.resultatEtudiant.findMany()
    * ```
    */
  get resultatEtudiant(): Prisma.ResultatEtudiantDelegate<ExtArgs>;

  /**
   * `prisma.evaluationEnseignement`: Exposes CRUD operations for the **EvaluationEnseignement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvaluationEnseignements
    * const evaluationEnseignements = await prisma.evaluationEnseignement.findMany()
    * ```
    */
  get evaluationEnseignement(): Prisma.EvaluationEnseignementDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.rotationWeekend`: Exposes CRUD operations for the **RotationWeekend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RotationWeekends
    * const rotationWeekends = await prisma.rotationWeekend.findMany()
    * ```
    */
  get rotationWeekend(): Prisma.RotationWeekendDelegate<ExtArgs>;

  /**
   * `prisma.disponibiliteResponsable`: Exposes CRUD operations for the **DisponibiliteResponsable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisponibiliteResponsables
    * const disponibiliteResponsables = await prisma.disponibiliteResponsable.findMany()
    * ```
    */
  get disponibiliteResponsable(): Prisma.DisponibiliteResponsableDelegate<ExtArgs>;

  /**
   * `prisma.rapportSupervision`: Exposes CRUD operations for the **RapportSupervision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RapportSupervisions
    * const rapportSupervisions = await prisma.rapportSupervision.findMany()
    * ```
    */
  get rapportSupervision(): Prisma.RapportSupervisionDelegate<ExtArgs>;

  /**
   * `prisma.statistiqueRotation`: Exposes CRUD operations for the **StatistiqueRotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatistiqueRotations
    * const statistiqueRotations = await prisma.statistiqueRotation.findMany()
    * ```
    */
  get statistiqueRotation(): Prisma.StatistiqueRotationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Programme: 'Programme',
    Intervenant: 'Intervenant',
    DisponibiliteIntervenant: 'DisponibiliteIntervenant',
    Module: 'Module',
    Salle: 'Salle',
    Seance: 'Seance',
    Conflit: 'Conflit',
    PeriodeAcademique: 'PeriodeAcademique',
    JournalActivite: 'JournalActivite',
    ActiviteAcademique: 'ActiviteAcademique',
    IndicateurAcademique: 'IndicateurAcademique',
    ResultatEtudiant: 'ResultatEtudiant',
    EvaluationEnseignement: 'EvaluationEnseignement',
    Notification: 'Notification',
    RotationWeekend: 'RotationWeekend',
    DisponibiliteResponsable: 'DisponibiliteResponsable',
    RapportSupervision: 'RapportSupervision',
    StatistiqueRotation: 'StatistiqueRotation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "programme" | "intervenant" | "disponibiliteIntervenant" | "module" | "salle" | "seance" | "conflit" | "periodeAcademique" | "journalActivite" | "activiteAcademique" | "indicateurAcademique" | "resultatEtudiant" | "evaluationEnseignement" | "notification" | "rotationWeekend" | "disponibiliteResponsable" | "rapportSupervision" | "statistiqueRotation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Programme: {
        payload: Prisma.$ProgrammePayload<ExtArgs>
        fields: Prisma.ProgrammeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgrammeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgrammeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          findFirst: {
            args: Prisma.ProgrammeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgrammeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          findMany: {
            args: Prisma.ProgrammeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>[]
          }
          create: {
            args: Prisma.ProgrammeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          createMany: {
            args: Prisma.ProgrammeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgrammeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>[]
          }
          delete: {
            args: Prisma.ProgrammeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          update: {
            args: Prisma.ProgrammeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          deleteMany: {
            args: Prisma.ProgrammeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgrammeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgrammeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgrammePayload>
          }
          aggregate: {
            args: Prisma.ProgrammeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramme>
          }
          groupBy: {
            args: Prisma.ProgrammeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgrammeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgrammeCountArgs<ExtArgs>
            result: $Utils.Optional<ProgrammeCountAggregateOutputType> | number
          }
        }
      }
      Intervenant: {
        payload: Prisma.$IntervenantPayload<ExtArgs>
        fields: Prisma.IntervenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntervenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntervenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          findFirst: {
            args: Prisma.IntervenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntervenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          findMany: {
            args: Prisma.IntervenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>[]
          }
          create: {
            args: Prisma.IntervenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          createMany: {
            args: Prisma.IntervenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntervenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>[]
          }
          delete: {
            args: Prisma.IntervenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          update: {
            args: Prisma.IntervenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          deleteMany: {
            args: Prisma.IntervenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntervenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntervenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntervenantPayload>
          }
          aggregate: {
            args: Prisma.IntervenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntervenant>
          }
          groupBy: {
            args: Prisma.IntervenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntervenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntervenantCountArgs<ExtArgs>
            result: $Utils.Optional<IntervenantCountAggregateOutputType> | number
          }
        }
      }
      DisponibiliteIntervenant: {
        payload: Prisma.$DisponibiliteIntervenantPayload<ExtArgs>
        fields: Prisma.DisponibiliteIntervenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisponibiliteIntervenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisponibiliteIntervenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          findFirst: {
            args: Prisma.DisponibiliteIntervenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisponibiliteIntervenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          findMany: {
            args: Prisma.DisponibiliteIntervenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>[]
          }
          create: {
            args: Prisma.DisponibiliteIntervenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          createMany: {
            args: Prisma.DisponibiliteIntervenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisponibiliteIntervenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>[]
          }
          delete: {
            args: Prisma.DisponibiliteIntervenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          update: {
            args: Prisma.DisponibiliteIntervenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          deleteMany: {
            args: Prisma.DisponibiliteIntervenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisponibiliteIntervenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisponibiliteIntervenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteIntervenantPayload>
          }
          aggregate: {
            args: Prisma.DisponibiliteIntervenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisponibiliteIntervenant>
          }
          groupBy: {
            args: Prisma.DisponibiliteIntervenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisponibiliteIntervenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisponibiliteIntervenantCountArgs<ExtArgs>
            result: $Utils.Optional<DisponibiliteIntervenantCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Salle: {
        payload: Prisma.$SallePayload<ExtArgs>
        fields: Prisma.SalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          findFirst: {
            args: Prisma.SalleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          findMany: {
            args: Prisma.SalleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>[]
          }
          create: {
            args: Prisma.SalleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          createMany: {
            args: Prisma.SalleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>[]
          }
          delete: {
            args: Prisma.SalleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          update: {
            args: Prisma.SalleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          deleteMany: {
            args: Prisma.SalleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SallePayload>
          }
          aggregate: {
            args: Prisma.SalleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalle>
          }
          groupBy: {
            args: Prisma.SalleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalleCountArgs<ExtArgs>
            result: $Utils.Optional<SalleCountAggregateOutputType> | number
          }
        }
      }
      Seance: {
        payload: Prisma.$SeancePayload<ExtArgs>
        fields: Prisma.SeanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          findFirst: {
            args: Prisma.SeanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          findMany: {
            args: Prisma.SeanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>[]
          }
          create: {
            args: Prisma.SeanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          createMany: {
            args: Prisma.SeanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>[]
          }
          delete: {
            args: Prisma.SeanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          update: {
            args: Prisma.SeanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          deleteMany: {
            args: Prisma.SeanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeancePayload>
          }
          aggregate: {
            args: Prisma.SeanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeance>
          }
          groupBy: {
            args: Prisma.SeanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeanceCountArgs<ExtArgs>
            result: $Utils.Optional<SeanceCountAggregateOutputType> | number
          }
        }
      }
      Conflit: {
        payload: Prisma.$ConflitPayload<ExtArgs>
        fields: Prisma.ConflitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConflitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConflitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          findFirst: {
            args: Prisma.ConflitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConflitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          findMany: {
            args: Prisma.ConflitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>[]
          }
          create: {
            args: Prisma.ConflitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          createMany: {
            args: Prisma.ConflitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConflitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>[]
          }
          delete: {
            args: Prisma.ConflitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          update: {
            args: Prisma.ConflitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          deleteMany: {
            args: Prisma.ConflitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConflitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConflitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConflitPayload>
          }
          aggregate: {
            args: Prisma.ConflitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConflit>
          }
          groupBy: {
            args: Prisma.ConflitGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConflitGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConflitCountArgs<ExtArgs>
            result: $Utils.Optional<ConflitCountAggregateOutputType> | number
          }
        }
      }
      PeriodeAcademique: {
        payload: Prisma.$PeriodeAcademiquePayload<ExtArgs>
        fields: Prisma.PeriodeAcademiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeriodeAcademiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeriodeAcademiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          findFirst: {
            args: Prisma.PeriodeAcademiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeriodeAcademiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          findMany: {
            args: Prisma.PeriodeAcademiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>[]
          }
          create: {
            args: Prisma.PeriodeAcademiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          createMany: {
            args: Prisma.PeriodeAcademiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PeriodeAcademiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>[]
          }
          delete: {
            args: Prisma.PeriodeAcademiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          update: {
            args: Prisma.PeriodeAcademiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          deleteMany: {
            args: Prisma.PeriodeAcademiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PeriodeAcademiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PeriodeAcademiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PeriodeAcademiquePayload>
          }
          aggregate: {
            args: Prisma.PeriodeAcademiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePeriodeAcademique>
          }
          groupBy: {
            args: Prisma.PeriodeAcademiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<PeriodeAcademiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.PeriodeAcademiqueCountArgs<ExtArgs>
            result: $Utils.Optional<PeriodeAcademiqueCountAggregateOutputType> | number
          }
        }
      }
      JournalActivite: {
        payload: Prisma.$JournalActivitePayload<ExtArgs>
        fields: Prisma.JournalActiviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JournalActiviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JournalActiviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          findFirst: {
            args: Prisma.JournalActiviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JournalActiviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          findMany: {
            args: Prisma.JournalActiviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>[]
          }
          create: {
            args: Prisma.JournalActiviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          createMany: {
            args: Prisma.JournalActiviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JournalActiviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>[]
          }
          delete: {
            args: Prisma.JournalActiviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          update: {
            args: Prisma.JournalActiviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          deleteMany: {
            args: Prisma.JournalActiviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JournalActiviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JournalActiviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JournalActivitePayload>
          }
          aggregate: {
            args: Prisma.JournalActiviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJournalActivite>
          }
          groupBy: {
            args: Prisma.JournalActiviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<JournalActiviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.JournalActiviteCountArgs<ExtArgs>
            result: $Utils.Optional<JournalActiviteCountAggregateOutputType> | number
          }
        }
      }
      ActiviteAcademique: {
        payload: Prisma.$ActiviteAcademiquePayload<ExtArgs>
        fields: Prisma.ActiviteAcademiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActiviteAcademiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActiviteAcademiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          findFirst: {
            args: Prisma.ActiviteAcademiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActiviteAcademiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          findMany: {
            args: Prisma.ActiviteAcademiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>[]
          }
          create: {
            args: Prisma.ActiviteAcademiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          createMany: {
            args: Prisma.ActiviteAcademiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActiviteAcademiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>[]
          }
          delete: {
            args: Prisma.ActiviteAcademiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          update: {
            args: Prisma.ActiviteAcademiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          deleteMany: {
            args: Prisma.ActiviteAcademiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActiviteAcademiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActiviteAcademiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActiviteAcademiquePayload>
          }
          aggregate: {
            args: Prisma.ActiviteAcademiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActiviteAcademique>
          }
          groupBy: {
            args: Prisma.ActiviteAcademiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActiviteAcademiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActiviteAcademiqueCountArgs<ExtArgs>
            result: $Utils.Optional<ActiviteAcademiqueCountAggregateOutputType> | number
          }
        }
      }
      IndicateurAcademique: {
        payload: Prisma.$IndicateurAcademiquePayload<ExtArgs>
        fields: Prisma.IndicateurAcademiqueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndicateurAcademiqueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndicateurAcademiqueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          findFirst: {
            args: Prisma.IndicateurAcademiqueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndicateurAcademiqueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          findMany: {
            args: Prisma.IndicateurAcademiqueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>[]
          }
          create: {
            args: Prisma.IndicateurAcademiqueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          createMany: {
            args: Prisma.IndicateurAcademiqueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndicateurAcademiqueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>[]
          }
          delete: {
            args: Prisma.IndicateurAcademiqueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          update: {
            args: Prisma.IndicateurAcademiqueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          deleteMany: {
            args: Prisma.IndicateurAcademiqueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndicateurAcademiqueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IndicateurAcademiqueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndicateurAcademiquePayload>
          }
          aggregate: {
            args: Prisma.IndicateurAcademiqueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndicateurAcademique>
          }
          groupBy: {
            args: Prisma.IndicateurAcademiqueGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndicateurAcademiqueGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndicateurAcademiqueCountArgs<ExtArgs>
            result: $Utils.Optional<IndicateurAcademiqueCountAggregateOutputType> | number
          }
        }
      }
      ResultatEtudiant: {
        payload: Prisma.$ResultatEtudiantPayload<ExtArgs>
        fields: Prisma.ResultatEtudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResultatEtudiantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResultatEtudiantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          findFirst: {
            args: Prisma.ResultatEtudiantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResultatEtudiantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          findMany: {
            args: Prisma.ResultatEtudiantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>[]
          }
          create: {
            args: Prisma.ResultatEtudiantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          createMany: {
            args: Prisma.ResultatEtudiantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResultatEtudiantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>[]
          }
          delete: {
            args: Prisma.ResultatEtudiantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          update: {
            args: Prisma.ResultatEtudiantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          deleteMany: {
            args: Prisma.ResultatEtudiantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResultatEtudiantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResultatEtudiantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResultatEtudiantPayload>
          }
          aggregate: {
            args: Prisma.ResultatEtudiantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResultatEtudiant>
          }
          groupBy: {
            args: Prisma.ResultatEtudiantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResultatEtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResultatEtudiantCountArgs<ExtArgs>
            result: $Utils.Optional<ResultatEtudiantCountAggregateOutputType> | number
          }
        }
      }
      EvaluationEnseignement: {
        payload: Prisma.$EvaluationEnseignementPayload<ExtArgs>
        fields: Prisma.EvaluationEnseignementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationEnseignementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationEnseignementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          findFirst: {
            args: Prisma.EvaluationEnseignementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationEnseignementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          findMany: {
            args: Prisma.EvaluationEnseignementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>[]
          }
          create: {
            args: Prisma.EvaluationEnseignementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          createMany: {
            args: Prisma.EvaluationEnseignementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluationEnseignementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>[]
          }
          delete: {
            args: Prisma.EvaluationEnseignementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          update: {
            args: Prisma.EvaluationEnseignementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationEnseignementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationEnseignementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationEnseignementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluationEnseignementPayload>
          }
          aggregate: {
            args: Prisma.EvaluationEnseignementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluationEnseignement>
          }
          groupBy: {
            args: Prisma.EvaluationEnseignementGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluationEnseignementGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationEnseignementCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluationEnseignementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      RotationWeekend: {
        payload: Prisma.$RotationWeekendPayload<ExtArgs>
        fields: Prisma.RotationWeekendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RotationWeekendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RotationWeekendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          findFirst: {
            args: Prisma.RotationWeekendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RotationWeekendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          findMany: {
            args: Prisma.RotationWeekendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>[]
          }
          create: {
            args: Prisma.RotationWeekendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          createMany: {
            args: Prisma.RotationWeekendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RotationWeekendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>[]
          }
          delete: {
            args: Prisma.RotationWeekendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          update: {
            args: Prisma.RotationWeekendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          deleteMany: {
            args: Prisma.RotationWeekendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RotationWeekendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RotationWeekendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RotationWeekendPayload>
          }
          aggregate: {
            args: Prisma.RotationWeekendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRotationWeekend>
          }
          groupBy: {
            args: Prisma.RotationWeekendGroupByArgs<ExtArgs>
            result: $Utils.Optional<RotationWeekendGroupByOutputType>[]
          }
          count: {
            args: Prisma.RotationWeekendCountArgs<ExtArgs>
            result: $Utils.Optional<RotationWeekendCountAggregateOutputType> | number
          }
        }
      }
      DisponibiliteResponsable: {
        payload: Prisma.$DisponibiliteResponsablePayload<ExtArgs>
        fields: Prisma.DisponibiliteResponsableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisponibiliteResponsableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisponibiliteResponsableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          findFirst: {
            args: Prisma.DisponibiliteResponsableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisponibiliteResponsableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          findMany: {
            args: Prisma.DisponibiliteResponsableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>[]
          }
          create: {
            args: Prisma.DisponibiliteResponsableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          createMany: {
            args: Prisma.DisponibiliteResponsableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisponibiliteResponsableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>[]
          }
          delete: {
            args: Prisma.DisponibiliteResponsableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          update: {
            args: Prisma.DisponibiliteResponsableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          deleteMany: {
            args: Prisma.DisponibiliteResponsableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisponibiliteResponsableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DisponibiliteResponsableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisponibiliteResponsablePayload>
          }
          aggregate: {
            args: Prisma.DisponibiliteResponsableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisponibiliteResponsable>
          }
          groupBy: {
            args: Prisma.DisponibiliteResponsableGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisponibiliteResponsableGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisponibiliteResponsableCountArgs<ExtArgs>
            result: $Utils.Optional<DisponibiliteResponsableCountAggregateOutputType> | number
          }
        }
      }
      RapportSupervision: {
        payload: Prisma.$RapportSupervisionPayload<ExtArgs>
        fields: Prisma.RapportSupervisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RapportSupervisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RapportSupervisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          findFirst: {
            args: Prisma.RapportSupervisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RapportSupervisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          findMany: {
            args: Prisma.RapportSupervisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>[]
          }
          create: {
            args: Prisma.RapportSupervisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          createMany: {
            args: Prisma.RapportSupervisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RapportSupervisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>[]
          }
          delete: {
            args: Prisma.RapportSupervisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          update: {
            args: Prisma.RapportSupervisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          deleteMany: {
            args: Prisma.RapportSupervisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RapportSupervisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RapportSupervisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RapportSupervisionPayload>
          }
          aggregate: {
            args: Prisma.RapportSupervisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRapportSupervision>
          }
          groupBy: {
            args: Prisma.RapportSupervisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RapportSupervisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RapportSupervisionCountArgs<ExtArgs>
            result: $Utils.Optional<RapportSupervisionCountAggregateOutputType> | number
          }
        }
      }
      StatistiqueRotation: {
        payload: Prisma.$StatistiqueRotationPayload<ExtArgs>
        fields: Prisma.StatistiqueRotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatistiqueRotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatistiqueRotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          findFirst: {
            args: Prisma.StatistiqueRotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatistiqueRotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          findMany: {
            args: Prisma.StatistiqueRotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>[]
          }
          create: {
            args: Prisma.StatistiqueRotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          createMany: {
            args: Prisma.StatistiqueRotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatistiqueRotationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>[]
          }
          delete: {
            args: Prisma.StatistiqueRotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          update: {
            args: Prisma.StatistiqueRotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          deleteMany: {
            args: Prisma.StatistiqueRotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatistiqueRotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StatistiqueRotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatistiqueRotationPayload>
          }
          aggregate: {
            args: Prisma.StatistiqueRotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatistiqueRotation>
          }
          groupBy: {
            args: Prisma.StatistiqueRotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatistiqueRotationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatistiqueRotationCountArgs<ExtArgs>
            result: $Utils.Optional<StatistiqueRotationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    indicateursAcademiques: number
    modules: number
    programmes: number
    rotationsResponsable: number
    rotationsSubstitut: number
    disponibilites: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicateursAcademiques?: boolean | UserCountOutputTypeCountIndicateursAcademiquesArgs
    modules?: boolean | UserCountOutputTypeCountModulesArgs
    programmes?: boolean | UserCountOutputTypeCountProgrammesArgs
    rotationsResponsable?: boolean | UserCountOutputTypeCountRotationsResponsableArgs
    rotationsSubstitut?: boolean | UserCountOutputTypeCountRotationsSubstitutArgs
    disponibilites?: boolean | UserCountOutputTypeCountDisponibilitesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIndicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicateurAcademiqueWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgrammesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgrammeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRotationsResponsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RotationWeekendWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRotationsSubstitutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RotationWeekendWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisponibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibiliteResponsableWhereInput
  }


  /**
   * Count Type ProgrammeCountOutputType
   */

  export type ProgrammeCountOutputType = {
    activitesAcademiques: number
    indicateursAcademiques: number
    modules: number
  }

  export type ProgrammeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitesAcademiques?: boolean | ProgrammeCountOutputTypeCountActivitesAcademiquesArgs
    indicateursAcademiques?: boolean | ProgrammeCountOutputTypeCountIndicateursAcademiquesArgs
    modules?: boolean | ProgrammeCountOutputTypeCountModulesArgs
  }

  // Custom InputTypes
  /**
   * ProgrammeCountOutputType without action
   */
  export type ProgrammeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgrammeCountOutputType
     */
    select?: ProgrammeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgrammeCountOutputType without action
   */
  export type ProgrammeCountOutputTypeCountActivitesAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiviteAcademiqueWhereInput
  }

  /**
   * ProgrammeCountOutputType without action
   */
  export type ProgrammeCountOutputTypeCountIndicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicateurAcademiqueWhereInput
  }

  /**
   * ProgrammeCountOutputType without action
   */
  export type ProgrammeCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }


  /**
   * Count Type IntervenantCountOutputType
   */

  export type IntervenantCountOutputType = {
    disponibilites: number
    evaluations: number
    modules: number
    seances: number
  }

  export type IntervenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disponibilites?: boolean | IntervenantCountOutputTypeCountDisponibilitesArgs
    evaluations?: boolean | IntervenantCountOutputTypeCountEvaluationsArgs
    modules?: boolean | IntervenantCountOutputTypeCountModulesArgs
    seances?: boolean | IntervenantCountOutputTypeCountSeancesArgs
  }

  // Custom InputTypes
  /**
   * IntervenantCountOutputType without action
   */
  export type IntervenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntervenantCountOutputType
     */
    select?: IntervenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntervenantCountOutputType without action
   */
  export type IntervenantCountOutputTypeCountDisponibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibiliteIntervenantWhereInput
  }

  /**
   * IntervenantCountOutputType without action
   */
  export type IntervenantCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationEnseignementWhereInput
  }

  /**
   * IntervenantCountOutputType without action
   */
  export type IntervenantCountOutputTypeCountModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * IntervenantCountOutputType without action
   */
  export type IntervenantCountOutputTypeCountSeancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeanceWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    evaluations: number
    resultatsEtudiants: number
    seances: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | ModuleCountOutputTypeCountEvaluationsArgs
    resultatsEtudiants?: boolean | ModuleCountOutputTypeCountResultatsEtudiantsArgs
    seances?: boolean | ModuleCountOutputTypeCountSeancesArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationEnseignementWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountResultatsEtudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatEtudiantWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountSeancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeanceWhereInput
  }


  /**
   * Count Type SeanceCountOutputType
   */

  export type SeanceCountOutputType = {
    conflitsAsSeance1: number
    conflitsAsSeance2: number
  }

  export type SeanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conflitsAsSeance1?: boolean | SeanceCountOutputTypeCountConflitsAsSeance1Args
    conflitsAsSeance2?: boolean | SeanceCountOutputTypeCountConflitsAsSeance2Args
  }

  // Custom InputTypes
  /**
   * SeanceCountOutputType without action
   */
  export type SeanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeanceCountOutputType
     */
    select?: SeanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeanceCountOutputType without action
   */
  export type SeanceCountOutputTypeCountConflitsAsSeance1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
  }

  /**
   * SeanceCountOutputType without action
   */
  export type SeanceCountOutputTypeCountConflitsAsSeance2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
  }


  /**
   * Count Type PeriodeAcademiqueCountOutputType
   */

  export type PeriodeAcademiqueCountOutputType = {
    activitesAcademiques: number
    indicateursAcademiques: number
  }

  export type PeriodeAcademiqueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitesAcademiques?: boolean | PeriodeAcademiqueCountOutputTypeCountActivitesAcademiquesArgs
    indicateursAcademiques?: boolean | PeriodeAcademiqueCountOutputTypeCountIndicateursAcademiquesArgs
  }

  // Custom InputTypes
  /**
   * PeriodeAcademiqueCountOutputType without action
   */
  export type PeriodeAcademiqueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademiqueCountOutputType
     */
    select?: PeriodeAcademiqueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PeriodeAcademiqueCountOutputType without action
   */
  export type PeriodeAcademiqueCountOutputTypeCountActivitesAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiviteAcademiqueWhereInput
  }

  /**
   * PeriodeAcademiqueCountOutputType without action
   */
  export type PeriodeAcademiqueCountOutputTypeCountIndicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicateurAcademiqueWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    password: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    password?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    password: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
    indicateursAcademiques?: boolean | User$indicateursAcademiquesArgs<ExtArgs>
    modules?: boolean | User$modulesArgs<ExtArgs>
    programmes?: boolean | User$programmesArgs<ExtArgs>
    rotationsResponsable?: boolean | User$rotationsResponsableArgs<ExtArgs>
    rotationsSubstitut?: boolean | User$rotationsSubstitutArgs<ExtArgs>
    disponibilites?: boolean | User$disponibilitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    password?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicateursAcademiques?: boolean | User$indicateursAcademiquesArgs<ExtArgs>
    modules?: boolean | User$modulesArgs<ExtArgs>
    programmes?: boolean | User$programmesArgs<ExtArgs>
    rotationsResponsable?: boolean | User$rotationsResponsableArgs<ExtArgs>
    rotationsSubstitut?: boolean | User$rotationsSubstitutArgs<ExtArgs>
    disponibilites?: boolean | User$disponibilitesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      indicateursAcademiques: Prisma.$IndicateurAcademiquePayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      programmes: Prisma.$ProgrammePayload<ExtArgs>[]
      rotationsResponsable: Prisma.$RotationWeekendPayload<ExtArgs>[]
      rotationsSubstitut: Prisma.$RotationWeekendPayload<ExtArgs>[]
      disponibilites: Prisma.$DisponibiliteResponsablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      password: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    indicateursAcademiques<T extends User$indicateursAcademiquesArgs<ExtArgs> = {}>(args?: Subset<T, User$indicateursAcademiquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends User$modulesArgs<ExtArgs> = {}>(args?: Subset<T, User$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    programmes<T extends User$programmesArgs<ExtArgs> = {}>(args?: Subset<T, User$programmesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findMany"> | Null>
    rotationsResponsable<T extends User$rotationsResponsableArgs<ExtArgs> = {}>(args?: Subset<T, User$rotationsResponsableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findMany"> | Null>
    rotationsSubstitut<T extends User$rotationsSubstitutArgs<ExtArgs> = {}>(args?: Subset<T, User$rotationsSubstitutArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findMany"> | Null>
    disponibilites<T extends User$disponibilitesArgs<ExtArgs> = {}>(args?: Subset<T, User$disponibilitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.indicateursAcademiques
   */
  export type User$indicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    where?: IndicateurAcademiqueWhereInput
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    cursor?: IndicateurAcademiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * User.modules
   */
  export type User$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * User.programmes
   */
  export type User$programmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    where?: ProgrammeWhereInput
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    cursor?: ProgrammeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * User.rotationsResponsable
   */
  export type User$rotationsResponsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    where?: RotationWeekendWhereInput
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    cursor?: RotationWeekendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RotationWeekendScalarFieldEnum | RotationWeekendScalarFieldEnum[]
  }

  /**
   * User.rotationsSubstitut
   */
  export type User$rotationsSubstitutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    where?: RotationWeekendWhereInput
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    cursor?: RotationWeekendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RotationWeekendScalarFieldEnum | RotationWeekendScalarFieldEnum[]
  }

  /**
   * User.disponibilites
   */
  export type User$disponibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    where?: DisponibiliteResponsableWhereInput
    orderBy?: DisponibiliteResponsableOrderByWithRelationInput | DisponibiliteResponsableOrderByWithRelationInput[]
    cursor?: DisponibiliteResponsableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisponibiliteResponsableScalarFieldEnum | DisponibiliteResponsableScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Programme
   */

  export type AggregateProgramme = {
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  export type ProgrammeAvgAggregateOutputType = {
    progression: number | null
    totalVHT: number | null
  }

  export type ProgrammeSumAggregateOutputType = {
    progression: number | null
    totalVHT: number | null
  }

  export type ProgrammeMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    semestre: $Enums.Semestre | null
    niveau: string | null
    dateDebut: Date | null
    dateFin: Date | null
    status: $Enums.StatusProgramme | null
    progression: number | null
    totalVHT: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgrammeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    semestre: $Enums.Semestre | null
    niveau: string | null
    dateDebut: Date | null
    dateFin: Date | null
    status: $Enums.StatusProgramme | null
    progression: number | null
    totalVHT: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProgrammeCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    semestre: number
    niveau: number
    dateDebut: number
    dateFin: number
    status: number
    progression: number
    totalVHT: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProgrammeAvgAggregateInputType = {
    progression?: true
    totalVHT?: true
  }

  export type ProgrammeSumAggregateInputType = {
    progression?: true
    totalVHT?: true
  }

  export type ProgrammeMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    semestre?: true
    niveau?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    progression?: true
    totalVHT?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgrammeMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    semestre?: true
    niveau?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    progression?: true
    totalVHT?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProgrammeCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    semestre?: true
    niveau?: true
    dateDebut?: true
    dateFin?: true
    status?: true
    progression?: true
    totalVHT?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProgrammeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programme to aggregate.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programmes
    **/
    _count?: true | ProgrammeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgrammeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgrammeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgrammeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgrammeMaxAggregateInputType
  }

  export type GetProgrammeAggregateType<T extends ProgrammeAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramme[P]>
      : GetScalarType<T[P], AggregateProgramme[P]>
  }




  export type ProgrammeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgrammeWhereInput
    orderBy?: ProgrammeOrderByWithAggregationInput | ProgrammeOrderByWithAggregationInput[]
    by: ProgrammeScalarFieldEnum[] | ProgrammeScalarFieldEnum
    having?: ProgrammeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgrammeCountAggregateInputType | true
    _avg?: ProgrammeAvgAggregateInputType
    _sum?: ProgrammeSumAggregateInputType
    _min?: ProgrammeMinAggregateInputType
    _max?: ProgrammeMaxAggregateInputType
  }

  export type ProgrammeGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date
    dateFin: Date
    status: $Enums.StatusProgramme
    progression: number
    totalVHT: number
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ProgrammeCountAggregateOutputType | null
    _avg: ProgrammeAvgAggregateOutputType | null
    _sum: ProgrammeSumAggregateOutputType | null
    _min: ProgrammeMinAggregateOutputType | null
    _max: ProgrammeMaxAggregateOutputType | null
  }

  type GetProgrammeGroupByPayload<T extends ProgrammeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgrammeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgrammeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
            : GetScalarType<T[P], ProgrammeGroupByOutputType[P]>
        }
      >
    >


  export type ProgrammeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semestre?: boolean
    niveau?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    progression?: boolean
    totalVHT?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activitesAcademiques?: boolean | Programme$activitesAcademiquesArgs<ExtArgs>
    indicateursAcademiques?: boolean | Programme$indicateursAcademiquesArgs<ExtArgs>
    modules?: boolean | Programme$modulesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProgrammeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programme"]>

  export type ProgrammeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semestre?: boolean
    niveau?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    progression?: boolean
    totalVHT?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programme"]>

  export type ProgrammeSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    semestre?: boolean
    niveau?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    status?: boolean
    progression?: boolean
    totalVHT?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProgrammeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitesAcademiques?: boolean | Programme$activitesAcademiquesArgs<ExtArgs>
    indicateursAcademiques?: boolean | Programme$indicateursAcademiquesArgs<ExtArgs>
    modules?: boolean | Programme$modulesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | ProgrammeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgrammeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProgrammePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Programme"
    objects: {
      activitesAcademiques: Prisma.$ActiviteAcademiquePayload<ExtArgs>[]
      indicateursAcademiques: Prisma.$IndicateurAcademiquePayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      semestre: $Enums.Semestre
      niveau: string
      dateDebut: Date
      dateFin: Date
      status: $Enums.StatusProgramme
      progression: number
      totalVHT: number
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["programme"]>
    composites: {}
  }

  type ProgrammeGetPayload<S extends boolean | null | undefined | ProgrammeDefaultArgs> = $Result.GetResult<Prisma.$ProgrammePayload, S>

  type ProgrammeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgrammeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgrammeCountAggregateInputType | true
    }

  export interface ProgrammeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Programme'], meta: { name: 'Programme' } }
    /**
     * Find zero or one Programme that matches the filter.
     * @param {ProgrammeFindUniqueArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgrammeFindUniqueArgs>(args: SelectSubset<T, ProgrammeFindUniqueArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Programme that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgrammeFindUniqueOrThrowArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgrammeFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgrammeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Programme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindFirstArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgrammeFindFirstArgs>(args?: SelectSubset<T, ProgrammeFindFirstArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Programme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindFirstOrThrowArgs} args - Arguments to find a Programme
     * @example
     * // Get one Programme
     * const programme = await prisma.programme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgrammeFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgrammeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programmes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programmes
     * const programmes = await prisma.programme.findMany()
     * 
     * // Get first 10 Programmes
     * const programmes = await prisma.programme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programmeWithIdOnly = await prisma.programme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgrammeFindManyArgs>(args?: SelectSubset<T, ProgrammeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Programme.
     * @param {ProgrammeCreateArgs} args - Arguments to create a Programme.
     * @example
     * // Create one Programme
     * const Programme = await prisma.programme.create({
     *   data: {
     *     // ... data to create a Programme
     *   }
     * })
     * 
     */
    create<T extends ProgrammeCreateArgs>(args: SelectSubset<T, ProgrammeCreateArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programmes.
     * @param {ProgrammeCreateManyArgs} args - Arguments to create many Programmes.
     * @example
     * // Create many Programmes
     * const programme = await prisma.programme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgrammeCreateManyArgs>(args?: SelectSubset<T, ProgrammeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programmes and returns the data saved in the database.
     * @param {ProgrammeCreateManyAndReturnArgs} args - Arguments to create many Programmes.
     * @example
     * // Create many Programmes
     * const programme = await prisma.programme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programmes and only return the `id`
     * const programmeWithIdOnly = await prisma.programme.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgrammeCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgrammeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Programme.
     * @param {ProgrammeDeleteArgs} args - Arguments to delete one Programme.
     * @example
     * // Delete one Programme
     * const Programme = await prisma.programme.delete({
     *   where: {
     *     // ... filter to delete one Programme
     *   }
     * })
     * 
     */
    delete<T extends ProgrammeDeleteArgs>(args: SelectSubset<T, ProgrammeDeleteArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Programme.
     * @param {ProgrammeUpdateArgs} args - Arguments to update one Programme.
     * @example
     * // Update one Programme
     * const programme = await prisma.programme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgrammeUpdateArgs>(args: SelectSubset<T, ProgrammeUpdateArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programmes.
     * @param {ProgrammeDeleteManyArgs} args - Arguments to filter Programmes to delete.
     * @example
     * // Delete a few Programmes
     * const { count } = await prisma.programme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgrammeDeleteManyArgs>(args?: SelectSubset<T, ProgrammeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programmes
     * const programme = await prisma.programme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgrammeUpdateManyArgs>(args: SelectSubset<T, ProgrammeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Programme.
     * @param {ProgrammeUpsertArgs} args - Arguments to update or create a Programme.
     * @example
     * // Update or create a Programme
     * const programme = await prisma.programme.upsert({
     *   create: {
     *     // ... data to create a Programme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programme we want to update
     *   }
     * })
     */
    upsert<T extends ProgrammeUpsertArgs>(args: SelectSubset<T, ProgrammeUpsertArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeCountArgs} args - Arguments to filter Programmes to count.
     * @example
     * // Count the number of Programmes
     * const count = await prisma.programme.count({
     *   where: {
     *     // ... the filter for the Programmes we want to count
     *   }
     * })
    **/
    count<T extends ProgrammeCountArgs>(
      args?: Subset<T, ProgrammeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgrammeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgrammeAggregateArgs>(args: Subset<T, ProgrammeAggregateArgs>): Prisma.PrismaPromise<GetProgrammeAggregateType<T>>

    /**
     * Group by Programme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgrammeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgrammeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgrammeGroupByArgs['orderBy'] }
        : { orderBy?: ProgrammeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgrammeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgrammeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Programme model
   */
  readonly fields: ProgrammeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgrammeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitesAcademiques<T extends Programme$activitesAcademiquesArgs<ExtArgs> = {}>(args?: Subset<T, Programme$activitesAcademiquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findMany"> | Null>
    indicateursAcademiques<T extends Programme$indicateursAcademiquesArgs<ExtArgs> = {}>(args?: Subset<T, Programme$indicateursAcademiquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends Programme$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Programme$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Programme model
   */ 
  interface ProgrammeFieldRefs {
    readonly id: FieldRef<"Programme", 'String'>
    readonly name: FieldRef<"Programme", 'String'>
    readonly code: FieldRef<"Programme", 'String'>
    readonly description: FieldRef<"Programme", 'String'>
    readonly semestre: FieldRef<"Programme", 'Semestre'>
    readonly niveau: FieldRef<"Programme", 'String'>
    readonly dateDebut: FieldRef<"Programme", 'DateTime'>
    readonly dateFin: FieldRef<"Programme", 'DateTime'>
    readonly status: FieldRef<"Programme", 'StatusProgramme'>
    readonly progression: FieldRef<"Programme", 'Int'>
    readonly totalVHT: FieldRef<"Programme", 'Int'>
    readonly userId: FieldRef<"Programme", 'String'>
    readonly createdAt: FieldRef<"Programme", 'DateTime'>
    readonly updatedAt: FieldRef<"Programme", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Programme findUnique
   */
  export type ProgrammeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme findUniqueOrThrow
   */
  export type ProgrammeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme findFirst
   */
  export type ProgrammeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programmes.
     */
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme findFirstOrThrow
   */
  export type ProgrammeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter, which Programme to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programmes.
     */
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme findMany
   */
  export type ProgrammeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter, which Programmes to fetch.
     */
    where?: ProgrammeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programmes to fetch.
     */
    orderBy?: ProgrammeOrderByWithRelationInput | ProgrammeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programmes.
     */
    cursor?: ProgrammeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programmes.
     */
    skip?: number
    distinct?: ProgrammeScalarFieldEnum | ProgrammeScalarFieldEnum[]
  }

  /**
   * Programme create
   */
  export type ProgrammeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * The data needed to create a Programme.
     */
    data: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
  }

  /**
   * Programme createMany
   */
  export type ProgrammeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programmes.
     */
    data: ProgrammeCreateManyInput | ProgrammeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programme createManyAndReturn
   */
  export type ProgrammeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programmes.
     */
    data: ProgrammeCreateManyInput | ProgrammeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Programme update
   */
  export type ProgrammeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * The data needed to update a Programme.
     */
    data: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
    /**
     * Choose, which Programme to update.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme updateMany
   */
  export type ProgrammeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programmes.
     */
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyInput>
    /**
     * Filter which Programmes to update
     */
    where?: ProgrammeWhereInput
  }

  /**
   * Programme upsert
   */
  export type ProgrammeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * The filter to search for the Programme to update in case it exists.
     */
    where: ProgrammeWhereUniqueInput
    /**
     * In case the Programme found by the `where` argument doesn't exist, create a new Programme with this data.
     */
    create: XOR<ProgrammeCreateInput, ProgrammeUncheckedCreateInput>
    /**
     * In case the Programme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgrammeUpdateInput, ProgrammeUncheckedUpdateInput>
  }

  /**
   * Programme delete
   */
  export type ProgrammeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
    /**
     * Filter which Programme to delete.
     */
    where: ProgrammeWhereUniqueInput
  }

  /**
   * Programme deleteMany
   */
  export type ProgrammeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programmes to delete
     */
    where?: ProgrammeWhereInput
  }

  /**
   * Programme.activitesAcademiques
   */
  export type Programme$activitesAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    where?: ActiviteAcademiqueWhereInput
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    cursor?: ActiviteAcademiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiviteAcademiqueScalarFieldEnum | ActiviteAcademiqueScalarFieldEnum[]
  }

  /**
   * Programme.indicateursAcademiques
   */
  export type Programme$indicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    where?: IndicateurAcademiqueWhereInput
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    cursor?: IndicateurAcademiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * Programme.modules
   */
  export type Programme$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Programme without action
   */
  export type ProgrammeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programme
     */
    select?: ProgrammeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgrammeInclude<ExtArgs> | null
  }


  /**
   * Model Intervenant
   */

  export type AggregateIntervenant = {
    _count: IntervenantCountAggregateOutputType | null
    _avg: IntervenantAvgAggregateOutputType | null
    _sum: IntervenantSumAggregateOutputType | null
    _min: IntervenantMinAggregateOutputType | null
    _max: IntervenantMaxAggregateOutputType | null
  }

  export type IntervenantAvgAggregateOutputType = {
    heuresMaxJour: number | null
    heuresMaxSemaine: number | null
  }

  export type IntervenantSumAggregateOutputType = {
    heuresMaxJour: number | null
    heuresMaxSemaine: number | null
  }

  export type IntervenantMinAggregateOutputType = {
    id: string | null
    civilite: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    grade: string | null
    specialite: string | null
    etablissement: string | null
    disponible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creneauxPreferences: string | null
    heuresMaxJour: number | null
    heuresMaxSemaine: number | null
    joursPreferences: string | null
  }

  export type IntervenantMaxAggregateOutputType = {
    id: string | null
    civilite: string | null
    nom: string | null
    prenom: string | null
    email: string | null
    telephone: string | null
    grade: string | null
    specialite: string | null
    etablissement: string | null
    disponible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    creneauxPreferences: string | null
    heuresMaxJour: number | null
    heuresMaxSemaine: number | null
    joursPreferences: string | null
  }

  export type IntervenantCountAggregateOutputType = {
    id: number
    civilite: number
    nom: number
    prenom: number
    email: number
    telephone: number
    grade: number
    specialite: number
    etablissement: number
    disponible: number
    createdAt: number
    updatedAt: number
    creneauxPreferences: number
    heuresMaxJour: number
    heuresMaxSemaine: number
    joursPreferences: number
    _all: number
  }


  export type IntervenantAvgAggregateInputType = {
    heuresMaxJour?: true
    heuresMaxSemaine?: true
  }

  export type IntervenantSumAggregateInputType = {
    heuresMaxJour?: true
    heuresMaxSemaine?: true
  }

  export type IntervenantMinAggregateInputType = {
    id?: true
    civilite?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    grade?: true
    specialite?: true
    etablissement?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
    creneauxPreferences?: true
    heuresMaxJour?: true
    heuresMaxSemaine?: true
    joursPreferences?: true
  }

  export type IntervenantMaxAggregateInputType = {
    id?: true
    civilite?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    grade?: true
    specialite?: true
    etablissement?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
    creneauxPreferences?: true
    heuresMaxJour?: true
    heuresMaxSemaine?: true
    joursPreferences?: true
  }

  export type IntervenantCountAggregateInputType = {
    id?: true
    civilite?: true
    nom?: true
    prenom?: true
    email?: true
    telephone?: true
    grade?: true
    specialite?: true
    etablissement?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
    creneauxPreferences?: true
    heuresMaxJour?: true
    heuresMaxSemaine?: true
    joursPreferences?: true
    _all?: true
  }

  export type IntervenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervenant to aggregate.
     */
    where?: IntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intervenants to fetch.
     */
    orderBy?: IntervenantOrderByWithRelationInput | IntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Intervenants
    **/
    _count?: true | IntervenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntervenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntervenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntervenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntervenantMaxAggregateInputType
  }

  export type GetIntervenantAggregateType<T extends IntervenantAggregateArgs> = {
        [P in keyof T & keyof AggregateIntervenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntervenant[P]>
      : GetScalarType<T[P], AggregateIntervenant[P]>
  }




  export type IntervenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntervenantWhereInput
    orderBy?: IntervenantOrderByWithAggregationInput | IntervenantOrderByWithAggregationInput[]
    by: IntervenantScalarFieldEnum[] | IntervenantScalarFieldEnum
    having?: IntervenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntervenantCountAggregateInputType | true
    _avg?: IntervenantAvgAggregateInputType
    _sum?: IntervenantSumAggregateInputType
    _min?: IntervenantMinAggregateInputType
    _max?: IntervenantMaxAggregateInputType
  }

  export type IntervenantGroupByOutputType = {
    id: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone: string | null
    grade: string | null
    specialite: string | null
    etablissement: string | null
    disponible: boolean
    createdAt: Date
    updatedAt: Date
    creneauxPreferences: string | null
    heuresMaxJour: number
    heuresMaxSemaine: number
    joursPreferences: string | null
    _count: IntervenantCountAggregateOutputType | null
    _avg: IntervenantAvgAggregateOutputType | null
    _sum: IntervenantSumAggregateOutputType | null
    _min: IntervenantMinAggregateOutputType | null
    _max: IntervenantMaxAggregateOutputType | null
  }

  type GetIntervenantGroupByPayload<T extends IntervenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntervenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntervenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntervenantGroupByOutputType[P]>
            : GetScalarType<T[P], IntervenantGroupByOutputType[P]>
        }
      >
    >


  export type IntervenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    civilite?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    grade?: boolean
    specialite?: boolean
    etablissement?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creneauxPreferences?: boolean
    heuresMaxJour?: boolean
    heuresMaxSemaine?: boolean
    joursPreferences?: boolean
    disponibilites?: boolean | Intervenant$disponibilitesArgs<ExtArgs>
    evaluations?: boolean | Intervenant$evaluationsArgs<ExtArgs>
    modules?: boolean | Intervenant$modulesArgs<ExtArgs>
    seances?: boolean | Intervenant$seancesArgs<ExtArgs>
    _count?: boolean | IntervenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["intervenant"]>

  export type IntervenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    civilite?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    grade?: boolean
    specialite?: boolean
    etablissement?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creneauxPreferences?: boolean
    heuresMaxJour?: boolean
    heuresMaxSemaine?: boolean
    joursPreferences?: boolean
  }, ExtArgs["result"]["intervenant"]>

  export type IntervenantSelectScalar = {
    id?: boolean
    civilite?: boolean
    nom?: boolean
    prenom?: boolean
    email?: boolean
    telephone?: boolean
    grade?: boolean
    specialite?: boolean
    etablissement?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creneauxPreferences?: boolean
    heuresMaxJour?: boolean
    heuresMaxSemaine?: boolean
    joursPreferences?: boolean
  }

  export type IntervenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disponibilites?: boolean | Intervenant$disponibilitesArgs<ExtArgs>
    evaluations?: boolean | Intervenant$evaluationsArgs<ExtArgs>
    modules?: boolean | Intervenant$modulesArgs<ExtArgs>
    seances?: boolean | Intervenant$seancesArgs<ExtArgs>
    _count?: boolean | IntervenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IntervenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IntervenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Intervenant"
    objects: {
      disponibilites: Prisma.$DisponibiliteIntervenantPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationEnseignementPayload<ExtArgs>[]
      modules: Prisma.$ModulePayload<ExtArgs>[]
      seances: Prisma.$SeancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      civilite: string
      nom: string
      prenom: string
      email: string
      telephone: string | null
      grade: string | null
      specialite: string | null
      etablissement: string | null
      disponible: boolean
      createdAt: Date
      updatedAt: Date
      creneauxPreferences: string | null
      heuresMaxJour: number
      heuresMaxSemaine: number
      joursPreferences: string | null
    }, ExtArgs["result"]["intervenant"]>
    composites: {}
  }

  type IntervenantGetPayload<S extends boolean | null | undefined | IntervenantDefaultArgs> = $Result.GetResult<Prisma.$IntervenantPayload, S>

  type IntervenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntervenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntervenantCountAggregateInputType | true
    }

  export interface IntervenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Intervenant'], meta: { name: 'Intervenant' } }
    /**
     * Find zero or one Intervenant that matches the filter.
     * @param {IntervenantFindUniqueArgs} args - Arguments to find a Intervenant
     * @example
     * // Get one Intervenant
     * const intervenant = await prisma.intervenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntervenantFindUniqueArgs>(args: SelectSubset<T, IntervenantFindUniqueArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Intervenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntervenantFindUniqueOrThrowArgs} args - Arguments to find a Intervenant
     * @example
     * // Get one Intervenant
     * const intervenant = await prisma.intervenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntervenantFindUniqueOrThrowArgs>(args: SelectSubset<T, IntervenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Intervenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantFindFirstArgs} args - Arguments to find a Intervenant
     * @example
     * // Get one Intervenant
     * const intervenant = await prisma.intervenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntervenantFindFirstArgs>(args?: SelectSubset<T, IntervenantFindFirstArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Intervenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantFindFirstOrThrowArgs} args - Arguments to find a Intervenant
     * @example
     * // Get one Intervenant
     * const intervenant = await prisma.intervenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntervenantFindFirstOrThrowArgs>(args?: SelectSubset<T, IntervenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Intervenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Intervenants
     * const intervenants = await prisma.intervenant.findMany()
     * 
     * // Get first 10 Intervenants
     * const intervenants = await prisma.intervenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const intervenantWithIdOnly = await prisma.intervenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntervenantFindManyArgs>(args?: SelectSubset<T, IntervenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Intervenant.
     * @param {IntervenantCreateArgs} args - Arguments to create a Intervenant.
     * @example
     * // Create one Intervenant
     * const Intervenant = await prisma.intervenant.create({
     *   data: {
     *     // ... data to create a Intervenant
     *   }
     * })
     * 
     */
    create<T extends IntervenantCreateArgs>(args: SelectSubset<T, IntervenantCreateArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Intervenants.
     * @param {IntervenantCreateManyArgs} args - Arguments to create many Intervenants.
     * @example
     * // Create many Intervenants
     * const intervenant = await prisma.intervenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntervenantCreateManyArgs>(args?: SelectSubset<T, IntervenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Intervenants and returns the data saved in the database.
     * @param {IntervenantCreateManyAndReturnArgs} args - Arguments to create many Intervenants.
     * @example
     * // Create many Intervenants
     * const intervenant = await prisma.intervenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Intervenants and only return the `id`
     * const intervenantWithIdOnly = await prisma.intervenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntervenantCreateManyAndReturnArgs>(args?: SelectSubset<T, IntervenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Intervenant.
     * @param {IntervenantDeleteArgs} args - Arguments to delete one Intervenant.
     * @example
     * // Delete one Intervenant
     * const Intervenant = await prisma.intervenant.delete({
     *   where: {
     *     // ... filter to delete one Intervenant
     *   }
     * })
     * 
     */
    delete<T extends IntervenantDeleteArgs>(args: SelectSubset<T, IntervenantDeleteArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Intervenant.
     * @param {IntervenantUpdateArgs} args - Arguments to update one Intervenant.
     * @example
     * // Update one Intervenant
     * const intervenant = await prisma.intervenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntervenantUpdateArgs>(args: SelectSubset<T, IntervenantUpdateArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Intervenants.
     * @param {IntervenantDeleteManyArgs} args - Arguments to filter Intervenants to delete.
     * @example
     * // Delete a few Intervenants
     * const { count } = await prisma.intervenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntervenantDeleteManyArgs>(args?: SelectSubset<T, IntervenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Intervenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Intervenants
     * const intervenant = await prisma.intervenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntervenantUpdateManyArgs>(args: SelectSubset<T, IntervenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Intervenant.
     * @param {IntervenantUpsertArgs} args - Arguments to update or create a Intervenant.
     * @example
     * // Update or create a Intervenant
     * const intervenant = await prisma.intervenant.upsert({
     *   create: {
     *     // ... data to create a Intervenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Intervenant we want to update
     *   }
     * })
     */
    upsert<T extends IntervenantUpsertArgs>(args: SelectSubset<T, IntervenantUpsertArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Intervenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantCountArgs} args - Arguments to filter Intervenants to count.
     * @example
     * // Count the number of Intervenants
     * const count = await prisma.intervenant.count({
     *   where: {
     *     // ... the filter for the Intervenants we want to count
     *   }
     * })
    **/
    count<T extends IntervenantCountArgs>(
      args?: Subset<T, IntervenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntervenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Intervenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntervenantAggregateArgs>(args: Subset<T, IntervenantAggregateArgs>): Prisma.PrismaPromise<GetIntervenantAggregateType<T>>

    /**
     * Group by Intervenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntervenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntervenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntervenantGroupByArgs['orderBy'] }
        : { orderBy?: IntervenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntervenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntervenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Intervenant model
   */
  readonly fields: IntervenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Intervenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntervenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    disponibilites<T extends Intervenant$disponibilitesArgs<ExtArgs> = {}>(args?: Subset<T, Intervenant$disponibilitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findMany"> | Null>
    evaluations<T extends Intervenant$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Intervenant$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findMany"> | Null>
    modules<T extends Intervenant$modulesArgs<ExtArgs> = {}>(args?: Subset<T, Intervenant$modulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany"> | Null>
    seances<T extends Intervenant$seancesArgs<ExtArgs> = {}>(args?: Subset<T, Intervenant$seancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Intervenant model
   */ 
  interface IntervenantFieldRefs {
    readonly id: FieldRef<"Intervenant", 'String'>
    readonly civilite: FieldRef<"Intervenant", 'String'>
    readonly nom: FieldRef<"Intervenant", 'String'>
    readonly prenom: FieldRef<"Intervenant", 'String'>
    readonly email: FieldRef<"Intervenant", 'String'>
    readonly telephone: FieldRef<"Intervenant", 'String'>
    readonly grade: FieldRef<"Intervenant", 'String'>
    readonly specialite: FieldRef<"Intervenant", 'String'>
    readonly etablissement: FieldRef<"Intervenant", 'String'>
    readonly disponible: FieldRef<"Intervenant", 'Boolean'>
    readonly createdAt: FieldRef<"Intervenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Intervenant", 'DateTime'>
    readonly creneauxPreferences: FieldRef<"Intervenant", 'String'>
    readonly heuresMaxJour: FieldRef<"Intervenant", 'Int'>
    readonly heuresMaxSemaine: FieldRef<"Intervenant", 'Int'>
    readonly joursPreferences: FieldRef<"Intervenant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Intervenant findUnique
   */
  export type IntervenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter, which Intervenant to fetch.
     */
    where: IntervenantWhereUniqueInput
  }

  /**
   * Intervenant findUniqueOrThrow
   */
  export type IntervenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter, which Intervenant to fetch.
     */
    where: IntervenantWhereUniqueInput
  }

  /**
   * Intervenant findFirst
   */
  export type IntervenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter, which Intervenant to fetch.
     */
    where?: IntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intervenants to fetch.
     */
    orderBy?: IntervenantOrderByWithRelationInput | IntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Intervenants.
     */
    cursor?: IntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Intervenants.
     */
    distinct?: IntervenantScalarFieldEnum | IntervenantScalarFieldEnum[]
  }

  /**
   * Intervenant findFirstOrThrow
   */
  export type IntervenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter, which Intervenant to fetch.
     */
    where?: IntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intervenants to fetch.
     */
    orderBy?: IntervenantOrderByWithRelationInput | IntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Intervenants.
     */
    cursor?: IntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Intervenants.
     */
    distinct?: IntervenantScalarFieldEnum | IntervenantScalarFieldEnum[]
  }

  /**
   * Intervenant findMany
   */
  export type IntervenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter, which Intervenants to fetch.
     */
    where?: IntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Intervenants to fetch.
     */
    orderBy?: IntervenantOrderByWithRelationInput | IntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Intervenants.
     */
    cursor?: IntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Intervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Intervenants.
     */
    skip?: number
    distinct?: IntervenantScalarFieldEnum | IntervenantScalarFieldEnum[]
  }

  /**
   * Intervenant create
   */
  export type IntervenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Intervenant.
     */
    data: XOR<IntervenantCreateInput, IntervenantUncheckedCreateInput>
  }

  /**
   * Intervenant createMany
   */
  export type IntervenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Intervenants.
     */
    data: IntervenantCreateManyInput | IntervenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervenant createManyAndReturn
   */
  export type IntervenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Intervenants.
     */
    data: IntervenantCreateManyInput | IntervenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Intervenant update
   */
  export type IntervenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Intervenant.
     */
    data: XOR<IntervenantUpdateInput, IntervenantUncheckedUpdateInput>
    /**
     * Choose, which Intervenant to update.
     */
    where: IntervenantWhereUniqueInput
  }

  /**
   * Intervenant updateMany
   */
  export type IntervenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Intervenants.
     */
    data: XOR<IntervenantUpdateManyMutationInput, IntervenantUncheckedUpdateManyInput>
    /**
     * Filter which Intervenants to update
     */
    where?: IntervenantWhereInput
  }

  /**
   * Intervenant upsert
   */
  export type IntervenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Intervenant to update in case it exists.
     */
    where: IntervenantWhereUniqueInput
    /**
     * In case the Intervenant found by the `where` argument doesn't exist, create a new Intervenant with this data.
     */
    create: XOR<IntervenantCreateInput, IntervenantUncheckedCreateInput>
    /**
     * In case the Intervenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntervenantUpdateInput, IntervenantUncheckedUpdateInput>
  }

  /**
   * Intervenant delete
   */
  export type IntervenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    /**
     * Filter which Intervenant to delete.
     */
    where: IntervenantWhereUniqueInput
  }

  /**
   * Intervenant deleteMany
   */
  export type IntervenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Intervenants to delete
     */
    where?: IntervenantWhereInput
  }

  /**
   * Intervenant.disponibilites
   */
  export type Intervenant$disponibilitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    where?: DisponibiliteIntervenantWhereInput
    orderBy?: DisponibiliteIntervenantOrderByWithRelationInput | DisponibiliteIntervenantOrderByWithRelationInput[]
    cursor?: DisponibiliteIntervenantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisponibiliteIntervenantScalarFieldEnum | DisponibiliteIntervenantScalarFieldEnum[]
  }

  /**
   * Intervenant.evaluations
   */
  export type Intervenant$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    where?: EvaluationEnseignementWhereInput
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    cursor?: EvaluationEnseignementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationEnseignementScalarFieldEnum | EvaluationEnseignementScalarFieldEnum[]
  }

  /**
   * Intervenant.modules
   */
  export type Intervenant$modulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Intervenant.seances
   */
  export type Intervenant$seancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    where?: SeanceWhereInput
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    cursor?: SeanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeanceScalarFieldEnum | SeanceScalarFieldEnum[]
  }

  /**
   * Intervenant without action
   */
  export type IntervenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
  }


  /**
   * Model DisponibiliteIntervenant
   */

  export type AggregateDisponibiliteIntervenant = {
    _count: DisponibiliteIntervenantCountAggregateOutputType | null
    _avg: DisponibiliteIntervenantAvgAggregateOutputType | null
    _sum: DisponibiliteIntervenantSumAggregateOutputType | null
    _min: DisponibiliteIntervenantMinAggregateOutputType | null
    _max: DisponibiliteIntervenantMaxAggregateOutputType | null
  }

  export type DisponibiliteIntervenantAvgAggregateOutputType = {
    jourSemaine: number | null
  }

  export type DisponibiliteIntervenantSumAggregateOutputType = {
    jourSemaine: number | null
  }

  export type DisponibiliteIntervenantMinAggregateOutputType = {
    id: string | null
    jourSemaine: number | null
    heureDebut: string | null
    heureFin: string | null
    type: $Enums.TypeDisponibilite | null
    dateDebut: Date | null
    dateFin: Date | null
    recurrent: boolean | null
    intervenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibiliteIntervenantMaxAggregateOutputType = {
    id: string | null
    jourSemaine: number | null
    heureDebut: string | null
    heureFin: string | null
    type: $Enums.TypeDisponibilite | null
    dateDebut: Date | null
    dateFin: Date | null
    recurrent: boolean | null
    intervenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibiliteIntervenantCountAggregateOutputType = {
    id: number
    jourSemaine: number
    heureDebut: number
    heureFin: number
    type: number
    dateDebut: number
    dateFin: number
    recurrent: number
    intervenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisponibiliteIntervenantAvgAggregateInputType = {
    jourSemaine?: true
  }

  export type DisponibiliteIntervenantSumAggregateInputType = {
    jourSemaine?: true
  }

  export type DisponibiliteIntervenantMinAggregateInputType = {
    id?: true
    jourSemaine?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    recurrent?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibiliteIntervenantMaxAggregateInputType = {
    id?: true
    jourSemaine?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    recurrent?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibiliteIntervenantCountAggregateInputType = {
    id?: true
    jourSemaine?: true
    heureDebut?: true
    heureFin?: true
    type?: true
    dateDebut?: true
    dateFin?: true
    recurrent?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisponibiliteIntervenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibiliteIntervenant to aggregate.
     */
    where?: DisponibiliteIntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteIntervenants to fetch.
     */
    orderBy?: DisponibiliteIntervenantOrderByWithRelationInput | DisponibiliteIntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisponibiliteIntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteIntervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteIntervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisponibiliteIntervenants
    **/
    _count?: true | DisponibiliteIntervenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisponibiliteIntervenantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisponibiliteIntervenantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisponibiliteIntervenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisponibiliteIntervenantMaxAggregateInputType
  }

  export type GetDisponibiliteIntervenantAggregateType<T extends DisponibiliteIntervenantAggregateArgs> = {
        [P in keyof T & keyof AggregateDisponibiliteIntervenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisponibiliteIntervenant[P]>
      : GetScalarType<T[P], AggregateDisponibiliteIntervenant[P]>
  }




  export type DisponibiliteIntervenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibiliteIntervenantWhereInput
    orderBy?: DisponibiliteIntervenantOrderByWithAggregationInput | DisponibiliteIntervenantOrderByWithAggregationInput[]
    by: DisponibiliteIntervenantScalarFieldEnum[] | DisponibiliteIntervenantScalarFieldEnum
    having?: DisponibiliteIntervenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisponibiliteIntervenantCountAggregateInputType | true
    _avg?: DisponibiliteIntervenantAvgAggregateInputType
    _sum?: DisponibiliteIntervenantSumAggregateInputType
    _min?: DisponibiliteIntervenantMinAggregateInputType
    _max?: DisponibiliteIntervenantMaxAggregateInputType
  }

  export type DisponibiliteIntervenantGroupByOutputType = {
    id: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type: $Enums.TypeDisponibilite
    dateDebut: Date | null
    dateFin: Date | null
    recurrent: boolean
    intervenantId: string
    createdAt: Date
    updatedAt: Date
    _count: DisponibiliteIntervenantCountAggregateOutputType | null
    _avg: DisponibiliteIntervenantAvgAggregateOutputType | null
    _sum: DisponibiliteIntervenantSumAggregateOutputType | null
    _min: DisponibiliteIntervenantMinAggregateOutputType | null
    _max: DisponibiliteIntervenantMaxAggregateOutputType | null
  }

  type GetDisponibiliteIntervenantGroupByPayload<T extends DisponibiliteIntervenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisponibiliteIntervenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisponibiliteIntervenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisponibiliteIntervenantGroupByOutputType[P]>
            : GetScalarType<T[P], DisponibiliteIntervenantGroupByOutputType[P]>
        }
      >
    >


  export type DisponibiliteIntervenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jourSemaine?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    recurrent?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibiliteIntervenant"]>

  export type DisponibiliteIntervenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jourSemaine?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    recurrent?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibiliteIntervenant"]>

  export type DisponibiliteIntervenantSelectScalar = {
    id?: boolean
    jourSemaine?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    type?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    recurrent?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisponibiliteIntervenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
  }
  export type DisponibiliteIntervenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
  }

  export type $DisponibiliteIntervenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisponibiliteIntervenant"
    objects: {
      intervenant: Prisma.$IntervenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      jourSemaine: number
      heureDebut: string
      heureFin: string
      type: $Enums.TypeDisponibilite
      dateDebut: Date | null
      dateFin: Date | null
      recurrent: boolean
      intervenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["disponibiliteIntervenant"]>
    composites: {}
  }

  type DisponibiliteIntervenantGetPayload<S extends boolean | null | undefined | DisponibiliteIntervenantDefaultArgs> = $Result.GetResult<Prisma.$DisponibiliteIntervenantPayload, S>

  type DisponibiliteIntervenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisponibiliteIntervenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisponibiliteIntervenantCountAggregateInputType | true
    }

  export interface DisponibiliteIntervenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisponibiliteIntervenant'], meta: { name: 'DisponibiliteIntervenant' } }
    /**
     * Find zero or one DisponibiliteIntervenant that matches the filter.
     * @param {DisponibiliteIntervenantFindUniqueArgs} args - Arguments to find a DisponibiliteIntervenant
     * @example
     * // Get one DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisponibiliteIntervenantFindUniqueArgs>(args: SelectSubset<T, DisponibiliteIntervenantFindUniqueArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DisponibiliteIntervenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisponibiliteIntervenantFindUniqueOrThrowArgs} args - Arguments to find a DisponibiliteIntervenant
     * @example
     * // Get one DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisponibiliteIntervenantFindUniqueOrThrowArgs>(args: SelectSubset<T, DisponibiliteIntervenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DisponibiliteIntervenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantFindFirstArgs} args - Arguments to find a DisponibiliteIntervenant
     * @example
     * // Get one DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisponibiliteIntervenantFindFirstArgs>(args?: SelectSubset<T, DisponibiliteIntervenantFindFirstArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DisponibiliteIntervenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantFindFirstOrThrowArgs} args - Arguments to find a DisponibiliteIntervenant
     * @example
     * // Get one DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisponibiliteIntervenantFindFirstOrThrowArgs>(args?: SelectSubset<T, DisponibiliteIntervenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DisponibiliteIntervenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisponibiliteIntervenants
     * const disponibiliteIntervenants = await prisma.disponibiliteIntervenant.findMany()
     * 
     * // Get first 10 DisponibiliteIntervenants
     * const disponibiliteIntervenants = await prisma.disponibiliteIntervenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disponibiliteIntervenantWithIdOnly = await prisma.disponibiliteIntervenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisponibiliteIntervenantFindManyArgs>(args?: SelectSubset<T, DisponibiliteIntervenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DisponibiliteIntervenant.
     * @param {DisponibiliteIntervenantCreateArgs} args - Arguments to create a DisponibiliteIntervenant.
     * @example
     * // Create one DisponibiliteIntervenant
     * const DisponibiliteIntervenant = await prisma.disponibiliteIntervenant.create({
     *   data: {
     *     // ... data to create a DisponibiliteIntervenant
     *   }
     * })
     * 
     */
    create<T extends DisponibiliteIntervenantCreateArgs>(args: SelectSubset<T, DisponibiliteIntervenantCreateArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DisponibiliteIntervenants.
     * @param {DisponibiliteIntervenantCreateManyArgs} args - Arguments to create many DisponibiliteIntervenants.
     * @example
     * // Create many DisponibiliteIntervenants
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisponibiliteIntervenantCreateManyArgs>(args?: SelectSubset<T, DisponibiliteIntervenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisponibiliteIntervenants and returns the data saved in the database.
     * @param {DisponibiliteIntervenantCreateManyAndReturnArgs} args - Arguments to create many DisponibiliteIntervenants.
     * @example
     * // Create many DisponibiliteIntervenants
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisponibiliteIntervenants and only return the `id`
     * const disponibiliteIntervenantWithIdOnly = await prisma.disponibiliteIntervenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisponibiliteIntervenantCreateManyAndReturnArgs>(args?: SelectSubset<T, DisponibiliteIntervenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DisponibiliteIntervenant.
     * @param {DisponibiliteIntervenantDeleteArgs} args - Arguments to delete one DisponibiliteIntervenant.
     * @example
     * // Delete one DisponibiliteIntervenant
     * const DisponibiliteIntervenant = await prisma.disponibiliteIntervenant.delete({
     *   where: {
     *     // ... filter to delete one DisponibiliteIntervenant
     *   }
     * })
     * 
     */
    delete<T extends DisponibiliteIntervenantDeleteArgs>(args: SelectSubset<T, DisponibiliteIntervenantDeleteArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DisponibiliteIntervenant.
     * @param {DisponibiliteIntervenantUpdateArgs} args - Arguments to update one DisponibiliteIntervenant.
     * @example
     * // Update one DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisponibiliteIntervenantUpdateArgs>(args: SelectSubset<T, DisponibiliteIntervenantUpdateArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DisponibiliteIntervenants.
     * @param {DisponibiliteIntervenantDeleteManyArgs} args - Arguments to filter DisponibiliteIntervenants to delete.
     * @example
     * // Delete a few DisponibiliteIntervenants
     * const { count } = await prisma.disponibiliteIntervenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisponibiliteIntervenantDeleteManyArgs>(args?: SelectSubset<T, DisponibiliteIntervenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisponibiliteIntervenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisponibiliteIntervenants
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisponibiliteIntervenantUpdateManyArgs>(args: SelectSubset<T, DisponibiliteIntervenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisponibiliteIntervenant.
     * @param {DisponibiliteIntervenantUpsertArgs} args - Arguments to update or create a DisponibiliteIntervenant.
     * @example
     * // Update or create a DisponibiliteIntervenant
     * const disponibiliteIntervenant = await prisma.disponibiliteIntervenant.upsert({
     *   create: {
     *     // ... data to create a DisponibiliteIntervenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisponibiliteIntervenant we want to update
     *   }
     * })
     */
    upsert<T extends DisponibiliteIntervenantUpsertArgs>(args: SelectSubset<T, DisponibiliteIntervenantUpsertArgs<ExtArgs>>): Prisma__DisponibiliteIntervenantClient<$Result.GetResult<Prisma.$DisponibiliteIntervenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DisponibiliteIntervenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantCountArgs} args - Arguments to filter DisponibiliteIntervenants to count.
     * @example
     * // Count the number of DisponibiliteIntervenants
     * const count = await prisma.disponibiliteIntervenant.count({
     *   where: {
     *     // ... the filter for the DisponibiliteIntervenants we want to count
     *   }
     * })
    **/
    count<T extends DisponibiliteIntervenantCountArgs>(
      args?: Subset<T, DisponibiliteIntervenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisponibiliteIntervenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisponibiliteIntervenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisponibiliteIntervenantAggregateArgs>(args: Subset<T, DisponibiliteIntervenantAggregateArgs>): Prisma.PrismaPromise<GetDisponibiliteIntervenantAggregateType<T>>

    /**
     * Group by DisponibiliteIntervenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteIntervenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisponibiliteIntervenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisponibiliteIntervenantGroupByArgs['orderBy'] }
        : { orderBy?: DisponibiliteIntervenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisponibiliteIntervenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisponibiliteIntervenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisponibiliteIntervenant model
   */
  readonly fields: DisponibiliteIntervenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisponibiliteIntervenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisponibiliteIntervenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intervenant<T extends IntervenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntervenantDefaultArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisponibiliteIntervenant model
   */ 
  interface DisponibiliteIntervenantFieldRefs {
    readonly id: FieldRef<"DisponibiliteIntervenant", 'String'>
    readonly jourSemaine: FieldRef<"DisponibiliteIntervenant", 'Int'>
    readonly heureDebut: FieldRef<"DisponibiliteIntervenant", 'String'>
    readonly heureFin: FieldRef<"DisponibiliteIntervenant", 'String'>
    readonly type: FieldRef<"DisponibiliteIntervenant", 'TypeDisponibilite'>
    readonly dateDebut: FieldRef<"DisponibiliteIntervenant", 'DateTime'>
    readonly dateFin: FieldRef<"DisponibiliteIntervenant", 'DateTime'>
    readonly recurrent: FieldRef<"DisponibiliteIntervenant", 'Boolean'>
    readonly intervenantId: FieldRef<"DisponibiliteIntervenant", 'String'>
    readonly createdAt: FieldRef<"DisponibiliteIntervenant", 'DateTime'>
    readonly updatedAt: FieldRef<"DisponibiliteIntervenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisponibiliteIntervenant findUnique
   */
  export type DisponibiliteIntervenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteIntervenant to fetch.
     */
    where: DisponibiliteIntervenantWhereUniqueInput
  }

  /**
   * DisponibiliteIntervenant findUniqueOrThrow
   */
  export type DisponibiliteIntervenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteIntervenant to fetch.
     */
    where: DisponibiliteIntervenantWhereUniqueInput
  }

  /**
   * DisponibiliteIntervenant findFirst
   */
  export type DisponibiliteIntervenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteIntervenant to fetch.
     */
    where?: DisponibiliteIntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteIntervenants to fetch.
     */
    orderBy?: DisponibiliteIntervenantOrderByWithRelationInput | DisponibiliteIntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibiliteIntervenants.
     */
    cursor?: DisponibiliteIntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteIntervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteIntervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibiliteIntervenants.
     */
    distinct?: DisponibiliteIntervenantScalarFieldEnum | DisponibiliteIntervenantScalarFieldEnum[]
  }

  /**
   * DisponibiliteIntervenant findFirstOrThrow
   */
  export type DisponibiliteIntervenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteIntervenant to fetch.
     */
    where?: DisponibiliteIntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteIntervenants to fetch.
     */
    orderBy?: DisponibiliteIntervenantOrderByWithRelationInput | DisponibiliteIntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibiliteIntervenants.
     */
    cursor?: DisponibiliteIntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteIntervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteIntervenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibiliteIntervenants.
     */
    distinct?: DisponibiliteIntervenantScalarFieldEnum | DisponibiliteIntervenantScalarFieldEnum[]
  }

  /**
   * DisponibiliteIntervenant findMany
   */
  export type DisponibiliteIntervenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteIntervenants to fetch.
     */
    where?: DisponibiliteIntervenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteIntervenants to fetch.
     */
    orderBy?: DisponibiliteIntervenantOrderByWithRelationInput | DisponibiliteIntervenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisponibiliteIntervenants.
     */
    cursor?: DisponibiliteIntervenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteIntervenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteIntervenants.
     */
    skip?: number
    distinct?: DisponibiliteIntervenantScalarFieldEnum | DisponibiliteIntervenantScalarFieldEnum[]
  }

  /**
   * DisponibiliteIntervenant create
   */
  export type DisponibiliteIntervenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * The data needed to create a DisponibiliteIntervenant.
     */
    data: XOR<DisponibiliteIntervenantCreateInput, DisponibiliteIntervenantUncheckedCreateInput>
  }

  /**
   * DisponibiliteIntervenant createMany
   */
  export type DisponibiliteIntervenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisponibiliteIntervenants.
     */
    data: DisponibiliteIntervenantCreateManyInput | DisponibiliteIntervenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisponibiliteIntervenant createManyAndReturn
   */
  export type DisponibiliteIntervenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DisponibiliteIntervenants.
     */
    data: DisponibiliteIntervenantCreateManyInput | DisponibiliteIntervenantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisponibiliteIntervenant update
   */
  export type DisponibiliteIntervenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * The data needed to update a DisponibiliteIntervenant.
     */
    data: XOR<DisponibiliteIntervenantUpdateInput, DisponibiliteIntervenantUncheckedUpdateInput>
    /**
     * Choose, which DisponibiliteIntervenant to update.
     */
    where: DisponibiliteIntervenantWhereUniqueInput
  }

  /**
   * DisponibiliteIntervenant updateMany
   */
  export type DisponibiliteIntervenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisponibiliteIntervenants.
     */
    data: XOR<DisponibiliteIntervenantUpdateManyMutationInput, DisponibiliteIntervenantUncheckedUpdateManyInput>
    /**
     * Filter which DisponibiliteIntervenants to update
     */
    where?: DisponibiliteIntervenantWhereInput
  }

  /**
   * DisponibiliteIntervenant upsert
   */
  export type DisponibiliteIntervenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * The filter to search for the DisponibiliteIntervenant to update in case it exists.
     */
    where: DisponibiliteIntervenantWhereUniqueInput
    /**
     * In case the DisponibiliteIntervenant found by the `where` argument doesn't exist, create a new DisponibiliteIntervenant with this data.
     */
    create: XOR<DisponibiliteIntervenantCreateInput, DisponibiliteIntervenantUncheckedCreateInput>
    /**
     * In case the DisponibiliteIntervenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisponibiliteIntervenantUpdateInput, DisponibiliteIntervenantUncheckedUpdateInput>
  }

  /**
   * DisponibiliteIntervenant delete
   */
  export type DisponibiliteIntervenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
    /**
     * Filter which DisponibiliteIntervenant to delete.
     */
    where: DisponibiliteIntervenantWhereUniqueInput
  }

  /**
   * DisponibiliteIntervenant deleteMany
   */
  export type DisponibiliteIntervenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibiliteIntervenants to delete
     */
    where?: DisponibiliteIntervenantWhereInput
  }

  /**
   * DisponibiliteIntervenant without action
   */
  export type DisponibiliteIntervenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteIntervenant
     */
    select?: DisponibiliteIntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteIntervenantInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    cm: number | null
    td: number | null
    tp: number | null
    tpe: number | null
    vht: number | null
    coefficient: number | null
    credits: number | null
    progression: number | null
  }

  export type ModuleSumAggregateOutputType = {
    cm: number | null
    td: number | null
    tp: number | null
    tpe: number | null
    vht: number | null
    coefficient: number | null
    credits: number | null
    progression: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    cm: number | null
    td: number | null
    tp: number | null
    tpe: number | null
    vht: number | null
    coefficient: number | null
    credits: number | null
    status: $Enums.StatusModule | null
    progression: number | null
    dateDebut: Date | null
    dateFin: Date | null
    programmeId: string | null
    intervenantId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    cm: number | null
    td: number | null
    tp: number | null
    tpe: number | null
    vht: number | null
    coefficient: number | null
    credits: number | null
    status: $Enums.StatusModule | null
    progression: number | null
    dateDebut: Date | null
    dateFin: Date | null
    programmeId: string | null
    intervenantId: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    cm: number
    td: number
    tp: number
    tpe: number
    vht: number
    coefficient: number
    credits: number
    status: number
    progression: number
    dateDebut: number
    dateFin: number
    programmeId: number
    intervenantId: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    cm?: true
    td?: true
    tp?: true
    tpe?: true
    vht?: true
    coefficient?: true
    credits?: true
    progression?: true
  }

  export type ModuleSumAggregateInputType = {
    cm?: true
    td?: true
    tp?: true
    tpe?: true
    vht?: true
    coefficient?: true
    credits?: true
    progression?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    cm?: true
    td?: true
    tp?: true
    tpe?: true
    vht?: true
    coefficient?: true
    credits?: true
    status?: true
    progression?: true
    dateDebut?: true
    dateFin?: true
    programmeId?: true
    intervenantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    cm?: true
    td?: true
    tp?: true
    tpe?: true
    vht?: true
    coefficient?: true
    credits?: true
    status?: true
    progression?: true
    dateDebut?: true
    dateFin?: true
    programmeId?: true
    intervenantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    cm?: true
    td?: true
    tp?: true
    tpe?: true
    vht?: true
    coefficient?: true
    credits?: true
    status?: true
    progression?: true
    dateDebut?: true
    dateFin?: true
    programmeId?: true
    intervenantId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    cm: number
    td: number
    tp: number
    tpe: number
    vht: number
    coefficient: number
    credits: number
    status: $Enums.StatusModule
    progression: number
    dateDebut: Date | null
    dateFin: Date | null
    programmeId: string
    intervenantId: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    cm?: boolean
    td?: boolean
    tp?: boolean
    tpe?: boolean
    vht?: boolean
    coefficient?: boolean
    credits?: boolean
    status?: boolean
    progression?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    programmeId?: boolean
    intervenantId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evaluations?: boolean | Module$evaluationsArgs<ExtArgs>
    intervenant?: boolean | Module$intervenantArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    resultatsEtudiants?: boolean | Module$resultatsEtudiantsArgs<ExtArgs>
    seances?: boolean | Module$seancesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    cm?: boolean
    td?: boolean
    tp?: boolean
    tpe?: boolean
    vht?: boolean
    coefficient?: boolean
    credits?: boolean
    status?: boolean
    progression?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    programmeId?: boolean
    intervenantId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervenant?: boolean | Module$intervenantArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    cm?: boolean
    td?: boolean
    tp?: boolean
    tpe?: boolean
    vht?: boolean
    coefficient?: boolean
    credits?: boolean
    status?: boolean
    progression?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    programmeId?: boolean
    intervenantId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | Module$evaluationsArgs<ExtArgs>
    intervenant?: boolean | Module$intervenantArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    resultatsEtudiants?: boolean | Module$resultatsEtudiantsArgs<ExtArgs>
    seances?: boolean | Module$seancesArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | Module$intervenantArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      evaluations: Prisma.$EvaluationEnseignementPayload<ExtArgs>[]
      intervenant: Prisma.$IntervenantPayload<ExtArgs> | null
      programme: Prisma.$ProgrammePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      resultatsEtudiants: Prisma.$ResultatEtudiantPayload<ExtArgs>[]
      seances: Prisma.$SeancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      cm: number
      td: number
      tp: number
      tpe: number
      vht: number
      coefficient: number
      credits: number
      status: $Enums.StatusModule
      progression: number
      dateDebut: Date | null
      dateFin: Date | null
      programmeId: string
      intervenantId: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluations<T extends Module$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Module$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findMany"> | Null>
    intervenant<T extends Module$intervenantArgs<ExtArgs> = {}>(args?: Subset<T, Module$intervenantArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    programme<T extends ProgrammeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgrammeDefaultArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resultatsEtudiants<T extends Module$resultatsEtudiantsArgs<ExtArgs> = {}>(args?: Subset<T, Module$resultatsEtudiantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findMany"> | Null>
    seances<T extends Module$seancesArgs<ExtArgs> = {}>(args?: Subset<T, Module$seancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */ 
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'String'>
    readonly code: FieldRef<"Module", 'String'>
    readonly name: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly cm: FieldRef<"Module", 'Int'>
    readonly td: FieldRef<"Module", 'Int'>
    readonly tp: FieldRef<"Module", 'Int'>
    readonly tpe: FieldRef<"Module", 'Int'>
    readonly vht: FieldRef<"Module", 'Int'>
    readonly coefficient: FieldRef<"Module", 'Int'>
    readonly credits: FieldRef<"Module", 'Int'>
    readonly status: FieldRef<"Module", 'StatusModule'>
    readonly progression: FieldRef<"Module", 'Int'>
    readonly dateDebut: FieldRef<"Module", 'DateTime'>
    readonly dateFin: FieldRef<"Module", 'DateTime'>
    readonly programmeId: FieldRef<"Module", 'String'>
    readonly intervenantId: FieldRef<"Module", 'String'>
    readonly userId: FieldRef<"Module", 'String'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
  }

  /**
   * Module.evaluations
   */
  export type Module$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    where?: EvaluationEnseignementWhereInput
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    cursor?: EvaluationEnseignementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationEnseignementScalarFieldEnum | EvaluationEnseignementScalarFieldEnum[]
  }

  /**
   * Module.intervenant
   */
  export type Module$intervenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Intervenant
     */
    select?: IntervenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntervenantInclude<ExtArgs> | null
    where?: IntervenantWhereInput
  }

  /**
   * Module.resultatsEtudiants
   */
  export type Module$resultatsEtudiantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    where?: ResultatEtudiantWhereInput
    orderBy?: ResultatEtudiantOrderByWithRelationInput | ResultatEtudiantOrderByWithRelationInput[]
    cursor?: ResultatEtudiantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResultatEtudiantScalarFieldEnum | ResultatEtudiantScalarFieldEnum[]
  }

  /**
   * Module.seances
   */
  export type Module$seancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    where?: SeanceWhereInput
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    cursor?: SeanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeanceScalarFieldEnum | SeanceScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Salle
   */

  export type AggregateSalle = {
    _count: SalleCountAggregateOutputType | null
    _avg: SalleAvgAggregateOutputType | null
    _sum: SalleSumAggregateOutputType | null
    _min: SalleMinAggregateOutputType | null
    _max: SalleMaxAggregateOutputType | null
  }

  export type SalleAvgAggregateOutputType = {
    capacite: number | null
  }

  export type SalleSumAggregateOutputType = {
    capacite: number | null
  }

  export type SalleMinAggregateOutputType = {
    id: string | null
    nom: string | null
    batiment: string | null
    capacite: number | null
    equipements: string | null
    disponible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalleMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    batiment: string | null
    capacite: number | null
    equipements: string | null
    disponible: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalleCountAggregateOutputType = {
    id: number
    nom: number
    batiment: number
    capacite: number
    equipements: number
    disponible: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalleAvgAggregateInputType = {
    capacite?: true
  }

  export type SalleSumAggregateInputType = {
    capacite?: true
  }

  export type SalleMinAggregateInputType = {
    id?: true
    nom?: true
    batiment?: true
    capacite?: true
    equipements?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalleMaxAggregateInputType = {
    id?: true
    nom?: true
    batiment?: true
    capacite?: true
    equipements?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalleCountAggregateInputType = {
    id?: true
    nom?: true
    batiment?: true
    capacite?: true
    equipements?: true
    disponible?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salle to aggregate.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salles
    **/
    _count?: true | SalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalleMaxAggregateInputType
  }

  export type GetSalleAggregateType<T extends SalleAggregateArgs> = {
        [P in keyof T & keyof AggregateSalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalle[P]>
      : GetScalarType<T[P], AggregateSalle[P]>
  }




  export type SalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalleWhereInput
    orderBy?: SalleOrderByWithAggregationInput | SalleOrderByWithAggregationInput[]
    by: SalleScalarFieldEnum[] | SalleScalarFieldEnum
    having?: SalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalleCountAggregateInputType | true
    _avg?: SalleAvgAggregateInputType
    _sum?: SalleSumAggregateInputType
    _min?: SalleMinAggregateInputType
    _max?: SalleMaxAggregateInputType
  }

  export type SalleGroupByOutputType = {
    id: string
    nom: string
    batiment: string
    capacite: number
    equipements: string | null
    disponible: boolean
    createdAt: Date
    updatedAt: Date
    _count: SalleCountAggregateOutputType | null
    _avg: SalleAvgAggregateOutputType | null
    _sum: SalleSumAggregateOutputType | null
    _min: SalleMinAggregateOutputType | null
    _max: SalleMaxAggregateOutputType | null
  }

  type GetSalleGroupByPayload<T extends SalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalleGroupByOutputType[P]>
            : GetScalarType<T[P], SalleGroupByOutputType[P]>
        }
      >
    >


  export type SalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    batiment?: boolean
    capacite?: boolean
    equipements?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salle"]>

  export type SalleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    batiment?: boolean
    capacite?: boolean
    equipements?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salle"]>

  export type SalleSelectScalar = {
    id?: boolean
    nom?: boolean
    batiment?: boolean
    capacite?: boolean
    equipements?: boolean
    disponible?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      batiment: string
      capacite: number
      equipements: string | null
      disponible: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salle"]>
    composites: {}
  }

  type SalleGetPayload<S extends boolean | null | undefined | SalleDefaultArgs> = $Result.GetResult<Prisma.$SallePayload, S>

  type SalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalleCountAggregateInputType | true
    }

  export interface SalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salle'], meta: { name: 'Salle' } }
    /**
     * Find zero or one Salle that matches the filter.
     * @param {SalleFindUniqueArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalleFindUniqueArgs>(args: SelectSubset<T, SalleFindUniqueArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Salle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalleFindUniqueOrThrowArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalleFindUniqueOrThrowArgs>(args: SelectSubset<T, SalleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Salle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindFirstArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalleFindFirstArgs>(args?: SelectSubset<T, SalleFindFirstArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Salle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindFirstOrThrowArgs} args - Arguments to find a Salle
     * @example
     * // Get one Salle
     * const salle = await prisma.salle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalleFindFirstOrThrowArgs>(args?: SelectSubset<T, SalleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Salles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salles
     * const salles = await prisma.salle.findMany()
     * 
     * // Get first 10 Salles
     * const salles = await prisma.salle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salleWithIdOnly = await prisma.salle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalleFindManyArgs>(args?: SelectSubset<T, SalleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Salle.
     * @param {SalleCreateArgs} args - Arguments to create a Salle.
     * @example
     * // Create one Salle
     * const Salle = await prisma.salle.create({
     *   data: {
     *     // ... data to create a Salle
     *   }
     * })
     * 
     */
    create<T extends SalleCreateArgs>(args: SelectSubset<T, SalleCreateArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Salles.
     * @param {SalleCreateManyArgs} args - Arguments to create many Salles.
     * @example
     * // Create many Salles
     * const salle = await prisma.salle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalleCreateManyArgs>(args?: SelectSubset<T, SalleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salles and returns the data saved in the database.
     * @param {SalleCreateManyAndReturnArgs} args - Arguments to create many Salles.
     * @example
     * // Create many Salles
     * const salle = await prisma.salle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salles and only return the `id`
     * const salleWithIdOnly = await prisma.salle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalleCreateManyAndReturnArgs>(args?: SelectSubset<T, SalleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Salle.
     * @param {SalleDeleteArgs} args - Arguments to delete one Salle.
     * @example
     * // Delete one Salle
     * const Salle = await prisma.salle.delete({
     *   where: {
     *     // ... filter to delete one Salle
     *   }
     * })
     * 
     */
    delete<T extends SalleDeleteArgs>(args: SelectSubset<T, SalleDeleteArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Salle.
     * @param {SalleUpdateArgs} args - Arguments to update one Salle.
     * @example
     * // Update one Salle
     * const salle = await prisma.salle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalleUpdateArgs>(args: SelectSubset<T, SalleUpdateArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Salles.
     * @param {SalleDeleteManyArgs} args - Arguments to filter Salles to delete.
     * @example
     * // Delete a few Salles
     * const { count } = await prisma.salle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalleDeleteManyArgs>(args?: SelectSubset<T, SalleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salles
     * const salle = await prisma.salle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalleUpdateManyArgs>(args: SelectSubset<T, SalleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Salle.
     * @param {SalleUpsertArgs} args - Arguments to update or create a Salle.
     * @example
     * // Update or create a Salle
     * const salle = await prisma.salle.upsert({
     *   create: {
     *     // ... data to create a Salle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salle we want to update
     *   }
     * })
     */
    upsert<T extends SalleUpsertArgs>(args: SelectSubset<T, SalleUpsertArgs<ExtArgs>>): Prisma__SalleClient<$Result.GetResult<Prisma.$SallePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Salles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleCountArgs} args - Arguments to filter Salles to count.
     * @example
     * // Count the number of Salles
     * const count = await prisma.salle.count({
     *   where: {
     *     // ... the filter for the Salles we want to count
     *   }
     * })
    **/
    count<T extends SalleCountArgs>(
      args?: Subset<T, SalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalleAggregateArgs>(args: Subset<T, SalleAggregateArgs>): Prisma.PrismaPromise<GetSalleAggregateType<T>>

    /**
     * Group by Salle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalleGroupByArgs['orderBy'] }
        : { orderBy?: SalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salle model
   */
  readonly fields: SalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salle model
   */ 
  interface SalleFieldRefs {
    readonly id: FieldRef<"Salle", 'String'>
    readonly nom: FieldRef<"Salle", 'String'>
    readonly batiment: FieldRef<"Salle", 'String'>
    readonly capacite: FieldRef<"Salle", 'Int'>
    readonly equipements: FieldRef<"Salle", 'String'>
    readonly disponible: FieldRef<"Salle", 'Boolean'>
    readonly createdAt: FieldRef<"Salle", 'DateTime'>
    readonly updatedAt: FieldRef<"Salle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Salle findUnique
   */
  export type SalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where: SalleWhereUniqueInput
  }

  /**
   * Salle findUniqueOrThrow
   */
  export type SalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where: SalleWhereUniqueInput
  }

  /**
   * Salle findFirst
   */
  export type SalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salles.
     */
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }

  /**
   * Salle findFirstOrThrow
   */
  export type SalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter, which Salle to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salles.
     */
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }

  /**
   * Salle findMany
   */
  export type SalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter, which Salles to fetch.
     */
    where?: SalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salles to fetch.
     */
    orderBy?: SalleOrderByWithRelationInput | SalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salles.
     */
    cursor?: SalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salles.
     */
    skip?: number
    distinct?: SalleScalarFieldEnum | SalleScalarFieldEnum[]
  }

  /**
   * Salle create
   */
  export type SalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * The data needed to create a Salle.
     */
    data: XOR<SalleCreateInput, SalleUncheckedCreateInput>
  }

  /**
   * Salle createMany
   */
  export type SalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salles.
     */
    data: SalleCreateManyInput | SalleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salle createManyAndReturn
   */
  export type SalleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Salles.
     */
    data: SalleCreateManyInput | SalleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salle update
   */
  export type SalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * The data needed to update a Salle.
     */
    data: XOR<SalleUpdateInput, SalleUncheckedUpdateInput>
    /**
     * Choose, which Salle to update.
     */
    where: SalleWhereUniqueInput
  }

  /**
   * Salle updateMany
   */
  export type SalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salles.
     */
    data: XOR<SalleUpdateManyMutationInput, SalleUncheckedUpdateManyInput>
    /**
     * Filter which Salles to update
     */
    where?: SalleWhereInput
  }

  /**
   * Salle upsert
   */
  export type SalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * The filter to search for the Salle to update in case it exists.
     */
    where: SalleWhereUniqueInput
    /**
     * In case the Salle found by the `where` argument doesn't exist, create a new Salle with this data.
     */
    create: XOR<SalleCreateInput, SalleUncheckedCreateInput>
    /**
     * In case the Salle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalleUpdateInput, SalleUncheckedUpdateInput>
  }

  /**
   * Salle delete
   */
  export type SalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
    /**
     * Filter which Salle to delete.
     */
    where: SalleWhereUniqueInput
  }

  /**
   * Salle deleteMany
   */
  export type SalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salles to delete
     */
    where?: SalleWhereInput
  }

  /**
   * Salle without action
   */
  export type SalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salle
     */
    select?: SalleSelect<ExtArgs> | null
  }


  /**
   * Model Seance
   */

  export type AggregateSeance = {
    _count: SeanceCountAggregateOutputType | null
    _avg: SeanceAvgAggregateOutputType | null
    _sum: SeanceSumAggregateOutputType | null
    _min: SeanceMinAggregateOutputType | null
    _max: SeanceMaxAggregateOutputType | null
  }

  export type SeanceAvgAggregateOutputType = {
    duree: number | null
  }

  export type SeanceSumAggregateOutputType = {
    duree: number | null
  }

  export type SeanceMinAggregateOutputType = {
    id: string | null
    dateSeance: Date | null
    heureDebut: string | null
    heureFin: string | null
    duree: number | null
    typeSeance: $Enums.TypeSeance | null
    salle: string | null
    batiment: string | null
    status: $Enums.StatusSeance | null
    moduleId: string | null
    intervenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    notes: string | null
    objectifs: string | null
  }

  export type SeanceMaxAggregateOutputType = {
    id: string | null
    dateSeance: Date | null
    heureDebut: string | null
    heureFin: string | null
    duree: number | null
    typeSeance: $Enums.TypeSeance | null
    salle: string | null
    batiment: string | null
    status: $Enums.StatusSeance | null
    moduleId: string | null
    intervenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    notes: string | null
    objectifs: string | null
  }

  export type SeanceCountAggregateOutputType = {
    id: number
    dateSeance: number
    heureDebut: number
    heureFin: number
    duree: number
    typeSeance: number
    salle: number
    batiment: number
    status: number
    moduleId: number
    intervenantId: number
    createdAt: number
    updatedAt: number
    notes: number
    objectifs: number
    _all: number
  }


  export type SeanceAvgAggregateInputType = {
    duree?: true
  }

  export type SeanceSumAggregateInputType = {
    duree?: true
  }

  export type SeanceMinAggregateInputType = {
    id?: true
    dateSeance?: true
    heureDebut?: true
    heureFin?: true
    duree?: true
    typeSeance?: true
    salle?: true
    batiment?: true
    status?: true
    moduleId?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
    objectifs?: true
  }

  export type SeanceMaxAggregateInputType = {
    id?: true
    dateSeance?: true
    heureDebut?: true
    heureFin?: true
    duree?: true
    typeSeance?: true
    salle?: true
    batiment?: true
    status?: true
    moduleId?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
    objectifs?: true
  }

  export type SeanceCountAggregateInputType = {
    id?: true
    dateSeance?: true
    heureDebut?: true
    heureFin?: true
    duree?: true
    typeSeance?: true
    salle?: true
    batiment?: true
    status?: true
    moduleId?: true
    intervenantId?: true
    createdAt?: true
    updatedAt?: true
    notes?: true
    objectifs?: true
    _all?: true
  }

  export type SeanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seance to aggregate.
     */
    where?: SeanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seances to fetch.
     */
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seances
    **/
    _count?: true | SeanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeanceMaxAggregateInputType
  }

  export type GetSeanceAggregateType<T extends SeanceAggregateArgs> = {
        [P in keyof T & keyof AggregateSeance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeance[P]>
      : GetScalarType<T[P], AggregateSeance[P]>
  }




  export type SeanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeanceWhereInput
    orderBy?: SeanceOrderByWithAggregationInput | SeanceOrderByWithAggregationInput[]
    by: SeanceScalarFieldEnum[] | SeanceScalarFieldEnum
    having?: SeanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeanceCountAggregateInputType | true
    _avg?: SeanceAvgAggregateInputType
    _sum?: SeanceSumAggregateInputType
    _min?: SeanceMinAggregateInputType
    _max?: SeanceMaxAggregateInputType
  }

  export type SeanceGroupByOutputType = {
    id: string
    dateSeance: Date
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle: string | null
    batiment: string | null
    status: $Enums.StatusSeance
    moduleId: string
    intervenantId: string
    createdAt: Date
    updatedAt: Date
    notes: string | null
    objectifs: string | null
    _count: SeanceCountAggregateOutputType | null
    _avg: SeanceAvgAggregateOutputType | null
    _sum: SeanceSumAggregateOutputType | null
    _min: SeanceMinAggregateOutputType | null
    _max: SeanceMaxAggregateOutputType | null
  }

  type GetSeanceGroupByPayload<T extends SeanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeanceGroupByOutputType[P]>
            : GetScalarType<T[P], SeanceGroupByOutputType[P]>
        }
      >
    >


  export type SeanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateSeance?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    duree?: boolean
    typeSeance?: boolean
    salle?: boolean
    batiment?: boolean
    status?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean
    objectifs?: boolean
    conflitsAsSeance1?: boolean | Seance$conflitsAsSeance1Args<ExtArgs>
    conflitsAsSeance2?: boolean | Seance$conflitsAsSeance2Args<ExtArgs>
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    _count?: boolean | SeanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seance"]>

  export type SeanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateSeance?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    duree?: boolean
    typeSeance?: boolean
    salle?: boolean
    batiment?: boolean
    status?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean
    objectifs?: boolean
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seance"]>

  export type SeanceSelectScalar = {
    id?: boolean
    dateSeance?: boolean
    heureDebut?: boolean
    heureFin?: boolean
    duree?: boolean
    typeSeance?: boolean
    salle?: boolean
    batiment?: boolean
    status?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notes?: boolean
    objectifs?: boolean
  }

  export type SeanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conflitsAsSeance1?: boolean | Seance$conflitsAsSeance1Args<ExtArgs>
    conflitsAsSeance2?: boolean | Seance$conflitsAsSeance2Args<ExtArgs>
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    _count?: boolean | SeanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $SeancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seance"
    objects: {
      conflitsAsSeance1: Prisma.$ConflitPayload<ExtArgs>[]
      conflitsAsSeance2: Prisma.$ConflitPayload<ExtArgs>[]
      intervenant: Prisma.$IntervenantPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateSeance: Date
      heureDebut: string
      heureFin: string
      duree: number
      typeSeance: $Enums.TypeSeance
      salle: string | null
      batiment: string | null
      status: $Enums.StatusSeance
      moduleId: string
      intervenantId: string
      createdAt: Date
      updatedAt: Date
      notes: string | null
      objectifs: string | null
    }, ExtArgs["result"]["seance"]>
    composites: {}
  }

  type SeanceGetPayload<S extends boolean | null | undefined | SeanceDefaultArgs> = $Result.GetResult<Prisma.$SeancePayload, S>

  type SeanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeanceCountAggregateInputType | true
    }

  export interface SeanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seance'], meta: { name: 'Seance' } }
    /**
     * Find zero or one Seance that matches the filter.
     * @param {SeanceFindUniqueArgs} args - Arguments to find a Seance
     * @example
     * // Get one Seance
     * const seance = await prisma.seance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeanceFindUniqueArgs>(args: SelectSubset<T, SeanceFindUniqueArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Seance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeanceFindUniqueOrThrowArgs} args - Arguments to find a Seance
     * @example
     * // Get one Seance
     * const seance = await prisma.seance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeanceFindUniqueOrThrowArgs>(args: SelectSubset<T, SeanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Seance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceFindFirstArgs} args - Arguments to find a Seance
     * @example
     * // Get one Seance
     * const seance = await prisma.seance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeanceFindFirstArgs>(args?: SelectSubset<T, SeanceFindFirstArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Seance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceFindFirstOrThrowArgs} args - Arguments to find a Seance
     * @example
     * // Get one Seance
     * const seance = await prisma.seance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeanceFindFirstOrThrowArgs>(args?: SelectSubset<T, SeanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seances
     * const seances = await prisma.seance.findMany()
     * 
     * // Get first 10 Seances
     * const seances = await prisma.seance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seanceWithIdOnly = await prisma.seance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeanceFindManyArgs>(args?: SelectSubset<T, SeanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Seance.
     * @param {SeanceCreateArgs} args - Arguments to create a Seance.
     * @example
     * // Create one Seance
     * const Seance = await prisma.seance.create({
     *   data: {
     *     // ... data to create a Seance
     *   }
     * })
     * 
     */
    create<T extends SeanceCreateArgs>(args: SelectSubset<T, SeanceCreateArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seances.
     * @param {SeanceCreateManyArgs} args - Arguments to create many Seances.
     * @example
     * // Create many Seances
     * const seance = await prisma.seance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeanceCreateManyArgs>(args?: SelectSubset<T, SeanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seances and returns the data saved in the database.
     * @param {SeanceCreateManyAndReturnArgs} args - Arguments to create many Seances.
     * @example
     * // Create many Seances
     * const seance = await prisma.seance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seances and only return the `id`
     * const seanceWithIdOnly = await prisma.seance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeanceCreateManyAndReturnArgs>(args?: SelectSubset<T, SeanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Seance.
     * @param {SeanceDeleteArgs} args - Arguments to delete one Seance.
     * @example
     * // Delete one Seance
     * const Seance = await prisma.seance.delete({
     *   where: {
     *     // ... filter to delete one Seance
     *   }
     * })
     * 
     */
    delete<T extends SeanceDeleteArgs>(args: SelectSubset<T, SeanceDeleteArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Seance.
     * @param {SeanceUpdateArgs} args - Arguments to update one Seance.
     * @example
     * // Update one Seance
     * const seance = await prisma.seance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeanceUpdateArgs>(args: SelectSubset<T, SeanceUpdateArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seances.
     * @param {SeanceDeleteManyArgs} args - Arguments to filter Seances to delete.
     * @example
     * // Delete a few Seances
     * const { count } = await prisma.seance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeanceDeleteManyArgs>(args?: SelectSubset<T, SeanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seances
     * const seance = await prisma.seance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeanceUpdateManyArgs>(args: SelectSubset<T, SeanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seance.
     * @param {SeanceUpsertArgs} args - Arguments to update or create a Seance.
     * @example
     * // Update or create a Seance
     * const seance = await prisma.seance.upsert({
     *   create: {
     *     // ... data to create a Seance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seance we want to update
     *   }
     * })
     */
    upsert<T extends SeanceUpsertArgs>(args: SelectSubset<T, SeanceUpsertArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceCountArgs} args - Arguments to filter Seances to count.
     * @example
     * // Count the number of Seances
     * const count = await prisma.seance.count({
     *   where: {
     *     // ... the filter for the Seances we want to count
     *   }
     * })
    **/
    count<T extends SeanceCountArgs>(
      args?: Subset<T, SeanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeanceAggregateArgs>(args: Subset<T, SeanceAggregateArgs>): Prisma.PrismaPromise<GetSeanceAggregateType<T>>

    /**
     * Group by Seance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeanceGroupByArgs['orderBy'] }
        : { orderBy?: SeanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seance model
   */
  readonly fields: SeanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conflitsAsSeance1<T extends Seance$conflitsAsSeance1Args<ExtArgs> = {}>(args?: Subset<T, Seance$conflitsAsSeance1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany"> | Null>
    conflitsAsSeance2<T extends Seance$conflitsAsSeance2Args<ExtArgs> = {}>(args?: Subset<T, Seance$conflitsAsSeance2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany"> | Null>
    intervenant<T extends IntervenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntervenantDefaultArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seance model
   */ 
  interface SeanceFieldRefs {
    readonly id: FieldRef<"Seance", 'String'>
    readonly dateSeance: FieldRef<"Seance", 'DateTime'>
    readonly heureDebut: FieldRef<"Seance", 'String'>
    readonly heureFin: FieldRef<"Seance", 'String'>
    readonly duree: FieldRef<"Seance", 'Int'>
    readonly typeSeance: FieldRef<"Seance", 'TypeSeance'>
    readonly salle: FieldRef<"Seance", 'String'>
    readonly batiment: FieldRef<"Seance", 'String'>
    readonly status: FieldRef<"Seance", 'StatusSeance'>
    readonly moduleId: FieldRef<"Seance", 'String'>
    readonly intervenantId: FieldRef<"Seance", 'String'>
    readonly createdAt: FieldRef<"Seance", 'DateTime'>
    readonly updatedAt: FieldRef<"Seance", 'DateTime'>
    readonly notes: FieldRef<"Seance", 'String'>
    readonly objectifs: FieldRef<"Seance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Seance findUnique
   */
  export type SeanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter, which Seance to fetch.
     */
    where: SeanceWhereUniqueInput
  }

  /**
   * Seance findUniqueOrThrow
   */
  export type SeanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter, which Seance to fetch.
     */
    where: SeanceWhereUniqueInput
  }

  /**
   * Seance findFirst
   */
  export type SeanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter, which Seance to fetch.
     */
    where?: SeanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seances to fetch.
     */
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seances.
     */
    cursor?: SeanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seances.
     */
    distinct?: SeanceScalarFieldEnum | SeanceScalarFieldEnum[]
  }

  /**
   * Seance findFirstOrThrow
   */
  export type SeanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter, which Seance to fetch.
     */
    where?: SeanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seances to fetch.
     */
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seances.
     */
    cursor?: SeanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seances.
     */
    distinct?: SeanceScalarFieldEnum | SeanceScalarFieldEnum[]
  }

  /**
   * Seance findMany
   */
  export type SeanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter, which Seances to fetch.
     */
    where?: SeanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seances to fetch.
     */
    orderBy?: SeanceOrderByWithRelationInput | SeanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seances.
     */
    cursor?: SeanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seances.
     */
    skip?: number
    distinct?: SeanceScalarFieldEnum | SeanceScalarFieldEnum[]
  }

  /**
   * Seance create
   */
  export type SeanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Seance.
     */
    data: XOR<SeanceCreateInput, SeanceUncheckedCreateInput>
  }

  /**
   * Seance createMany
   */
  export type SeanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seances.
     */
    data: SeanceCreateManyInput | SeanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Seance createManyAndReturn
   */
  export type SeanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Seances.
     */
    data: SeanceCreateManyInput | SeanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Seance update
   */
  export type SeanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Seance.
     */
    data: XOR<SeanceUpdateInput, SeanceUncheckedUpdateInput>
    /**
     * Choose, which Seance to update.
     */
    where: SeanceWhereUniqueInput
  }

  /**
   * Seance updateMany
   */
  export type SeanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seances.
     */
    data: XOR<SeanceUpdateManyMutationInput, SeanceUncheckedUpdateManyInput>
    /**
     * Filter which Seances to update
     */
    where?: SeanceWhereInput
  }

  /**
   * Seance upsert
   */
  export type SeanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Seance to update in case it exists.
     */
    where: SeanceWhereUniqueInput
    /**
     * In case the Seance found by the `where` argument doesn't exist, create a new Seance with this data.
     */
    create: XOR<SeanceCreateInput, SeanceUncheckedCreateInput>
    /**
     * In case the Seance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeanceUpdateInput, SeanceUncheckedUpdateInput>
  }

  /**
   * Seance delete
   */
  export type SeanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    /**
     * Filter which Seance to delete.
     */
    where: SeanceWhereUniqueInput
  }

  /**
   * Seance deleteMany
   */
  export type SeanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seances to delete
     */
    where?: SeanceWhereInput
  }

  /**
   * Seance.conflitsAsSeance1
   */
  export type Seance$conflitsAsSeance1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    cursor?: ConflitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Seance.conflitsAsSeance2
   */
  export type Seance$conflitsAsSeance2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    cursor?: ConflitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Seance without action
   */
  export type SeanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
  }


  /**
   * Model Conflit
   */

  export type AggregateConflit = {
    _count: ConflitCountAggregateOutputType | null
    _min: ConflitMinAggregateOutputType | null
    _max: ConflitMaxAggregateOutputType | null
  }

  export type ConflitMinAggregateOutputType = {
    id: string | null
    type: $Enums.TypeConflit | null
    description: string | null
    seanceId1: string | null
    seanceId2: string | null
    ressourceType: string | null
    ressourceId: string | null
    resolu: boolean | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resoluLe: Date | null
    resoluPar: string | null
    severite: $Enums.SeveriteConflit | null
  }

  export type ConflitMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TypeConflit | null
    description: string | null
    seanceId1: string | null
    seanceId2: string | null
    ressourceType: string | null
    ressourceId: string | null
    resolu: boolean | null
    resolution: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resoluLe: Date | null
    resoluPar: string | null
    severite: $Enums.SeveriteConflit | null
  }

  export type ConflitCountAggregateOutputType = {
    id: number
    type: number
    description: number
    seanceId1: number
    seanceId2: number
    ressourceType: number
    ressourceId: number
    resolu: number
    resolution: number
    createdAt: number
    updatedAt: number
    resoluLe: number
    resoluPar: number
    severite: number
    _all: number
  }


  export type ConflitMinAggregateInputType = {
    id?: true
    type?: true
    description?: true
    seanceId1?: true
    seanceId2?: true
    ressourceType?: true
    ressourceId?: true
    resolu?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resoluLe?: true
    resoluPar?: true
    severite?: true
  }

  export type ConflitMaxAggregateInputType = {
    id?: true
    type?: true
    description?: true
    seanceId1?: true
    seanceId2?: true
    ressourceType?: true
    ressourceId?: true
    resolu?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resoluLe?: true
    resoluPar?: true
    severite?: true
  }

  export type ConflitCountAggregateInputType = {
    id?: true
    type?: true
    description?: true
    seanceId1?: true
    seanceId2?: true
    ressourceType?: true
    ressourceId?: true
    resolu?: true
    resolution?: true
    createdAt?: true
    updatedAt?: true
    resoluLe?: true
    resoluPar?: true
    severite?: true
    _all?: true
  }

  export type ConflitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conflit to aggregate.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conflits
    **/
    _count?: true | ConflitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConflitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConflitMaxAggregateInputType
  }

  export type GetConflitAggregateType<T extends ConflitAggregateArgs> = {
        [P in keyof T & keyof AggregateConflit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConflit[P]>
      : GetScalarType<T[P], AggregateConflit[P]>
  }




  export type ConflitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConflitWhereInput
    orderBy?: ConflitOrderByWithAggregationInput | ConflitOrderByWithAggregationInput[]
    by: ConflitScalarFieldEnum[] | ConflitScalarFieldEnum
    having?: ConflitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConflitCountAggregateInputType | true
    _min?: ConflitMinAggregateInputType
    _max?: ConflitMaxAggregateInputType
  }

  export type ConflitGroupByOutputType = {
    id: string
    type: $Enums.TypeConflit
    description: string
    seanceId1: string
    seanceId2: string | null
    ressourceType: string
    ressourceId: string
    resolu: boolean
    resolution: string | null
    createdAt: Date
    updatedAt: Date
    resoluLe: Date | null
    resoluPar: string | null
    severite: $Enums.SeveriteConflit
    _count: ConflitCountAggregateOutputType | null
    _min: ConflitMinAggregateOutputType | null
    _max: ConflitMaxAggregateOutputType | null
  }

  type GetConflitGroupByPayload<T extends ConflitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConflitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConflitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConflitGroupByOutputType[P]>
            : GetScalarType<T[P], ConflitGroupByOutputType[P]>
        }
      >
    >


  export type ConflitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    seanceId1?: boolean
    seanceId2?: boolean
    ressourceType?: boolean
    ressourceId?: boolean
    resolu?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resoluLe?: boolean
    resoluPar?: boolean
    severite?: boolean
    seance1?: boolean | SeanceDefaultArgs<ExtArgs>
    seance2?: boolean | Conflit$seance2Args<ExtArgs>
  }, ExtArgs["result"]["conflit"]>

  export type ConflitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    description?: boolean
    seanceId1?: boolean
    seanceId2?: boolean
    ressourceType?: boolean
    ressourceId?: boolean
    resolu?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resoluLe?: boolean
    resoluPar?: boolean
    severite?: boolean
    seance1?: boolean | SeanceDefaultArgs<ExtArgs>
    seance2?: boolean | Conflit$seance2Args<ExtArgs>
  }, ExtArgs["result"]["conflit"]>

  export type ConflitSelectScalar = {
    id?: boolean
    type?: boolean
    description?: boolean
    seanceId1?: boolean
    seanceId2?: boolean
    ressourceType?: boolean
    ressourceId?: boolean
    resolu?: boolean
    resolution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resoluLe?: boolean
    resoluPar?: boolean
    severite?: boolean
  }

  export type ConflitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seance1?: boolean | SeanceDefaultArgs<ExtArgs>
    seance2?: boolean | Conflit$seance2Args<ExtArgs>
  }
  export type ConflitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seance1?: boolean | SeanceDefaultArgs<ExtArgs>
    seance2?: boolean | Conflit$seance2Args<ExtArgs>
  }

  export type $ConflitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conflit"
    objects: {
      seance1: Prisma.$SeancePayload<ExtArgs>
      seance2: Prisma.$SeancePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TypeConflit
      description: string
      seanceId1: string
      seanceId2: string | null
      ressourceType: string
      ressourceId: string
      resolu: boolean
      resolution: string | null
      createdAt: Date
      updatedAt: Date
      resoluLe: Date | null
      resoluPar: string | null
      severite: $Enums.SeveriteConflit
    }, ExtArgs["result"]["conflit"]>
    composites: {}
  }

  type ConflitGetPayload<S extends boolean | null | undefined | ConflitDefaultArgs> = $Result.GetResult<Prisma.$ConflitPayload, S>

  type ConflitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConflitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConflitCountAggregateInputType | true
    }

  export interface ConflitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conflit'], meta: { name: 'Conflit' } }
    /**
     * Find zero or one Conflit that matches the filter.
     * @param {ConflitFindUniqueArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConflitFindUniqueArgs>(args: SelectSubset<T, ConflitFindUniqueArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conflit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConflitFindUniqueOrThrowArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConflitFindUniqueOrThrowArgs>(args: SelectSubset<T, ConflitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conflit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindFirstArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConflitFindFirstArgs>(args?: SelectSubset<T, ConflitFindFirstArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conflit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindFirstOrThrowArgs} args - Arguments to find a Conflit
     * @example
     * // Get one Conflit
     * const conflit = await prisma.conflit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConflitFindFirstOrThrowArgs>(args?: SelectSubset<T, ConflitFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conflits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conflits
     * const conflits = await prisma.conflit.findMany()
     * 
     * // Get first 10 Conflits
     * const conflits = await prisma.conflit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conflitWithIdOnly = await prisma.conflit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConflitFindManyArgs>(args?: SelectSubset<T, ConflitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conflit.
     * @param {ConflitCreateArgs} args - Arguments to create a Conflit.
     * @example
     * // Create one Conflit
     * const Conflit = await prisma.conflit.create({
     *   data: {
     *     // ... data to create a Conflit
     *   }
     * })
     * 
     */
    create<T extends ConflitCreateArgs>(args: SelectSubset<T, ConflitCreateArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conflits.
     * @param {ConflitCreateManyArgs} args - Arguments to create many Conflits.
     * @example
     * // Create many Conflits
     * const conflit = await prisma.conflit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConflitCreateManyArgs>(args?: SelectSubset<T, ConflitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conflits and returns the data saved in the database.
     * @param {ConflitCreateManyAndReturnArgs} args - Arguments to create many Conflits.
     * @example
     * // Create many Conflits
     * const conflit = await prisma.conflit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conflits and only return the `id`
     * const conflitWithIdOnly = await prisma.conflit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConflitCreateManyAndReturnArgs>(args?: SelectSubset<T, ConflitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conflit.
     * @param {ConflitDeleteArgs} args - Arguments to delete one Conflit.
     * @example
     * // Delete one Conflit
     * const Conflit = await prisma.conflit.delete({
     *   where: {
     *     // ... filter to delete one Conflit
     *   }
     * })
     * 
     */
    delete<T extends ConflitDeleteArgs>(args: SelectSubset<T, ConflitDeleteArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conflit.
     * @param {ConflitUpdateArgs} args - Arguments to update one Conflit.
     * @example
     * // Update one Conflit
     * const conflit = await prisma.conflit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConflitUpdateArgs>(args: SelectSubset<T, ConflitUpdateArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conflits.
     * @param {ConflitDeleteManyArgs} args - Arguments to filter Conflits to delete.
     * @example
     * // Delete a few Conflits
     * const { count } = await prisma.conflit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConflitDeleteManyArgs>(args?: SelectSubset<T, ConflitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conflits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conflits
     * const conflit = await prisma.conflit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConflitUpdateManyArgs>(args: SelectSubset<T, ConflitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conflit.
     * @param {ConflitUpsertArgs} args - Arguments to update or create a Conflit.
     * @example
     * // Update or create a Conflit
     * const conflit = await prisma.conflit.upsert({
     *   create: {
     *     // ... data to create a Conflit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conflit we want to update
     *   }
     * })
     */
    upsert<T extends ConflitUpsertArgs>(args: SelectSubset<T, ConflitUpsertArgs<ExtArgs>>): Prisma__ConflitClient<$Result.GetResult<Prisma.$ConflitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conflits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitCountArgs} args - Arguments to filter Conflits to count.
     * @example
     * // Count the number of Conflits
     * const count = await prisma.conflit.count({
     *   where: {
     *     // ... the filter for the Conflits we want to count
     *   }
     * })
    **/
    count<T extends ConflitCountArgs>(
      args?: Subset<T, ConflitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConflitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conflit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConflitAggregateArgs>(args: Subset<T, ConflitAggregateArgs>): Prisma.PrismaPromise<GetConflitAggregateType<T>>

    /**
     * Group by Conflit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConflitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConflitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConflitGroupByArgs['orderBy'] }
        : { orderBy?: ConflitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConflitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConflitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conflit model
   */
  readonly fields: ConflitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conflit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConflitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seance1<T extends SeanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeanceDefaultArgs<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    seance2<T extends Conflit$seance2Args<ExtArgs> = {}>(args?: Subset<T, Conflit$seance2Args<ExtArgs>>): Prisma__SeanceClient<$Result.GetResult<Prisma.$SeancePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conflit model
   */ 
  interface ConflitFieldRefs {
    readonly id: FieldRef<"Conflit", 'String'>
    readonly type: FieldRef<"Conflit", 'TypeConflit'>
    readonly description: FieldRef<"Conflit", 'String'>
    readonly seanceId1: FieldRef<"Conflit", 'String'>
    readonly seanceId2: FieldRef<"Conflit", 'String'>
    readonly ressourceType: FieldRef<"Conflit", 'String'>
    readonly ressourceId: FieldRef<"Conflit", 'String'>
    readonly resolu: FieldRef<"Conflit", 'Boolean'>
    readonly resolution: FieldRef<"Conflit", 'String'>
    readonly createdAt: FieldRef<"Conflit", 'DateTime'>
    readonly updatedAt: FieldRef<"Conflit", 'DateTime'>
    readonly resoluLe: FieldRef<"Conflit", 'DateTime'>
    readonly resoluPar: FieldRef<"Conflit", 'String'>
    readonly severite: FieldRef<"Conflit", 'SeveriteConflit'>
  }
    

  // Custom InputTypes
  /**
   * Conflit findUnique
   */
  export type ConflitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit findUniqueOrThrow
   */
  export type ConflitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit findFirst
   */
  export type ConflitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conflits.
     */
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit findFirstOrThrow
   */
  export type ConflitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflit to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conflits.
     */
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit findMany
   */
  export type ConflitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter, which Conflits to fetch.
     */
    where?: ConflitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conflits to fetch.
     */
    orderBy?: ConflitOrderByWithRelationInput | ConflitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conflits.
     */
    cursor?: ConflitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conflits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conflits.
     */
    skip?: number
    distinct?: ConflitScalarFieldEnum | ConflitScalarFieldEnum[]
  }

  /**
   * Conflit create
   */
  export type ConflitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The data needed to create a Conflit.
     */
    data: XOR<ConflitCreateInput, ConflitUncheckedCreateInput>
  }

  /**
   * Conflit createMany
   */
  export type ConflitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conflits.
     */
    data: ConflitCreateManyInput | ConflitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conflit createManyAndReturn
   */
  export type ConflitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conflits.
     */
    data: ConflitCreateManyInput | ConflitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conflit update
   */
  export type ConflitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The data needed to update a Conflit.
     */
    data: XOR<ConflitUpdateInput, ConflitUncheckedUpdateInput>
    /**
     * Choose, which Conflit to update.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit updateMany
   */
  export type ConflitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conflits.
     */
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyInput>
    /**
     * Filter which Conflits to update
     */
    where?: ConflitWhereInput
  }

  /**
   * Conflit upsert
   */
  export type ConflitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * The filter to search for the Conflit to update in case it exists.
     */
    where: ConflitWhereUniqueInput
    /**
     * In case the Conflit found by the `where` argument doesn't exist, create a new Conflit with this data.
     */
    create: XOR<ConflitCreateInput, ConflitUncheckedCreateInput>
    /**
     * In case the Conflit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConflitUpdateInput, ConflitUncheckedUpdateInput>
  }

  /**
   * Conflit delete
   */
  export type ConflitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
    /**
     * Filter which Conflit to delete.
     */
    where: ConflitWhereUniqueInput
  }

  /**
   * Conflit deleteMany
   */
  export type ConflitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conflits to delete
     */
    where?: ConflitWhereInput
  }

  /**
   * Conflit.seance2
   */
  export type Conflit$seance2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seance
     */
    select?: SeanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeanceInclude<ExtArgs> | null
    where?: SeanceWhereInput
  }

  /**
   * Conflit without action
   */
  export type ConflitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conflit
     */
    select?: ConflitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConflitInclude<ExtArgs> | null
  }


  /**
   * Model PeriodeAcademique
   */

  export type AggregatePeriodeAcademique = {
    _count: PeriodeAcademiqueCountAggregateOutputType | null
    _min: PeriodeAcademiqueMinAggregateOutputType | null
    _max: PeriodeAcademiqueMaxAggregateOutputType | null
  }

  export type PeriodeAcademiqueMinAggregateOutputType = {
    id: string | null
    nom: string | null
    annee: string | null
    debutS1: Date | null
    finS1: Date | null
    debutS2: Date | null
    finS2: Date | null
    vacancesNoel: Date | null
    finVacancesNoel: Date | null
    vacancesPaques: Date | null
    finVacancesPaques: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeriodeAcademiqueMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    annee: string | null
    debutS1: Date | null
    finS1: Date | null
    debutS2: Date | null
    finS2: Date | null
    vacancesNoel: Date | null
    finVacancesNoel: Date | null
    vacancesPaques: Date | null
    finVacancesPaques: Date | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PeriodeAcademiqueCountAggregateOutputType = {
    id: number
    nom: number
    annee: number
    debutS1: number
    finS1: number
    debutS2: number
    finS2: number
    vacancesNoel: number
    finVacancesNoel: number
    vacancesPaques: number
    finVacancesPaques: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PeriodeAcademiqueMinAggregateInputType = {
    id?: true
    nom?: true
    annee?: true
    debutS1?: true
    finS1?: true
    debutS2?: true
    finS2?: true
    vacancesNoel?: true
    finVacancesNoel?: true
    vacancesPaques?: true
    finVacancesPaques?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeriodeAcademiqueMaxAggregateInputType = {
    id?: true
    nom?: true
    annee?: true
    debutS1?: true
    finS1?: true
    debutS2?: true
    finS2?: true
    vacancesNoel?: true
    finVacancesNoel?: true
    vacancesPaques?: true
    finVacancesPaques?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PeriodeAcademiqueCountAggregateInputType = {
    id?: true
    nom?: true
    annee?: true
    debutS1?: true
    finS1?: true
    debutS2?: true
    finS2?: true
    vacancesNoel?: true
    finVacancesNoel?: true
    vacancesPaques?: true
    finVacancesPaques?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PeriodeAcademiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodeAcademique to aggregate.
     */
    where?: PeriodeAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodeAcademiques to fetch.
     */
    orderBy?: PeriodeAcademiqueOrderByWithRelationInput | PeriodeAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeriodeAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodeAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodeAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PeriodeAcademiques
    **/
    _count?: true | PeriodeAcademiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeriodeAcademiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeriodeAcademiqueMaxAggregateInputType
  }

  export type GetPeriodeAcademiqueAggregateType<T extends PeriodeAcademiqueAggregateArgs> = {
        [P in keyof T & keyof AggregatePeriodeAcademique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeriodeAcademique[P]>
      : GetScalarType<T[P], AggregatePeriodeAcademique[P]>
  }




  export type PeriodeAcademiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PeriodeAcademiqueWhereInput
    orderBy?: PeriodeAcademiqueOrderByWithAggregationInput | PeriodeAcademiqueOrderByWithAggregationInput[]
    by: PeriodeAcademiqueScalarFieldEnum[] | PeriodeAcademiqueScalarFieldEnum
    having?: PeriodeAcademiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeriodeAcademiqueCountAggregateInputType | true
    _min?: PeriodeAcademiqueMinAggregateInputType
    _max?: PeriodeAcademiqueMaxAggregateInputType
  }

  export type PeriodeAcademiqueGroupByOutputType = {
    id: string
    nom: string
    annee: string
    debutS1: Date
    finS1: Date
    debutS2: Date
    finS2: Date
    vacancesNoel: Date
    finVacancesNoel: Date
    vacancesPaques: Date | null
    finVacancesPaques: Date | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: PeriodeAcademiqueCountAggregateOutputType | null
    _min: PeriodeAcademiqueMinAggregateOutputType | null
    _max: PeriodeAcademiqueMaxAggregateOutputType | null
  }

  type GetPeriodeAcademiqueGroupByPayload<T extends PeriodeAcademiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeriodeAcademiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeriodeAcademiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeriodeAcademiqueGroupByOutputType[P]>
            : GetScalarType<T[P], PeriodeAcademiqueGroupByOutputType[P]>
        }
      >
    >


  export type PeriodeAcademiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    annee?: boolean
    debutS1?: boolean
    finS1?: boolean
    debutS2?: boolean
    finS2?: boolean
    vacancesNoel?: boolean
    finVacancesNoel?: boolean
    vacancesPaques?: boolean
    finVacancesPaques?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    activitesAcademiques?: boolean | PeriodeAcademique$activitesAcademiquesArgs<ExtArgs>
    indicateursAcademiques?: boolean | PeriodeAcademique$indicateursAcademiquesArgs<ExtArgs>
    _count?: boolean | PeriodeAcademiqueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["periodeAcademique"]>

  export type PeriodeAcademiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    annee?: boolean
    debutS1?: boolean
    finS1?: boolean
    debutS2?: boolean
    finS2?: boolean
    vacancesNoel?: boolean
    finVacancesNoel?: boolean
    vacancesPaques?: boolean
    finVacancesPaques?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["periodeAcademique"]>

  export type PeriodeAcademiqueSelectScalar = {
    id?: boolean
    nom?: boolean
    annee?: boolean
    debutS1?: boolean
    finS1?: boolean
    debutS2?: boolean
    finS2?: boolean
    vacancesNoel?: boolean
    finVacancesNoel?: boolean
    vacancesPaques?: boolean
    finVacancesPaques?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PeriodeAcademiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activitesAcademiques?: boolean | PeriodeAcademique$activitesAcademiquesArgs<ExtArgs>
    indicateursAcademiques?: boolean | PeriodeAcademique$indicateursAcademiquesArgs<ExtArgs>
    _count?: boolean | PeriodeAcademiqueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PeriodeAcademiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PeriodeAcademiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PeriodeAcademique"
    objects: {
      activitesAcademiques: Prisma.$ActiviteAcademiquePayload<ExtArgs>[]
      indicateursAcademiques: Prisma.$IndicateurAcademiquePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      annee: string
      debutS1: Date
      finS1: Date
      debutS2: Date
      finS2: Date
      vacancesNoel: Date
      finVacancesNoel: Date
      vacancesPaques: Date | null
      finVacancesPaques: Date | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["periodeAcademique"]>
    composites: {}
  }

  type PeriodeAcademiqueGetPayload<S extends boolean | null | undefined | PeriodeAcademiqueDefaultArgs> = $Result.GetResult<Prisma.$PeriodeAcademiquePayload, S>

  type PeriodeAcademiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PeriodeAcademiqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PeriodeAcademiqueCountAggregateInputType | true
    }

  export interface PeriodeAcademiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PeriodeAcademique'], meta: { name: 'PeriodeAcademique' } }
    /**
     * Find zero or one PeriodeAcademique that matches the filter.
     * @param {PeriodeAcademiqueFindUniqueArgs} args - Arguments to find a PeriodeAcademique
     * @example
     * // Get one PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PeriodeAcademiqueFindUniqueArgs>(args: SelectSubset<T, PeriodeAcademiqueFindUniqueArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PeriodeAcademique that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PeriodeAcademiqueFindUniqueOrThrowArgs} args - Arguments to find a PeriodeAcademique
     * @example
     * // Get one PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PeriodeAcademiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, PeriodeAcademiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PeriodeAcademique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueFindFirstArgs} args - Arguments to find a PeriodeAcademique
     * @example
     * // Get one PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PeriodeAcademiqueFindFirstArgs>(args?: SelectSubset<T, PeriodeAcademiqueFindFirstArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PeriodeAcademique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueFindFirstOrThrowArgs} args - Arguments to find a PeriodeAcademique
     * @example
     * // Get one PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PeriodeAcademiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, PeriodeAcademiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PeriodeAcademiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PeriodeAcademiques
     * const periodeAcademiques = await prisma.periodeAcademique.findMany()
     * 
     * // Get first 10 PeriodeAcademiques
     * const periodeAcademiques = await prisma.periodeAcademique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const periodeAcademiqueWithIdOnly = await prisma.periodeAcademique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PeriodeAcademiqueFindManyArgs>(args?: SelectSubset<T, PeriodeAcademiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PeriodeAcademique.
     * @param {PeriodeAcademiqueCreateArgs} args - Arguments to create a PeriodeAcademique.
     * @example
     * // Create one PeriodeAcademique
     * const PeriodeAcademique = await prisma.periodeAcademique.create({
     *   data: {
     *     // ... data to create a PeriodeAcademique
     *   }
     * })
     * 
     */
    create<T extends PeriodeAcademiqueCreateArgs>(args: SelectSubset<T, PeriodeAcademiqueCreateArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PeriodeAcademiques.
     * @param {PeriodeAcademiqueCreateManyArgs} args - Arguments to create many PeriodeAcademiques.
     * @example
     * // Create many PeriodeAcademiques
     * const periodeAcademique = await prisma.periodeAcademique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PeriodeAcademiqueCreateManyArgs>(args?: SelectSubset<T, PeriodeAcademiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PeriodeAcademiques and returns the data saved in the database.
     * @param {PeriodeAcademiqueCreateManyAndReturnArgs} args - Arguments to create many PeriodeAcademiques.
     * @example
     * // Create many PeriodeAcademiques
     * const periodeAcademique = await prisma.periodeAcademique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PeriodeAcademiques and only return the `id`
     * const periodeAcademiqueWithIdOnly = await prisma.periodeAcademique.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PeriodeAcademiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, PeriodeAcademiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PeriodeAcademique.
     * @param {PeriodeAcademiqueDeleteArgs} args - Arguments to delete one PeriodeAcademique.
     * @example
     * // Delete one PeriodeAcademique
     * const PeriodeAcademique = await prisma.periodeAcademique.delete({
     *   where: {
     *     // ... filter to delete one PeriodeAcademique
     *   }
     * })
     * 
     */
    delete<T extends PeriodeAcademiqueDeleteArgs>(args: SelectSubset<T, PeriodeAcademiqueDeleteArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PeriodeAcademique.
     * @param {PeriodeAcademiqueUpdateArgs} args - Arguments to update one PeriodeAcademique.
     * @example
     * // Update one PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PeriodeAcademiqueUpdateArgs>(args: SelectSubset<T, PeriodeAcademiqueUpdateArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PeriodeAcademiques.
     * @param {PeriodeAcademiqueDeleteManyArgs} args - Arguments to filter PeriodeAcademiques to delete.
     * @example
     * // Delete a few PeriodeAcademiques
     * const { count } = await prisma.periodeAcademique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PeriodeAcademiqueDeleteManyArgs>(args?: SelectSubset<T, PeriodeAcademiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PeriodeAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PeriodeAcademiques
     * const periodeAcademique = await prisma.periodeAcademique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PeriodeAcademiqueUpdateManyArgs>(args: SelectSubset<T, PeriodeAcademiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PeriodeAcademique.
     * @param {PeriodeAcademiqueUpsertArgs} args - Arguments to update or create a PeriodeAcademique.
     * @example
     * // Update or create a PeriodeAcademique
     * const periodeAcademique = await prisma.periodeAcademique.upsert({
     *   create: {
     *     // ... data to create a PeriodeAcademique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PeriodeAcademique we want to update
     *   }
     * })
     */
    upsert<T extends PeriodeAcademiqueUpsertArgs>(args: SelectSubset<T, PeriodeAcademiqueUpsertArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PeriodeAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueCountArgs} args - Arguments to filter PeriodeAcademiques to count.
     * @example
     * // Count the number of PeriodeAcademiques
     * const count = await prisma.periodeAcademique.count({
     *   where: {
     *     // ... the filter for the PeriodeAcademiques we want to count
     *   }
     * })
    **/
    count<T extends PeriodeAcademiqueCountArgs>(
      args?: Subset<T, PeriodeAcademiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeriodeAcademiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PeriodeAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeriodeAcademiqueAggregateArgs>(args: Subset<T, PeriodeAcademiqueAggregateArgs>): Prisma.PrismaPromise<GetPeriodeAcademiqueAggregateType<T>>

    /**
     * Group by PeriodeAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeriodeAcademiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeriodeAcademiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeriodeAcademiqueGroupByArgs['orderBy'] }
        : { orderBy?: PeriodeAcademiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeriodeAcademiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeriodeAcademiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PeriodeAcademique model
   */
  readonly fields: PeriodeAcademiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PeriodeAcademique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeriodeAcademiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activitesAcademiques<T extends PeriodeAcademique$activitesAcademiquesArgs<ExtArgs> = {}>(args?: Subset<T, PeriodeAcademique$activitesAcademiquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findMany"> | Null>
    indicateursAcademiques<T extends PeriodeAcademique$indicateursAcademiquesArgs<ExtArgs> = {}>(args?: Subset<T, PeriodeAcademique$indicateursAcademiquesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PeriodeAcademique model
   */ 
  interface PeriodeAcademiqueFieldRefs {
    readonly id: FieldRef<"PeriodeAcademique", 'String'>
    readonly nom: FieldRef<"PeriodeAcademique", 'String'>
    readonly annee: FieldRef<"PeriodeAcademique", 'String'>
    readonly debutS1: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly finS1: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly debutS2: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly finS2: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly vacancesNoel: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly finVacancesNoel: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly vacancesPaques: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly finVacancesPaques: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly active: FieldRef<"PeriodeAcademique", 'Boolean'>
    readonly createdAt: FieldRef<"PeriodeAcademique", 'DateTime'>
    readonly updatedAt: FieldRef<"PeriodeAcademique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PeriodeAcademique findUnique
   */
  export type PeriodeAcademiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which PeriodeAcademique to fetch.
     */
    where: PeriodeAcademiqueWhereUniqueInput
  }

  /**
   * PeriodeAcademique findUniqueOrThrow
   */
  export type PeriodeAcademiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which PeriodeAcademique to fetch.
     */
    where: PeriodeAcademiqueWhereUniqueInput
  }

  /**
   * PeriodeAcademique findFirst
   */
  export type PeriodeAcademiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which PeriodeAcademique to fetch.
     */
    where?: PeriodeAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodeAcademiques to fetch.
     */
    orderBy?: PeriodeAcademiqueOrderByWithRelationInput | PeriodeAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodeAcademiques.
     */
    cursor?: PeriodeAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodeAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodeAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodeAcademiques.
     */
    distinct?: PeriodeAcademiqueScalarFieldEnum | PeriodeAcademiqueScalarFieldEnum[]
  }

  /**
   * PeriodeAcademique findFirstOrThrow
   */
  export type PeriodeAcademiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which PeriodeAcademique to fetch.
     */
    where?: PeriodeAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodeAcademiques to fetch.
     */
    orderBy?: PeriodeAcademiqueOrderByWithRelationInput | PeriodeAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PeriodeAcademiques.
     */
    cursor?: PeriodeAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodeAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodeAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PeriodeAcademiques.
     */
    distinct?: PeriodeAcademiqueScalarFieldEnum | PeriodeAcademiqueScalarFieldEnum[]
  }

  /**
   * PeriodeAcademique findMany
   */
  export type PeriodeAcademiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which PeriodeAcademiques to fetch.
     */
    where?: PeriodeAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PeriodeAcademiques to fetch.
     */
    orderBy?: PeriodeAcademiqueOrderByWithRelationInput | PeriodeAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PeriodeAcademiques.
     */
    cursor?: PeriodeAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PeriodeAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PeriodeAcademiques.
     */
    skip?: number
    distinct?: PeriodeAcademiqueScalarFieldEnum | PeriodeAcademiqueScalarFieldEnum[]
  }

  /**
   * PeriodeAcademique create
   */
  export type PeriodeAcademiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a PeriodeAcademique.
     */
    data: XOR<PeriodeAcademiqueCreateInput, PeriodeAcademiqueUncheckedCreateInput>
  }

  /**
   * PeriodeAcademique createMany
   */
  export type PeriodeAcademiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PeriodeAcademiques.
     */
    data: PeriodeAcademiqueCreateManyInput | PeriodeAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PeriodeAcademique createManyAndReturn
   */
  export type PeriodeAcademiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PeriodeAcademiques.
     */
    data: PeriodeAcademiqueCreateManyInput | PeriodeAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PeriodeAcademique update
   */
  export type PeriodeAcademiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a PeriodeAcademique.
     */
    data: XOR<PeriodeAcademiqueUpdateInput, PeriodeAcademiqueUncheckedUpdateInput>
    /**
     * Choose, which PeriodeAcademique to update.
     */
    where: PeriodeAcademiqueWhereUniqueInput
  }

  /**
   * PeriodeAcademique updateMany
   */
  export type PeriodeAcademiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PeriodeAcademiques.
     */
    data: XOR<PeriodeAcademiqueUpdateManyMutationInput, PeriodeAcademiqueUncheckedUpdateManyInput>
    /**
     * Filter which PeriodeAcademiques to update
     */
    where?: PeriodeAcademiqueWhereInput
  }

  /**
   * PeriodeAcademique upsert
   */
  export type PeriodeAcademiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the PeriodeAcademique to update in case it exists.
     */
    where: PeriodeAcademiqueWhereUniqueInput
    /**
     * In case the PeriodeAcademique found by the `where` argument doesn't exist, create a new PeriodeAcademique with this data.
     */
    create: XOR<PeriodeAcademiqueCreateInput, PeriodeAcademiqueUncheckedCreateInput>
    /**
     * In case the PeriodeAcademique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeriodeAcademiqueUpdateInput, PeriodeAcademiqueUncheckedUpdateInput>
  }

  /**
   * PeriodeAcademique delete
   */
  export type PeriodeAcademiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
    /**
     * Filter which PeriodeAcademique to delete.
     */
    where: PeriodeAcademiqueWhereUniqueInput
  }

  /**
   * PeriodeAcademique deleteMany
   */
  export type PeriodeAcademiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PeriodeAcademiques to delete
     */
    where?: PeriodeAcademiqueWhereInput
  }

  /**
   * PeriodeAcademique.activitesAcademiques
   */
  export type PeriodeAcademique$activitesAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    where?: ActiviteAcademiqueWhereInput
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    cursor?: ActiviteAcademiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActiviteAcademiqueScalarFieldEnum | ActiviteAcademiqueScalarFieldEnum[]
  }

  /**
   * PeriodeAcademique.indicateursAcademiques
   */
  export type PeriodeAcademique$indicateursAcademiquesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    where?: IndicateurAcademiqueWhereInput
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    cursor?: IndicateurAcademiqueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * PeriodeAcademique without action
   */
  export type PeriodeAcademiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PeriodeAcademique
     */
    select?: PeriodeAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PeriodeAcademiqueInclude<ExtArgs> | null
  }


  /**
   * Model JournalActivite
   */

  export type AggregateJournalActivite = {
    _count: JournalActiviteCountAggregateOutputType | null
    _min: JournalActiviteMinAggregateOutputType | null
    _max: JournalActiviteMaxAggregateOutputType | null
  }

  export type JournalActiviteMinAggregateOutputType = {
    id: string | null
    action: $Enums.ActionType | null
    entite: string | null
    entiteId: string | null
    description: string | null
    ancienneValeur: string | null
    nouvelleValeur: string | null
    userId: string | null
    userName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type JournalActiviteMaxAggregateOutputType = {
    id: string | null
    action: $Enums.ActionType | null
    entite: string | null
    entiteId: string | null
    description: string | null
    ancienneValeur: string | null
    nouvelleValeur: string | null
    userId: string | null
    userName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type JournalActiviteCountAggregateOutputType = {
    id: number
    action: number
    entite: number
    entiteId: number
    description: number
    ancienneValeur: number
    nouvelleValeur: number
    userId: number
    userName: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type JournalActiviteMinAggregateInputType = {
    id?: true
    action?: true
    entite?: true
    entiteId?: true
    description?: true
    ancienneValeur?: true
    nouvelleValeur?: true
    userId?: true
    userName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type JournalActiviteMaxAggregateInputType = {
    id?: true
    action?: true
    entite?: true
    entiteId?: true
    description?: true
    ancienneValeur?: true
    nouvelleValeur?: true
    userId?: true
    userName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type JournalActiviteCountAggregateInputType = {
    id?: true
    action?: true
    entite?: true
    entiteId?: true
    description?: true
    ancienneValeur?: true
    nouvelleValeur?: true
    userId?: true
    userName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type JournalActiviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalActivite to aggregate.
     */
    where?: JournalActiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalActivites to fetch.
     */
    orderBy?: JournalActiviteOrderByWithRelationInput | JournalActiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JournalActiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalActivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalActivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JournalActivites
    **/
    _count?: true | JournalActiviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JournalActiviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JournalActiviteMaxAggregateInputType
  }

  export type GetJournalActiviteAggregateType<T extends JournalActiviteAggregateArgs> = {
        [P in keyof T & keyof AggregateJournalActivite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJournalActivite[P]>
      : GetScalarType<T[P], AggregateJournalActivite[P]>
  }




  export type JournalActiviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JournalActiviteWhereInput
    orderBy?: JournalActiviteOrderByWithAggregationInput | JournalActiviteOrderByWithAggregationInput[]
    by: JournalActiviteScalarFieldEnum[] | JournalActiviteScalarFieldEnum
    having?: JournalActiviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JournalActiviteCountAggregateInputType | true
    _min?: JournalActiviteMinAggregateInputType
    _max?: JournalActiviteMaxAggregateInputType
  }

  export type JournalActiviteGroupByOutputType = {
    id: string
    action: $Enums.ActionType
    entite: string
    entiteId: string
    description: string
    ancienneValeur: string | null
    nouvelleValeur: string | null
    userId: string
    userName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: JournalActiviteCountAggregateOutputType | null
    _min: JournalActiviteMinAggregateOutputType | null
    _max: JournalActiviteMaxAggregateOutputType | null
  }

  type GetJournalActiviteGroupByPayload<T extends JournalActiviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JournalActiviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JournalActiviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JournalActiviteGroupByOutputType[P]>
            : GetScalarType<T[P], JournalActiviteGroupByOutputType[P]>
        }
      >
    >


  export type JournalActiviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entite?: boolean
    entiteId?: boolean
    description?: boolean
    ancienneValeur?: boolean
    nouvelleValeur?: boolean
    userId?: boolean
    userName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["journalActivite"]>

  export type JournalActiviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entite?: boolean
    entiteId?: boolean
    description?: boolean
    ancienneValeur?: boolean
    nouvelleValeur?: boolean
    userId?: boolean
    userName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["journalActivite"]>

  export type JournalActiviteSelectScalar = {
    id?: boolean
    action?: boolean
    entite?: boolean
    entiteId?: boolean
    description?: boolean
    ancienneValeur?: boolean
    nouvelleValeur?: boolean
    userId?: boolean
    userName?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }


  export type $JournalActivitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JournalActivite"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.ActionType
      entite: string
      entiteId: string
      description: string
      ancienneValeur: string | null
      nouvelleValeur: string | null
      userId: string
      userName: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["journalActivite"]>
    composites: {}
  }

  type JournalActiviteGetPayload<S extends boolean | null | undefined | JournalActiviteDefaultArgs> = $Result.GetResult<Prisma.$JournalActivitePayload, S>

  type JournalActiviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JournalActiviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JournalActiviteCountAggregateInputType | true
    }

  export interface JournalActiviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JournalActivite'], meta: { name: 'JournalActivite' } }
    /**
     * Find zero or one JournalActivite that matches the filter.
     * @param {JournalActiviteFindUniqueArgs} args - Arguments to find a JournalActivite
     * @example
     * // Get one JournalActivite
     * const journalActivite = await prisma.journalActivite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JournalActiviteFindUniqueArgs>(args: SelectSubset<T, JournalActiviteFindUniqueArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JournalActivite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JournalActiviteFindUniqueOrThrowArgs} args - Arguments to find a JournalActivite
     * @example
     * // Get one JournalActivite
     * const journalActivite = await prisma.journalActivite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JournalActiviteFindUniqueOrThrowArgs>(args: SelectSubset<T, JournalActiviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JournalActivite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteFindFirstArgs} args - Arguments to find a JournalActivite
     * @example
     * // Get one JournalActivite
     * const journalActivite = await prisma.journalActivite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JournalActiviteFindFirstArgs>(args?: SelectSubset<T, JournalActiviteFindFirstArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JournalActivite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteFindFirstOrThrowArgs} args - Arguments to find a JournalActivite
     * @example
     * // Get one JournalActivite
     * const journalActivite = await prisma.journalActivite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JournalActiviteFindFirstOrThrowArgs>(args?: SelectSubset<T, JournalActiviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JournalActivites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JournalActivites
     * const journalActivites = await prisma.journalActivite.findMany()
     * 
     * // Get first 10 JournalActivites
     * const journalActivites = await prisma.journalActivite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journalActiviteWithIdOnly = await prisma.journalActivite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JournalActiviteFindManyArgs>(args?: SelectSubset<T, JournalActiviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JournalActivite.
     * @param {JournalActiviteCreateArgs} args - Arguments to create a JournalActivite.
     * @example
     * // Create one JournalActivite
     * const JournalActivite = await prisma.journalActivite.create({
     *   data: {
     *     // ... data to create a JournalActivite
     *   }
     * })
     * 
     */
    create<T extends JournalActiviteCreateArgs>(args: SelectSubset<T, JournalActiviteCreateArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JournalActivites.
     * @param {JournalActiviteCreateManyArgs} args - Arguments to create many JournalActivites.
     * @example
     * // Create many JournalActivites
     * const journalActivite = await prisma.journalActivite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JournalActiviteCreateManyArgs>(args?: SelectSubset<T, JournalActiviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JournalActivites and returns the data saved in the database.
     * @param {JournalActiviteCreateManyAndReturnArgs} args - Arguments to create many JournalActivites.
     * @example
     * // Create many JournalActivites
     * const journalActivite = await prisma.journalActivite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JournalActivites and only return the `id`
     * const journalActiviteWithIdOnly = await prisma.journalActivite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JournalActiviteCreateManyAndReturnArgs>(args?: SelectSubset<T, JournalActiviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a JournalActivite.
     * @param {JournalActiviteDeleteArgs} args - Arguments to delete one JournalActivite.
     * @example
     * // Delete one JournalActivite
     * const JournalActivite = await prisma.journalActivite.delete({
     *   where: {
     *     // ... filter to delete one JournalActivite
     *   }
     * })
     * 
     */
    delete<T extends JournalActiviteDeleteArgs>(args: SelectSubset<T, JournalActiviteDeleteArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JournalActivite.
     * @param {JournalActiviteUpdateArgs} args - Arguments to update one JournalActivite.
     * @example
     * // Update one JournalActivite
     * const journalActivite = await prisma.journalActivite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JournalActiviteUpdateArgs>(args: SelectSubset<T, JournalActiviteUpdateArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JournalActivites.
     * @param {JournalActiviteDeleteManyArgs} args - Arguments to filter JournalActivites to delete.
     * @example
     * // Delete a few JournalActivites
     * const { count } = await prisma.journalActivite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JournalActiviteDeleteManyArgs>(args?: SelectSubset<T, JournalActiviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JournalActivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JournalActivites
     * const journalActivite = await prisma.journalActivite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JournalActiviteUpdateManyArgs>(args: SelectSubset<T, JournalActiviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JournalActivite.
     * @param {JournalActiviteUpsertArgs} args - Arguments to update or create a JournalActivite.
     * @example
     * // Update or create a JournalActivite
     * const journalActivite = await prisma.journalActivite.upsert({
     *   create: {
     *     // ... data to create a JournalActivite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JournalActivite we want to update
     *   }
     * })
     */
    upsert<T extends JournalActiviteUpsertArgs>(args: SelectSubset<T, JournalActiviteUpsertArgs<ExtArgs>>): Prisma__JournalActiviteClient<$Result.GetResult<Prisma.$JournalActivitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JournalActivites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteCountArgs} args - Arguments to filter JournalActivites to count.
     * @example
     * // Count the number of JournalActivites
     * const count = await prisma.journalActivite.count({
     *   where: {
     *     // ... the filter for the JournalActivites we want to count
     *   }
     * })
    **/
    count<T extends JournalActiviteCountArgs>(
      args?: Subset<T, JournalActiviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JournalActiviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JournalActivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JournalActiviteAggregateArgs>(args: Subset<T, JournalActiviteAggregateArgs>): Prisma.PrismaPromise<GetJournalActiviteAggregateType<T>>

    /**
     * Group by JournalActivite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JournalActiviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JournalActiviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JournalActiviteGroupByArgs['orderBy'] }
        : { orderBy?: JournalActiviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JournalActiviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJournalActiviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JournalActivite model
   */
  readonly fields: JournalActiviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JournalActivite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JournalActiviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JournalActivite model
   */ 
  interface JournalActiviteFieldRefs {
    readonly id: FieldRef<"JournalActivite", 'String'>
    readonly action: FieldRef<"JournalActivite", 'ActionType'>
    readonly entite: FieldRef<"JournalActivite", 'String'>
    readonly entiteId: FieldRef<"JournalActivite", 'String'>
    readonly description: FieldRef<"JournalActivite", 'String'>
    readonly ancienneValeur: FieldRef<"JournalActivite", 'String'>
    readonly nouvelleValeur: FieldRef<"JournalActivite", 'String'>
    readonly userId: FieldRef<"JournalActivite", 'String'>
    readonly userName: FieldRef<"JournalActivite", 'String'>
    readonly ipAddress: FieldRef<"JournalActivite", 'String'>
    readonly userAgent: FieldRef<"JournalActivite", 'String'>
    readonly createdAt: FieldRef<"JournalActivite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JournalActivite findUnique
   */
  export type JournalActiviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter, which JournalActivite to fetch.
     */
    where: JournalActiviteWhereUniqueInput
  }

  /**
   * JournalActivite findUniqueOrThrow
   */
  export type JournalActiviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter, which JournalActivite to fetch.
     */
    where: JournalActiviteWhereUniqueInput
  }

  /**
   * JournalActivite findFirst
   */
  export type JournalActiviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter, which JournalActivite to fetch.
     */
    where?: JournalActiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalActivites to fetch.
     */
    orderBy?: JournalActiviteOrderByWithRelationInput | JournalActiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalActivites.
     */
    cursor?: JournalActiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalActivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalActivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalActivites.
     */
    distinct?: JournalActiviteScalarFieldEnum | JournalActiviteScalarFieldEnum[]
  }

  /**
   * JournalActivite findFirstOrThrow
   */
  export type JournalActiviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter, which JournalActivite to fetch.
     */
    where?: JournalActiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalActivites to fetch.
     */
    orderBy?: JournalActiviteOrderByWithRelationInput | JournalActiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JournalActivites.
     */
    cursor?: JournalActiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalActivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalActivites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JournalActivites.
     */
    distinct?: JournalActiviteScalarFieldEnum | JournalActiviteScalarFieldEnum[]
  }

  /**
   * JournalActivite findMany
   */
  export type JournalActiviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter, which JournalActivites to fetch.
     */
    where?: JournalActiviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JournalActivites to fetch.
     */
    orderBy?: JournalActiviteOrderByWithRelationInput | JournalActiviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JournalActivites.
     */
    cursor?: JournalActiviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JournalActivites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JournalActivites.
     */
    skip?: number
    distinct?: JournalActiviteScalarFieldEnum | JournalActiviteScalarFieldEnum[]
  }

  /**
   * JournalActivite create
   */
  export type JournalActiviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * The data needed to create a JournalActivite.
     */
    data: XOR<JournalActiviteCreateInput, JournalActiviteUncheckedCreateInput>
  }

  /**
   * JournalActivite createMany
   */
  export type JournalActiviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JournalActivites.
     */
    data: JournalActiviteCreateManyInput | JournalActiviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalActivite createManyAndReturn
   */
  export type JournalActiviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many JournalActivites.
     */
    data: JournalActiviteCreateManyInput | JournalActiviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JournalActivite update
   */
  export type JournalActiviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * The data needed to update a JournalActivite.
     */
    data: XOR<JournalActiviteUpdateInput, JournalActiviteUncheckedUpdateInput>
    /**
     * Choose, which JournalActivite to update.
     */
    where: JournalActiviteWhereUniqueInput
  }

  /**
   * JournalActivite updateMany
   */
  export type JournalActiviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JournalActivites.
     */
    data: XOR<JournalActiviteUpdateManyMutationInput, JournalActiviteUncheckedUpdateManyInput>
    /**
     * Filter which JournalActivites to update
     */
    where?: JournalActiviteWhereInput
  }

  /**
   * JournalActivite upsert
   */
  export type JournalActiviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * The filter to search for the JournalActivite to update in case it exists.
     */
    where: JournalActiviteWhereUniqueInput
    /**
     * In case the JournalActivite found by the `where` argument doesn't exist, create a new JournalActivite with this data.
     */
    create: XOR<JournalActiviteCreateInput, JournalActiviteUncheckedCreateInput>
    /**
     * In case the JournalActivite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JournalActiviteUpdateInput, JournalActiviteUncheckedUpdateInput>
  }

  /**
   * JournalActivite delete
   */
  export type JournalActiviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
    /**
     * Filter which JournalActivite to delete.
     */
    where: JournalActiviteWhereUniqueInput
  }

  /**
   * JournalActivite deleteMany
   */
  export type JournalActiviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JournalActivites to delete
     */
    where?: JournalActiviteWhereInput
  }

  /**
   * JournalActivite without action
   */
  export type JournalActiviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JournalActivite
     */
    select?: JournalActiviteSelect<ExtArgs> | null
  }


  /**
   * Model ActiviteAcademique
   */

  export type AggregateActiviteAcademique = {
    _count: ActiviteAcademiqueCountAggregateOutputType | null
    _min: ActiviteAcademiqueMinAggregateOutputType | null
    _max: ActiviteAcademiqueMaxAggregateOutputType | null
  }

  export type ActiviteAcademiqueMinAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    datePrevue: Date | null
    dateReelle: Date | null
    type: string | null
    programmeId: string | null
    periodeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActiviteAcademiqueMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    datePrevue: Date | null
    dateReelle: Date | null
    type: string | null
    programmeId: string | null
    periodeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActiviteAcademiqueCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    datePrevue: number
    dateReelle: number
    type: number
    programmeId: number
    periodeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActiviteAcademiqueMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    datePrevue?: true
    dateReelle?: true
    type?: true
    programmeId?: true
    periodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActiviteAcademiqueMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    datePrevue?: true
    dateReelle?: true
    type?: true
    programmeId?: true
    periodeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActiviteAcademiqueCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    datePrevue?: true
    dateReelle?: true
    type?: true
    programmeId?: true
    periodeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActiviteAcademiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiviteAcademique to aggregate.
     */
    where?: ActiviteAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiviteAcademiques to fetch.
     */
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActiviteAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiviteAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiviteAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActiviteAcademiques
    **/
    _count?: true | ActiviteAcademiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActiviteAcademiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActiviteAcademiqueMaxAggregateInputType
  }

  export type GetActiviteAcademiqueAggregateType<T extends ActiviteAcademiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateActiviteAcademique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActiviteAcademique[P]>
      : GetScalarType<T[P], AggregateActiviteAcademique[P]>
  }




  export type ActiviteAcademiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActiviteAcademiqueWhereInput
    orderBy?: ActiviteAcademiqueOrderByWithAggregationInput | ActiviteAcademiqueOrderByWithAggregationInput[]
    by: ActiviteAcademiqueScalarFieldEnum[] | ActiviteAcademiqueScalarFieldEnum
    having?: ActiviteAcademiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActiviteAcademiqueCountAggregateInputType | true
    _min?: ActiviteAcademiqueMinAggregateInputType
    _max?: ActiviteAcademiqueMaxAggregateInputType
  }

  export type ActiviteAcademiqueGroupByOutputType = {
    id: string
    nom: string
    description: string | null
    datePrevue: Date | null
    dateReelle: Date | null
    type: string
    programmeId: string
    periodeId: string
    createdAt: Date
    updatedAt: Date
    _count: ActiviteAcademiqueCountAggregateOutputType | null
    _min: ActiviteAcademiqueMinAggregateOutputType | null
    _max: ActiviteAcademiqueMaxAggregateOutputType | null
  }

  type GetActiviteAcademiqueGroupByPayload<T extends ActiviteAcademiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActiviteAcademiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActiviteAcademiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActiviteAcademiqueGroupByOutputType[P]>
            : GetScalarType<T[P], ActiviteAcademiqueGroupByOutputType[P]>
        }
      >
    >


  export type ActiviteAcademiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    datePrevue?: boolean
    dateReelle?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activiteAcademique"]>

  export type ActiviteAcademiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    datePrevue?: boolean
    dateReelle?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activiteAcademique"]>

  export type ActiviteAcademiqueSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    datePrevue?: boolean
    dateReelle?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActiviteAcademiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
  }
  export type ActiviteAcademiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
  }

  export type $ActiviteAcademiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActiviteAcademique"
    objects: {
      periode: Prisma.$PeriodeAcademiquePayload<ExtArgs>
      programme: Prisma.$ProgrammePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      description: string | null
      datePrevue: Date | null
      dateReelle: Date | null
      type: string
      programmeId: string
      periodeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["activiteAcademique"]>
    composites: {}
  }

  type ActiviteAcademiqueGetPayload<S extends boolean | null | undefined | ActiviteAcademiqueDefaultArgs> = $Result.GetResult<Prisma.$ActiviteAcademiquePayload, S>

  type ActiviteAcademiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActiviteAcademiqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActiviteAcademiqueCountAggregateInputType | true
    }

  export interface ActiviteAcademiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActiviteAcademique'], meta: { name: 'ActiviteAcademique' } }
    /**
     * Find zero or one ActiviteAcademique that matches the filter.
     * @param {ActiviteAcademiqueFindUniqueArgs} args - Arguments to find a ActiviteAcademique
     * @example
     * // Get one ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActiviteAcademiqueFindUniqueArgs>(args: SelectSubset<T, ActiviteAcademiqueFindUniqueArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActiviteAcademique that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActiviteAcademiqueFindUniqueOrThrowArgs} args - Arguments to find a ActiviteAcademique
     * @example
     * // Get one ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActiviteAcademiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, ActiviteAcademiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActiviteAcademique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueFindFirstArgs} args - Arguments to find a ActiviteAcademique
     * @example
     * // Get one ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActiviteAcademiqueFindFirstArgs>(args?: SelectSubset<T, ActiviteAcademiqueFindFirstArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActiviteAcademique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueFindFirstOrThrowArgs} args - Arguments to find a ActiviteAcademique
     * @example
     * // Get one ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActiviteAcademiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, ActiviteAcademiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActiviteAcademiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActiviteAcademiques
     * const activiteAcademiques = await prisma.activiteAcademique.findMany()
     * 
     * // Get first 10 ActiviteAcademiques
     * const activiteAcademiques = await prisma.activiteAcademique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activiteAcademiqueWithIdOnly = await prisma.activiteAcademique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActiviteAcademiqueFindManyArgs>(args?: SelectSubset<T, ActiviteAcademiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActiviteAcademique.
     * @param {ActiviteAcademiqueCreateArgs} args - Arguments to create a ActiviteAcademique.
     * @example
     * // Create one ActiviteAcademique
     * const ActiviteAcademique = await prisma.activiteAcademique.create({
     *   data: {
     *     // ... data to create a ActiviteAcademique
     *   }
     * })
     * 
     */
    create<T extends ActiviteAcademiqueCreateArgs>(args: SelectSubset<T, ActiviteAcademiqueCreateArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActiviteAcademiques.
     * @param {ActiviteAcademiqueCreateManyArgs} args - Arguments to create many ActiviteAcademiques.
     * @example
     * // Create many ActiviteAcademiques
     * const activiteAcademique = await prisma.activiteAcademique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActiviteAcademiqueCreateManyArgs>(args?: SelectSubset<T, ActiviteAcademiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActiviteAcademiques and returns the data saved in the database.
     * @param {ActiviteAcademiqueCreateManyAndReturnArgs} args - Arguments to create many ActiviteAcademiques.
     * @example
     * // Create many ActiviteAcademiques
     * const activiteAcademique = await prisma.activiteAcademique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActiviteAcademiques and only return the `id`
     * const activiteAcademiqueWithIdOnly = await prisma.activiteAcademique.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActiviteAcademiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, ActiviteAcademiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActiviteAcademique.
     * @param {ActiviteAcademiqueDeleteArgs} args - Arguments to delete one ActiviteAcademique.
     * @example
     * // Delete one ActiviteAcademique
     * const ActiviteAcademique = await prisma.activiteAcademique.delete({
     *   where: {
     *     // ... filter to delete one ActiviteAcademique
     *   }
     * })
     * 
     */
    delete<T extends ActiviteAcademiqueDeleteArgs>(args: SelectSubset<T, ActiviteAcademiqueDeleteArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActiviteAcademique.
     * @param {ActiviteAcademiqueUpdateArgs} args - Arguments to update one ActiviteAcademique.
     * @example
     * // Update one ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActiviteAcademiqueUpdateArgs>(args: SelectSubset<T, ActiviteAcademiqueUpdateArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActiviteAcademiques.
     * @param {ActiviteAcademiqueDeleteManyArgs} args - Arguments to filter ActiviteAcademiques to delete.
     * @example
     * // Delete a few ActiviteAcademiques
     * const { count } = await prisma.activiteAcademique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActiviteAcademiqueDeleteManyArgs>(args?: SelectSubset<T, ActiviteAcademiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActiviteAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActiviteAcademiques
     * const activiteAcademique = await prisma.activiteAcademique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActiviteAcademiqueUpdateManyArgs>(args: SelectSubset<T, ActiviteAcademiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActiviteAcademique.
     * @param {ActiviteAcademiqueUpsertArgs} args - Arguments to update or create a ActiviteAcademique.
     * @example
     * // Update or create a ActiviteAcademique
     * const activiteAcademique = await prisma.activiteAcademique.upsert({
     *   create: {
     *     // ... data to create a ActiviteAcademique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActiviteAcademique we want to update
     *   }
     * })
     */
    upsert<T extends ActiviteAcademiqueUpsertArgs>(args: SelectSubset<T, ActiviteAcademiqueUpsertArgs<ExtArgs>>): Prisma__ActiviteAcademiqueClient<$Result.GetResult<Prisma.$ActiviteAcademiquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActiviteAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueCountArgs} args - Arguments to filter ActiviteAcademiques to count.
     * @example
     * // Count the number of ActiviteAcademiques
     * const count = await prisma.activiteAcademique.count({
     *   where: {
     *     // ... the filter for the ActiviteAcademiques we want to count
     *   }
     * })
    **/
    count<T extends ActiviteAcademiqueCountArgs>(
      args?: Subset<T, ActiviteAcademiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActiviteAcademiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActiviteAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActiviteAcademiqueAggregateArgs>(args: Subset<T, ActiviteAcademiqueAggregateArgs>): Prisma.PrismaPromise<GetActiviteAcademiqueAggregateType<T>>

    /**
     * Group by ActiviteAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActiviteAcademiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActiviteAcademiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActiviteAcademiqueGroupByArgs['orderBy'] }
        : { orderBy?: ActiviteAcademiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActiviteAcademiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActiviteAcademiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActiviteAcademique model
   */
  readonly fields: ActiviteAcademiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActiviteAcademique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActiviteAcademiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    periode<T extends PeriodeAcademiqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodeAcademiqueDefaultArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programme<T extends ProgrammeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgrammeDefaultArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActiviteAcademique model
   */ 
  interface ActiviteAcademiqueFieldRefs {
    readonly id: FieldRef<"ActiviteAcademique", 'String'>
    readonly nom: FieldRef<"ActiviteAcademique", 'String'>
    readonly description: FieldRef<"ActiviteAcademique", 'String'>
    readonly datePrevue: FieldRef<"ActiviteAcademique", 'DateTime'>
    readonly dateReelle: FieldRef<"ActiviteAcademique", 'DateTime'>
    readonly type: FieldRef<"ActiviteAcademique", 'String'>
    readonly programmeId: FieldRef<"ActiviteAcademique", 'String'>
    readonly periodeId: FieldRef<"ActiviteAcademique", 'String'>
    readonly createdAt: FieldRef<"ActiviteAcademique", 'DateTime'>
    readonly updatedAt: FieldRef<"ActiviteAcademique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActiviteAcademique findUnique
   */
  export type ActiviteAcademiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which ActiviteAcademique to fetch.
     */
    where: ActiviteAcademiqueWhereUniqueInput
  }

  /**
   * ActiviteAcademique findUniqueOrThrow
   */
  export type ActiviteAcademiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which ActiviteAcademique to fetch.
     */
    where: ActiviteAcademiqueWhereUniqueInput
  }

  /**
   * ActiviteAcademique findFirst
   */
  export type ActiviteAcademiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which ActiviteAcademique to fetch.
     */
    where?: ActiviteAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiviteAcademiques to fetch.
     */
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiviteAcademiques.
     */
    cursor?: ActiviteAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiviteAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiviteAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiviteAcademiques.
     */
    distinct?: ActiviteAcademiqueScalarFieldEnum | ActiviteAcademiqueScalarFieldEnum[]
  }

  /**
   * ActiviteAcademique findFirstOrThrow
   */
  export type ActiviteAcademiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which ActiviteAcademique to fetch.
     */
    where?: ActiviteAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiviteAcademiques to fetch.
     */
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActiviteAcademiques.
     */
    cursor?: ActiviteAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiviteAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiviteAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActiviteAcademiques.
     */
    distinct?: ActiviteAcademiqueScalarFieldEnum | ActiviteAcademiqueScalarFieldEnum[]
  }

  /**
   * ActiviteAcademique findMany
   */
  export type ActiviteAcademiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which ActiviteAcademiques to fetch.
     */
    where?: ActiviteAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActiviteAcademiques to fetch.
     */
    orderBy?: ActiviteAcademiqueOrderByWithRelationInput | ActiviteAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActiviteAcademiques.
     */
    cursor?: ActiviteAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActiviteAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActiviteAcademiques.
     */
    skip?: number
    distinct?: ActiviteAcademiqueScalarFieldEnum | ActiviteAcademiqueScalarFieldEnum[]
  }

  /**
   * ActiviteAcademique create
   */
  export type ActiviteAcademiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a ActiviteAcademique.
     */
    data: XOR<ActiviteAcademiqueCreateInput, ActiviteAcademiqueUncheckedCreateInput>
  }

  /**
   * ActiviteAcademique createMany
   */
  export type ActiviteAcademiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActiviteAcademiques.
     */
    data: ActiviteAcademiqueCreateManyInput | ActiviteAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActiviteAcademique createManyAndReturn
   */
  export type ActiviteAcademiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActiviteAcademiques.
     */
    data: ActiviteAcademiqueCreateManyInput | ActiviteAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActiviteAcademique update
   */
  export type ActiviteAcademiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a ActiviteAcademique.
     */
    data: XOR<ActiviteAcademiqueUpdateInput, ActiviteAcademiqueUncheckedUpdateInput>
    /**
     * Choose, which ActiviteAcademique to update.
     */
    where: ActiviteAcademiqueWhereUniqueInput
  }

  /**
   * ActiviteAcademique updateMany
   */
  export type ActiviteAcademiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActiviteAcademiques.
     */
    data: XOR<ActiviteAcademiqueUpdateManyMutationInput, ActiviteAcademiqueUncheckedUpdateManyInput>
    /**
     * Filter which ActiviteAcademiques to update
     */
    where?: ActiviteAcademiqueWhereInput
  }

  /**
   * ActiviteAcademique upsert
   */
  export type ActiviteAcademiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the ActiviteAcademique to update in case it exists.
     */
    where: ActiviteAcademiqueWhereUniqueInput
    /**
     * In case the ActiviteAcademique found by the `where` argument doesn't exist, create a new ActiviteAcademique with this data.
     */
    create: XOR<ActiviteAcademiqueCreateInput, ActiviteAcademiqueUncheckedCreateInput>
    /**
     * In case the ActiviteAcademique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActiviteAcademiqueUpdateInput, ActiviteAcademiqueUncheckedUpdateInput>
  }

  /**
   * ActiviteAcademique delete
   */
  export type ActiviteAcademiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
    /**
     * Filter which ActiviteAcademique to delete.
     */
    where: ActiviteAcademiqueWhereUniqueInput
  }

  /**
   * ActiviteAcademique deleteMany
   */
  export type ActiviteAcademiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActiviteAcademiques to delete
     */
    where?: ActiviteAcademiqueWhereInput
  }

  /**
   * ActiviteAcademique without action
   */
  export type ActiviteAcademiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActiviteAcademique
     */
    select?: ActiviteAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActiviteAcademiqueInclude<ExtArgs> | null
  }


  /**
   * Model IndicateurAcademique
   */

  export type AggregateIndicateurAcademique = {
    _count: IndicateurAcademiqueCountAggregateOutputType | null
    _avg: IndicateurAcademiqueAvgAggregateOutputType | null
    _sum: IndicateurAcademiqueSumAggregateOutputType | null
    _min: IndicateurAcademiqueMinAggregateOutputType | null
    _max: IndicateurAcademiqueMaxAggregateOutputType | null
  }

  export type IndicateurAcademiqueAvgAggregateOutputType = {
    valeurCible: number | null
    valeurReelle: number | null
  }

  export type IndicateurAcademiqueSumAggregateOutputType = {
    valeurCible: number | null
    valeurReelle: number | null
  }

  export type IndicateurAcademiqueMinAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    valeurCible: number | null
    valeurReelle: number | null
    periodicite: string | null
    methodeCalcul: string | null
    unite: string | null
    type: string | null
    programmeId: string | null
    periodeId: string | null
    responsableId: string | null
    dateCollecte: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicateurAcademiqueMaxAggregateOutputType = {
    id: string | null
    nom: string | null
    description: string | null
    valeurCible: number | null
    valeurReelle: number | null
    periodicite: string | null
    methodeCalcul: string | null
    unite: string | null
    type: string | null
    programmeId: string | null
    periodeId: string | null
    responsableId: string | null
    dateCollecte: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IndicateurAcademiqueCountAggregateOutputType = {
    id: number
    nom: number
    description: number
    valeurCible: number
    valeurReelle: number
    periodicite: number
    methodeCalcul: number
    unite: number
    type: number
    programmeId: number
    periodeId: number
    responsableId: number
    dateCollecte: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IndicateurAcademiqueAvgAggregateInputType = {
    valeurCible?: true
    valeurReelle?: true
  }

  export type IndicateurAcademiqueSumAggregateInputType = {
    valeurCible?: true
    valeurReelle?: true
  }

  export type IndicateurAcademiqueMinAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    valeurCible?: true
    valeurReelle?: true
    periodicite?: true
    methodeCalcul?: true
    unite?: true
    type?: true
    programmeId?: true
    periodeId?: true
    responsableId?: true
    dateCollecte?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicateurAcademiqueMaxAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    valeurCible?: true
    valeurReelle?: true
    periodicite?: true
    methodeCalcul?: true
    unite?: true
    type?: true
    programmeId?: true
    periodeId?: true
    responsableId?: true
    dateCollecte?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IndicateurAcademiqueCountAggregateInputType = {
    id?: true
    nom?: true
    description?: true
    valeurCible?: true
    valeurReelle?: true
    periodicite?: true
    methodeCalcul?: true
    unite?: true
    type?: true
    programmeId?: true
    periodeId?: true
    responsableId?: true
    dateCollecte?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IndicateurAcademiqueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicateurAcademique to aggregate.
     */
    where?: IndicateurAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicateurAcademiques to fetch.
     */
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndicateurAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicateurAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicateurAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IndicateurAcademiques
    **/
    _count?: true | IndicateurAcademiqueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndicateurAcademiqueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndicateurAcademiqueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndicateurAcademiqueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndicateurAcademiqueMaxAggregateInputType
  }

  export type GetIndicateurAcademiqueAggregateType<T extends IndicateurAcademiqueAggregateArgs> = {
        [P in keyof T & keyof AggregateIndicateurAcademique]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndicateurAcademique[P]>
      : GetScalarType<T[P], AggregateIndicateurAcademique[P]>
  }




  export type IndicateurAcademiqueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndicateurAcademiqueWhereInput
    orderBy?: IndicateurAcademiqueOrderByWithAggregationInput | IndicateurAcademiqueOrderByWithAggregationInput[]
    by: IndicateurAcademiqueScalarFieldEnum[] | IndicateurAcademiqueScalarFieldEnum
    having?: IndicateurAcademiqueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndicateurAcademiqueCountAggregateInputType | true
    _avg?: IndicateurAcademiqueAvgAggregateInputType
    _sum?: IndicateurAcademiqueSumAggregateInputType
    _min?: IndicateurAcademiqueMinAggregateInputType
    _max?: IndicateurAcademiqueMaxAggregateInputType
  }

  export type IndicateurAcademiqueGroupByOutputType = {
    id: string
    nom: string
    description: string | null
    valeurCible: number | null
    valeurReelle: number | null
    periodicite: string
    methodeCalcul: string | null
    unite: string
    type: string
    programmeId: string
    periodeId: string
    responsableId: string | null
    dateCollecte: Date | null
    createdAt: Date
    updatedAt: Date
    _count: IndicateurAcademiqueCountAggregateOutputType | null
    _avg: IndicateurAcademiqueAvgAggregateOutputType | null
    _sum: IndicateurAcademiqueSumAggregateOutputType | null
    _min: IndicateurAcademiqueMinAggregateOutputType | null
    _max: IndicateurAcademiqueMaxAggregateOutputType | null
  }

  type GetIndicateurAcademiqueGroupByPayload<T extends IndicateurAcademiqueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndicateurAcademiqueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndicateurAcademiqueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndicateurAcademiqueGroupByOutputType[P]>
            : GetScalarType<T[P], IndicateurAcademiqueGroupByOutputType[P]>
        }
      >
    >


  export type IndicateurAcademiqueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    valeurCible?: boolean
    valeurReelle?: boolean
    periodicite?: boolean
    methodeCalcul?: boolean
    unite?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    responsableId?: boolean
    dateCollecte?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    responsable?: boolean | IndicateurAcademique$responsableArgs<ExtArgs>
  }, ExtArgs["result"]["indicateurAcademique"]>

  export type IndicateurAcademiqueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    description?: boolean
    valeurCible?: boolean
    valeurReelle?: boolean
    periodicite?: boolean
    methodeCalcul?: boolean
    unite?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    responsableId?: boolean
    dateCollecte?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    responsable?: boolean | IndicateurAcademique$responsableArgs<ExtArgs>
  }, ExtArgs["result"]["indicateurAcademique"]>

  export type IndicateurAcademiqueSelectScalar = {
    id?: boolean
    nom?: boolean
    description?: boolean
    valeurCible?: boolean
    valeurReelle?: boolean
    periodicite?: boolean
    methodeCalcul?: boolean
    unite?: boolean
    type?: boolean
    programmeId?: boolean
    periodeId?: boolean
    responsableId?: boolean
    dateCollecte?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IndicateurAcademiqueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    responsable?: boolean | IndicateurAcademique$responsableArgs<ExtArgs>
  }
  export type IndicateurAcademiqueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    periode?: boolean | PeriodeAcademiqueDefaultArgs<ExtArgs>
    programme?: boolean | ProgrammeDefaultArgs<ExtArgs>
    responsable?: boolean | IndicateurAcademique$responsableArgs<ExtArgs>
  }

  export type $IndicateurAcademiquePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IndicateurAcademique"
    objects: {
      periode: Prisma.$PeriodeAcademiquePayload<ExtArgs>
      programme: Prisma.$ProgrammePayload<ExtArgs>
      responsable: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nom: string
      description: string | null
      valeurCible: number | null
      valeurReelle: number | null
      periodicite: string
      methodeCalcul: string | null
      unite: string
      type: string
      programmeId: string
      periodeId: string
      responsableId: string | null
      dateCollecte: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["indicateurAcademique"]>
    composites: {}
  }

  type IndicateurAcademiqueGetPayload<S extends boolean | null | undefined | IndicateurAcademiqueDefaultArgs> = $Result.GetResult<Prisma.$IndicateurAcademiquePayload, S>

  type IndicateurAcademiqueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IndicateurAcademiqueFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IndicateurAcademiqueCountAggregateInputType | true
    }

  export interface IndicateurAcademiqueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IndicateurAcademique'], meta: { name: 'IndicateurAcademique' } }
    /**
     * Find zero or one IndicateurAcademique that matches the filter.
     * @param {IndicateurAcademiqueFindUniqueArgs} args - Arguments to find a IndicateurAcademique
     * @example
     * // Get one IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndicateurAcademiqueFindUniqueArgs>(args: SelectSubset<T, IndicateurAcademiqueFindUniqueArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IndicateurAcademique that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IndicateurAcademiqueFindUniqueOrThrowArgs} args - Arguments to find a IndicateurAcademique
     * @example
     * // Get one IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndicateurAcademiqueFindUniqueOrThrowArgs>(args: SelectSubset<T, IndicateurAcademiqueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IndicateurAcademique that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueFindFirstArgs} args - Arguments to find a IndicateurAcademique
     * @example
     * // Get one IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndicateurAcademiqueFindFirstArgs>(args?: SelectSubset<T, IndicateurAcademiqueFindFirstArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IndicateurAcademique that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueFindFirstOrThrowArgs} args - Arguments to find a IndicateurAcademique
     * @example
     * // Get one IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndicateurAcademiqueFindFirstOrThrowArgs>(args?: SelectSubset<T, IndicateurAcademiqueFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IndicateurAcademiques that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IndicateurAcademiques
     * const indicateurAcademiques = await prisma.indicateurAcademique.findMany()
     * 
     * // Get first 10 IndicateurAcademiques
     * const indicateurAcademiques = await prisma.indicateurAcademique.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const indicateurAcademiqueWithIdOnly = await prisma.indicateurAcademique.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndicateurAcademiqueFindManyArgs>(args?: SelectSubset<T, IndicateurAcademiqueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IndicateurAcademique.
     * @param {IndicateurAcademiqueCreateArgs} args - Arguments to create a IndicateurAcademique.
     * @example
     * // Create one IndicateurAcademique
     * const IndicateurAcademique = await prisma.indicateurAcademique.create({
     *   data: {
     *     // ... data to create a IndicateurAcademique
     *   }
     * })
     * 
     */
    create<T extends IndicateurAcademiqueCreateArgs>(args: SelectSubset<T, IndicateurAcademiqueCreateArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IndicateurAcademiques.
     * @param {IndicateurAcademiqueCreateManyArgs} args - Arguments to create many IndicateurAcademiques.
     * @example
     * // Create many IndicateurAcademiques
     * const indicateurAcademique = await prisma.indicateurAcademique.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndicateurAcademiqueCreateManyArgs>(args?: SelectSubset<T, IndicateurAcademiqueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IndicateurAcademiques and returns the data saved in the database.
     * @param {IndicateurAcademiqueCreateManyAndReturnArgs} args - Arguments to create many IndicateurAcademiques.
     * @example
     * // Create many IndicateurAcademiques
     * const indicateurAcademique = await prisma.indicateurAcademique.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IndicateurAcademiques and only return the `id`
     * const indicateurAcademiqueWithIdOnly = await prisma.indicateurAcademique.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndicateurAcademiqueCreateManyAndReturnArgs>(args?: SelectSubset<T, IndicateurAcademiqueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IndicateurAcademique.
     * @param {IndicateurAcademiqueDeleteArgs} args - Arguments to delete one IndicateurAcademique.
     * @example
     * // Delete one IndicateurAcademique
     * const IndicateurAcademique = await prisma.indicateurAcademique.delete({
     *   where: {
     *     // ... filter to delete one IndicateurAcademique
     *   }
     * })
     * 
     */
    delete<T extends IndicateurAcademiqueDeleteArgs>(args: SelectSubset<T, IndicateurAcademiqueDeleteArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IndicateurAcademique.
     * @param {IndicateurAcademiqueUpdateArgs} args - Arguments to update one IndicateurAcademique.
     * @example
     * // Update one IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndicateurAcademiqueUpdateArgs>(args: SelectSubset<T, IndicateurAcademiqueUpdateArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IndicateurAcademiques.
     * @param {IndicateurAcademiqueDeleteManyArgs} args - Arguments to filter IndicateurAcademiques to delete.
     * @example
     * // Delete a few IndicateurAcademiques
     * const { count } = await prisma.indicateurAcademique.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndicateurAcademiqueDeleteManyArgs>(args?: SelectSubset<T, IndicateurAcademiqueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IndicateurAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IndicateurAcademiques
     * const indicateurAcademique = await prisma.indicateurAcademique.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndicateurAcademiqueUpdateManyArgs>(args: SelectSubset<T, IndicateurAcademiqueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IndicateurAcademique.
     * @param {IndicateurAcademiqueUpsertArgs} args - Arguments to update or create a IndicateurAcademique.
     * @example
     * // Update or create a IndicateurAcademique
     * const indicateurAcademique = await prisma.indicateurAcademique.upsert({
     *   create: {
     *     // ... data to create a IndicateurAcademique
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IndicateurAcademique we want to update
     *   }
     * })
     */
    upsert<T extends IndicateurAcademiqueUpsertArgs>(args: SelectSubset<T, IndicateurAcademiqueUpsertArgs<ExtArgs>>): Prisma__IndicateurAcademiqueClient<$Result.GetResult<Prisma.$IndicateurAcademiquePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IndicateurAcademiques.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueCountArgs} args - Arguments to filter IndicateurAcademiques to count.
     * @example
     * // Count the number of IndicateurAcademiques
     * const count = await prisma.indicateurAcademique.count({
     *   where: {
     *     // ... the filter for the IndicateurAcademiques we want to count
     *   }
     * })
    **/
    count<T extends IndicateurAcademiqueCountArgs>(
      args?: Subset<T, IndicateurAcademiqueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndicateurAcademiqueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IndicateurAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndicateurAcademiqueAggregateArgs>(args: Subset<T, IndicateurAcademiqueAggregateArgs>): Prisma.PrismaPromise<GetIndicateurAcademiqueAggregateType<T>>

    /**
     * Group by IndicateurAcademique.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndicateurAcademiqueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndicateurAcademiqueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndicateurAcademiqueGroupByArgs['orderBy'] }
        : { orderBy?: IndicateurAcademiqueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndicateurAcademiqueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndicateurAcademiqueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IndicateurAcademique model
   */
  readonly fields: IndicateurAcademiqueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IndicateurAcademique.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndicateurAcademiqueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    periode<T extends PeriodeAcademiqueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PeriodeAcademiqueDefaultArgs<ExtArgs>>): Prisma__PeriodeAcademiqueClient<$Result.GetResult<Prisma.$PeriodeAcademiquePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programme<T extends ProgrammeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgrammeDefaultArgs<ExtArgs>>): Prisma__ProgrammeClient<$Result.GetResult<Prisma.$ProgrammePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responsable<T extends IndicateurAcademique$responsableArgs<ExtArgs> = {}>(args?: Subset<T, IndicateurAcademique$responsableArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IndicateurAcademique model
   */ 
  interface IndicateurAcademiqueFieldRefs {
    readonly id: FieldRef<"IndicateurAcademique", 'String'>
    readonly nom: FieldRef<"IndicateurAcademique", 'String'>
    readonly description: FieldRef<"IndicateurAcademique", 'String'>
    readonly valeurCible: FieldRef<"IndicateurAcademique", 'Float'>
    readonly valeurReelle: FieldRef<"IndicateurAcademique", 'Float'>
    readonly periodicite: FieldRef<"IndicateurAcademique", 'String'>
    readonly methodeCalcul: FieldRef<"IndicateurAcademique", 'String'>
    readonly unite: FieldRef<"IndicateurAcademique", 'String'>
    readonly type: FieldRef<"IndicateurAcademique", 'String'>
    readonly programmeId: FieldRef<"IndicateurAcademique", 'String'>
    readonly periodeId: FieldRef<"IndicateurAcademique", 'String'>
    readonly responsableId: FieldRef<"IndicateurAcademique", 'String'>
    readonly dateCollecte: FieldRef<"IndicateurAcademique", 'DateTime'>
    readonly createdAt: FieldRef<"IndicateurAcademique", 'DateTime'>
    readonly updatedAt: FieldRef<"IndicateurAcademique", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IndicateurAcademique findUnique
   */
  export type IndicateurAcademiqueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which IndicateurAcademique to fetch.
     */
    where: IndicateurAcademiqueWhereUniqueInput
  }

  /**
   * IndicateurAcademique findUniqueOrThrow
   */
  export type IndicateurAcademiqueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which IndicateurAcademique to fetch.
     */
    where: IndicateurAcademiqueWhereUniqueInput
  }

  /**
   * IndicateurAcademique findFirst
   */
  export type IndicateurAcademiqueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which IndicateurAcademique to fetch.
     */
    where?: IndicateurAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicateurAcademiques to fetch.
     */
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicateurAcademiques.
     */
    cursor?: IndicateurAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicateurAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicateurAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicateurAcademiques.
     */
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * IndicateurAcademique findFirstOrThrow
   */
  export type IndicateurAcademiqueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which IndicateurAcademique to fetch.
     */
    where?: IndicateurAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicateurAcademiques to fetch.
     */
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IndicateurAcademiques.
     */
    cursor?: IndicateurAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicateurAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicateurAcademiques.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IndicateurAcademiques.
     */
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * IndicateurAcademique findMany
   */
  export type IndicateurAcademiqueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter, which IndicateurAcademiques to fetch.
     */
    where?: IndicateurAcademiqueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IndicateurAcademiques to fetch.
     */
    orderBy?: IndicateurAcademiqueOrderByWithRelationInput | IndicateurAcademiqueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IndicateurAcademiques.
     */
    cursor?: IndicateurAcademiqueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IndicateurAcademiques from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IndicateurAcademiques.
     */
    skip?: number
    distinct?: IndicateurAcademiqueScalarFieldEnum | IndicateurAcademiqueScalarFieldEnum[]
  }

  /**
   * IndicateurAcademique create
   */
  export type IndicateurAcademiqueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to create a IndicateurAcademique.
     */
    data: XOR<IndicateurAcademiqueCreateInput, IndicateurAcademiqueUncheckedCreateInput>
  }

  /**
   * IndicateurAcademique createMany
   */
  export type IndicateurAcademiqueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IndicateurAcademiques.
     */
    data: IndicateurAcademiqueCreateManyInput | IndicateurAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IndicateurAcademique createManyAndReturn
   */
  export type IndicateurAcademiqueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IndicateurAcademiques.
     */
    data: IndicateurAcademiqueCreateManyInput | IndicateurAcademiqueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * IndicateurAcademique update
   */
  export type IndicateurAcademiqueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * The data needed to update a IndicateurAcademique.
     */
    data: XOR<IndicateurAcademiqueUpdateInput, IndicateurAcademiqueUncheckedUpdateInput>
    /**
     * Choose, which IndicateurAcademique to update.
     */
    where: IndicateurAcademiqueWhereUniqueInput
  }

  /**
   * IndicateurAcademique updateMany
   */
  export type IndicateurAcademiqueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IndicateurAcademiques.
     */
    data: XOR<IndicateurAcademiqueUpdateManyMutationInput, IndicateurAcademiqueUncheckedUpdateManyInput>
    /**
     * Filter which IndicateurAcademiques to update
     */
    where?: IndicateurAcademiqueWhereInput
  }

  /**
   * IndicateurAcademique upsert
   */
  export type IndicateurAcademiqueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * The filter to search for the IndicateurAcademique to update in case it exists.
     */
    where: IndicateurAcademiqueWhereUniqueInput
    /**
     * In case the IndicateurAcademique found by the `where` argument doesn't exist, create a new IndicateurAcademique with this data.
     */
    create: XOR<IndicateurAcademiqueCreateInput, IndicateurAcademiqueUncheckedCreateInput>
    /**
     * In case the IndicateurAcademique was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndicateurAcademiqueUpdateInput, IndicateurAcademiqueUncheckedUpdateInput>
  }

  /**
   * IndicateurAcademique delete
   */
  export type IndicateurAcademiqueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
    /**
     * Filter which IndicateurAcademique to delete.
     */
    where: IndicateurAcademiqueWhereUniqueInput
  }

  /**
   * IndicateurAcademique deleteMany
   */
  export type IndicateurAcademiqueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IndicateurAcademiques to delete
     */
    where?: IndicateurAcademiqueWhereInput
  }

  /**
   * IndicateurAcademique.responsable
   */
  export type IndicateurAcademique$responsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * IndicateurAcademique without action
   */
  export type IndicateurAcademiqueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndicateurAcademique
     */
    select?: IndicateurAcademiqueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndicateurAcademiqueInclude<ExtArgs> | null
  }


  /**
   * Model ResultatEtudiant
   */

  export type AggregateResultatEtudiant = {
    _count: ResultatEtudiantCountAggregateOutputType | null
    _avg: ResultatEtudiantAvgAggregateOutputType | null
    _sum: ResultatEtudiantSumAggregateOutputType | null
    _min: ResultatEtudiantMinAggregateOutputType | null
    _max: ResultatEtudiantMaxAggregateOutputType | null
  }

  export type ResultatEtudiantAvgAggregateOutputType = {
    noteCC: number | null
    noteExamen: number | null
    noteFinale: number | null
    vhDeroule: number | null
    progressionPct: number | null
    presences: number | null
    absences: number | null
    tauxPresence: number | null
  }

  export type ResultatEtudiantSumAggregateOutputType = {
    noteCC: number | null
    noteExamen: number | null
    noteFinale: number | null
    vhDeroule: number | null
    progressionPct: number | null
    presences: number | null
    absences: number | null
    tauxPresence: number | null
  }

  export type ResultatEtudiantMinAggregateOutputType = {
    id: string | null
    numeroEtudiant: string | null
    nomEtudiant: string | null
    prenomEtudiant: string | null
    emailEtudiant: string | null
    moduleId: string | null
    noteCC: number | null
    noteExamen: number | null
    noteFinale: number | null
    statut: string | null
    mention: string | null
    vhDeroule: number | null
    progressionPct: number | null
    presences: number | null
    absences: number | null
    tauxPresence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultatEtudiantMaxAggregateOutputType = {
    id: string | null
    numeroEtudiant: string | null
    nomEtudiant: string | null
    prenomEtudiant: string | null
    emailEtudiant: string | null
    moduleId: string | null
    noteCC: number | null
    noteExamen: number | null
    noteFinale: number | null
    statut: string | null
    mention: string | null
    vhDeroule: number | null
    progressionPct: number | null
    presences: number | null
    absences: number | null
    tauxPresence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResultatEtudiantCountAggregateOutputType = {
    id: number
    numeroEtudiant: number
    nomEtudiant: number
    prenomEtudiant: number
    emailEtudiant: number
    moduleId: number
    noteCC: number
    noteExamen: number
    noteFinale: number
    statut: number
    mention: number
    vhDeroule: number
    progressionPct: number
    presences: number
    absences: number
    tauxPresence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResultatEtudiantAvgAggregateInputType = {
    noteCC?: true
    noteExamen?: true
    noteFinale?: true
    vhDeroule?: true
    progressionPct?: true
    presences?: true
    absences?: true
    tauxPresence?: true
  }

  export type ResultatEtudiantSumAggregateInputType = {
    noteCC?: true
    noteExamen?: true
    noteFinale?: true
    vhDeroule?: true
    progressionPct?: true
    presences?: true
    absences?: true
    tauxPresence?: true
  }

  export type ResultatEtudiantMinAggregateInputType = {
    id?: true
    numeroEtudiant?: true
    nomEtudiant?: true
    prenomEtudiant?: true
    emailEtudiant?: true
    moduleId?: true
    noteCC?: true
    noteExamen?: true
    noteFinale?: true
    statut?: true
    mention?: true
    vhDeroule?: true
    progressionPct?: true
    presences?: true
    absences?: true
    tauxPresence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultatEtudiantMaxAggregateInputType = {
    id?: true
    numeroEtudiant?: true
    nomEtudiant?: true
    prenomEtudiant?: true
    emailEtudiant?: true
    moduleId?: true
    noteCC?: true
    noteExamen?: true
    noteFinale?: true
    statut?: true
    mention?: true
    vhDeroule?: true
    progressionPct?: true
    presences?: true
    absences?: true
    tauxPresence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResultatEtudiantCountAggregateInputType = {
    id?: true
    numeroEtudiant?: true
    nomEtudiant?: true
    prenomEtudiant?: true
    emailEtudiant?: true
    moduleId?: true
    noteCC?: true
    noteExamen?: true
    noteFinale?: true
    statut?: true
    mention?: true
    vhDeroule?: true
    progressionPct?: true
    presences?: true
    absences?: true
    tauxPresence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResultatEtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultatEtudiant to aggregate.
     */
    where?: ResultatEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatEtudiants to fetch.
     */
    orderBy?: ResultatEtudiantOrderByWithRelationInput | ResultatEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResultatEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResultatEtudiants
    **/
    _count?: true | ResultatEtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResultatEtudiantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResultatEtudiantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResultatEtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResultatEtudiantMaxAggregateInputType
  }

  export type GetResultatEtudiantAggregateType<T extends ResultatEtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateResultatEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResultatEtudiant[P]>
      : GetScalarType<T[P], AggregateResultatEtudiant[P]>
  }




  export type ResultatEtudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResultatEtudiantWhereInput
    orderBy?: ResultatEtudiantOrderByWithAggregationInput | ResultatEtudiantOrderByWithAggregationInput[]
    by: ResultatEtudiantScalarFieldEnum[] | ResultatEtudiantScalarFieldEnum
    having?: ResultatEtudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResultatEtudiantCountAggregateInputType | true
    _avg?: ResultatEtudiantAvgAggregateInputType
    _sum?: ResultatEtudiantSumAggregateInputType
    _min?: ResultatEtudiantMinAggregateInputType
    _max?: ResultatEtudiantMaxAggregateInputType
  }

  export type ResultatEtudiantGroupByOutputType = {
    id: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant: string | null
    moduleId: string
    noteCC: number | null
    noteExamen: number | null
    noteFinale: number | null
    statut: string
    mention: string | null
    vhDeroule: number
    progressionPct: number
    presences: number
    absences: number
    tauxPresence: number | null
    createdAt: Date
    updatedAt: Date
    _count: ResultatEtudiantCountAggregateOutputType | null
    _avg: ResultatEtudiantAvgAggregateOutputType | null
    _sum: ResultatEtudiantSumAggregateOutputType | null
    _min: ResultatEtudiantMinAggregateOutputType | null
    _max: ResultatEtudiantMaxAggregateOutputType | null
  }

  type GetResultatEtudiantGroupByPayload<T extends ResultatEtudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResultatEtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResultatEtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResultatEtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], ResultatEtudiantGroupByOutputType[P]>
        }
      >
    >


  export type ResultatEtudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEtudiant?: boolean
    nomEtudiant?: boolean
    prenomEtudiant?: boolean
    emailEtudiant?: boolean
    moduleId?: boolean
    noteCC?: boolean
    noteExamen?: boolean
    noteFinale?: boolean
    statut?: boolean
    mention?: boolean
    vhDeroule?: boolean
    progressionPct?: boolean
    presences?: boolean
    absences?: boolean
    tauxPresence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultatEtudiant"]>

  export type ResultatEtudiantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numeroEtudiant?: boolean
    nomEtudiant?: boolean
    prenomEtudiant?: boolean
    emailEtudiant?: boolean
    moduleId?: boolean
    noteCC?: boolean
    noteExamen?: boolean
    noteFinale?: boolean
    statut?: boolean
    mention?: boolean
    vhDeroule?: boolean
    progressionPct?: boolean
    presences?: boolean
    absences?: boolean
    tauxPresence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resultatEtudiant"]>

  export type ResultatEtudiantSelectScalar = {
    id?: boolean
    numeroEtudiant?: boolean
    nomEtudiant?: boolean
    prenomEtudiant?: boolean
    emailEtudiant?: boolean
    moduleId?: boolean
    noteCC?: boolean
    noteExamen?: boolean
    noteFinale?: boolean
    statut?: boolean
    mention?: boolean
    vhDeroule?: boolean
    progressionPct?: boolean
    presences?: boolean
    absences?: boolean
    tauxPresence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResultatEtudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ResultatEtudiantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ResultatEtudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResultatEtudiant"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      numeroEtudiant: string
      nomEtudiant: string
      prenomEtudiant: string
      emailEtudiant: string | null
      moduleId: string
      noteCC: number | null
      noteExamen: number | null
      noteFinale: number | null
      statut: string
      mention: string | null
      vhDeroule: number
      progressionPct: number
      presences: number
      absences: number
      tauxPresence: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resultatEtudiant"]>
    composites: {}
  }

  type ResultatEtudiantGetPayload<S extends boolean | null | undefined | ResultatEtudiantDefaultArgs> = $Result.GetResult<Prisma.$ResultatEtudiantPayload, S>

  type ResultatEtudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResultatEtudiantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResultatEtudiantCountAggregateInputType | true
    }

  export interface ResultatEtudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResultatEtudiant'], meta: { name: 'ResultatEtudiant' } }
    /**
     * Find zero or one ResultatEtudiant that matches the filter.
     * @param {ResultatEtudiantFindUniqueArgs} args - Arguments to find a ResultatEtudiant
     * @example
     * // Get one ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResultatEtudiantFindUniqueArgs>(args: SelectSubset<T, ResultatEtudiantFindUniqueArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ResultatEtudiant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResultatEtudiantFindUniqueOrThrowArgs} args - Arguments to find a ResultatEtudiant
     * @example
     * // Get one ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResultatEtudiantFindUniqueOrThrowArgs>(args: SelectSubset<T, ResultatEtudiantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ResultatEtudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantFindFirstArgs} args - Arguments to find a ResultatEtudiant
     * @example
     * // Get one ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResultatEtudiantFindFirstArgs>(args?: SelectSubset<T, ResultatEtudiantFindFirstArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ResultatEtudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantFindFirstOrThrowArgs} args - Arguments to find a ResultatEtudiant
     * @example
     * // Get one ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResultatEtudiantFindFirstOrThrowArgs>(args?: SelectSubset<T, ResultatEtudiantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ResultatEtudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResultatEtudiants
     * const resultatEtudiants = await prisma.resultatEtudiant.findMany()
     * 
     * // Get first 10 ResultatEtudiants
     * const resultatEtudiants = await prisma.resultatEtudiant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resultatEtudiantWithIdOnly = await prisma.resultatEtudiant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResultatEtudiantFindManyArgs>(args?: SelectSubset<T, ResultatEtudiantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ResultatEtudiant.
     * @param {ResultatEtudiantCreateArgs} args - Arguments to create a ResultatEtudiant.
     * @example
     * // Create one ResultatEtudiant
     * const ResultatEtudiant = await prisma.resultatEtudiant.create({
     *   data: {
     *     // ... data to create a ResultatEtudiant
     *   }
     * })
     * 
     */
    create<T extends ResultatEtudiantCreateArgs>(args: SelectSubset<T, ResultatEtudiantCreateArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ResultatEtudiants.
     * @param {ResultatEtudiantCreateManyArgs} args - Arguments to create many ResultatEtudiants.
     * @example
     * // Create many ResultatEtudiants
     * const resultatEtudiant = await prisma.resultatEtudiant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResultatEtudiantCreateManyArgs>(args?: SelectSubset<T, ResultatEtudiantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResultatEtudiants and returns the data saved in the database.
     * @param {ResultatEtudiantCreateManyAndReturnArgs} args - Arguments to create many ResultatEtudiants.
     * @example
     * // Create many ResultatEtudiants
     * const resultatEtudiant = await prisma.resultatEtudiant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResultatEtudiants and only return the `id`
     * const resultatEtudiantWithIdOnly = await prisma.resultatEtudiant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResultatEtudiantCreateManyAndReturnArgs>(args?: SelectSubset<T, ResultatEtudiantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ResultatEtudiant.
     * @param {ResultatEtudiantDeleteArgs} args - Arguments to delete one ResultatEtudiant.
     * @example
     * // Delete one ResultatEtudiant
     * const ResultatEtudiant = await prisma.resultatEtudiant.delete({
     *   where: {
     *     // ... filter to delete one ResultatEtudiant
     *   }
     * })
     * 
     */
    delete<T extends ResultatEtudiantDeleteArgs>(args: SelectSubset<T, ResultatEtudiantDeleteArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ResultatEtudiant.
     * @param {ResultatEtudiantUpdateArgs} args - Arguments to update one ResultatEtudiant.
     * @example
     * // Update one ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResultatEtudiantUpdateArgs>(args: SelectSubset<T, ResultatEtudiantUpdateArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ResultatEtudiants.
     * @param {ResultatEtudiantDeleteManyArgs} args - Arguments to filter ResultatEtudiants to delete.
     * @example
     * // Delete a few ResultatEtudiants
     * const { count } = await prisma.resultatEtudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResultatEtudiantDeleteManyArgs>(args?: SelectSubset<T, ResultatEtudiantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResultatEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResultatEtudiants
     * const resultatEtudiant = await prisma.resultatEtudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResultatEtudiantUpdateManyArgs>(args: SelectSubset<T, ResultatEtudiantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ResultatEtudiant.
     * @param {ResultatEtudiantUpsertArgs} args - Arguments to update or create a ResultatEtudiant.
     * @example
     * // Update or create a ResultatEtudiant
     * const resultatEtudiant = await prisma.resultatEtudiant.upsert({
     *   create: {
     *     // ... data to create a ResultatEtudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResultatEtudiant we want to update
     *   }
     * })
     */
    upsert<T extends ResultatEtudiantUpsertArgs>(args: SelectSubset<T, ResultatEtudiantUpsertArgs<ExtArgs>>): Prisma__ResultatEtudiantClient<$Result.GetResult<Prisma.$ResultatEtudiantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ResultatEtudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantCountArgs} args - Arguments to filter ResultatEtudiants to count.
     * @example
     * // Count the number of ResultatEtudiants
     * const count = await prisma.resultatEtudiant.count({
     *   where: {
     *     // ... the filter for the ResultatEtudiants we want to count
     *   }
     * })
    **/
    count<T extends ResultatEtudiantCountArgs>(
      args?: Subset<T, ResultatEtudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResultatEtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResultatEtudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResultatEtudiantAggregateArgs>(args: Subset<T, ResultatEtudiantAggregateArgs>): Prisma.PrismaPromise<GetResultatEtudiantAggregateType<T>>

    /**
     * Group by ResultatEtudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResultatEtudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResultatEtudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResultatEtudiantGroupByArgs['orderBy'] }
        : { orderBy?: ResultatEtudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResultatEtudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResultatEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResultatEtudiant model
   */
  readonly fields: ResultatEtudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResultatEtudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResultatEtudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResultatEtudiant model
   */ 
  interface ResultatEtudiantFieldRefs {
    readonly id: FieldRef<"ResultatEtudiant", 'String'>
    readonly numeroEtudiant: FieldRef<"ResultatEtudiant", 'String'>
    readonly nomEtudiant: FieldRef<"ResultatEtudiant", 'String'>
    readonly prenomEtudiant: FieldRef<"ResultatEtudiant", 'String'>
    readonly emailEtudiant: FieldRef<"ResultatEtudiant", 'String'>
    readonly moduleId: FieldRef<"ResultatEtudiant", 'String'>
    readonly noteCC: FieldRef<"ResultatEtudiant", 'Float'>
    readonly noteExamen: FieldRef<"ResultatEtudiant", 'Float'>
    readonly noteFinale: FieldRef<"ResultatEtudiant", 'Float'>
    readonly statut: FieldRef<"ResultatEtudiant", 'String'>
    readonly mention: FieldRef<"ResultatEtudiant", 'String'>
    readonly vhDeroule: FieldRef<"ResultatEtudiant", 'Int'>
    readonly progressionPct: FieldRef<"ResultatEtudiant", 'Int'>
    readonly presences: FieldRef<"ResultatEtudiant", 'Int'>
    readonly absences: FieldRef<"ResultatEtudiant", 'Int'>
    readonly tauxPresence: FieldRef<"ResultatEtudiant", 'Float'>
    readonly createdAt: FieldRef<"ResultatEtudiant", 'DateTime'>
    readonly updatedAt: FieldRef<"ResultatEtudiant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResultatEtudiant findUnique
   */
  export type ResultatEtudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which ResultatEtudiant to fetch.
     */
    where: ResultatEtudiantWhereUniqueInput
  }

  /**
   * ResultatEtudiant findUniqueOrThrow
   */
  export type ResultatEtudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which ResultatEtudiant to fetch.
     */
    where: ResultatEtudiantWhereUniqueInput
  }

  /**
   * ResultatEtudiant findFirst
   */
  export type ResultatEtudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which ResultatEtudiant to fetch.
     */
    where?: ResultatEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatEtudiants to fetch.
     */
    orderBy?: ResultatEtudiantOrderByWithRelationInput | ResultatEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultatEtudiants.
     */
    cursor?: ResultatEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultatEtudiants.
     */
    distinct?: ResultatEtudiantScalarFieldEnum | ResultatEtudiantScalarFieldEnum[]
  }

  /**
   * ResultatEtudiant findFirstOrThrow
   */
  export type ResultatEtudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which ResultatEtudiant to fetch.
     */
    where?: ResultatEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatEtudiants to fetch.
     */
    orderBy?: ResultatEtudiantOrderByWithRelationInput | ResultatEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResultatEtudiants.
     */
    cursor?: ResultatEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatEtudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResultatEtudiants.
     */
    distinct?: ResultatEtudiantScalarFieldEnum | ResultatEtudiantScalarFieldEnum[]
  }

  /**
   * ResultatEtudiant findMany
   */
  export type ResultatEtudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter, which ResultatEtudiants to fetch.
     */
    where?: ResultatEtudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResultatEtudiants to fetch.
     */
    orderBy?: ResultatEtudiantOrderByWithRelationInput | ResultatEtudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResultatEtudiants.
     */
    cursor?: ResultatEtudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResultatEtudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResultatEtudiants.
     */
    skip?: number
    distinct?: ResultatEtudiantScalarFieldEnum | ResultatEtudiantScalarFieldEnum[]
  }

  /**
   * ResultatEtudiant create
   */
  export type ResultatEtudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a ResultatEtudiant.
     */
    data: XOR<ResultatEtudiantCreateInput, ResultatEtudiantUncheckedCreateInput>
  }

  /**
   * ResultatEtudiant createMany
   */
  export type ResultatEtudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResultatEtudiants.
     */
    data: ResultatEtudiantCreateManyInput | ResultatEtudiantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResultatEtudiant createManyAndReturn
   */
  export type ResultatEtudiantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ResultatEtudiants.
     */
    data: ResultatEtudiantCreateManyInput | ResultatEtudiantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResultatEtudiant update
   */
  export type ResultatEtudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a ResultatEtudiant.
     */
    data: XOR<ResultatEtudiantUpdateInput, ResultatEtudiantUncheckedUpdateInput>
    /**
     * Choose, which ResultatEtudiant to update.
     */
    where: ResultatEtudiantWhereUniqueInput
  }

  /**
   * ResultatEtudiant updateMany
   */
  export type ResultatEtudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResultatEtudiants.
     */
    data: XOR<ResultatEtudiantUpdateManyMutationInput, ResultatEtudiantUncheckedUpdateManyInput>
    /**
     * Filter which ResultatEtudiants to update
     */
    where?: ResultatEtudiantWhereInput
  }

  /**
   * ResultatEtudiant upsert
   */
  export type ResultatEtudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the ResultatEtudiant to update in case it exists.
     */
    where: ResultatEtudiantWhereUniqueInput
    /**
     * In case the ResultatEtudiant found by the `where` argument doesn't exist, create a new ResultatEtudiant with this data.
     */
    create: XOR<ResultatEtudiantCreateInput, ResultatEtudiantUncheckedCreateInput>
    /**
     * In case the ResultatEtudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResultatEtudiantUpdateInput, ResultatEtudiantUncheckedUpdateInput>
  }

  /**
   * ResultatEtudiant delete
   */
  export type ResultatEtudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
    /**
     * Filter which ResultatEtudiant to delete.
     */
    where: ResultatEtudiantWhereUniqueInput
  }

  /**
   * ResultatEtudiant deleteMany
   */
  export type ResultatEtudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResultatEtudiants to delete
     */
    where?: ResultatEtudiantWhereInput
  }

  /**
   * ResultatEtudiant without action
   */
  export type ResultatEtudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResultatEtudiant
     */
    select?: ResultatEtudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResultatEtudiantInclude<ExtArgs> | null
  }


  /**
   * Model EvaluationEnseignement
   */

  export type AggregateEvaluationEnseignement = {
    _count: EvaluationEnseignementCountAggregateOutputType | null
    _avg: EvaluationEnseignementAvgAggregateOutputType | null
    _sum: EvaluationEnseignementSumAggregateOutputType | null
    _min: EvaluationEnseignementMinAggregateOutputType | null
    _max: EvaluationEnseignementMaxAggregateOutputType | null
  }

  export type EvaluationEnseignementAvgAggregateOutputType = {
    noteQualiteCours: number | null
    noteQualitePedagogie: number | null
    noteDisponibilite: number | null
    noteMoyenne: number | null
    nombreReponses: number | null
    nombreInvitations: number | null
    tauxParticipation: number | null
  }

  export type EvaluationEnseignementSumAggregateOutputType = {
    noteQualiteCours: number | null
    noteQualitePedagogie: number | null
    noteDisponibilite: number | null
    noteMoyenne: number | null
    nombreReponses: number | null
    nombreInvitations: number | null
    tauxParticipation: number | null
  }

  export type EvaluationEnseignementMinAggregateOutputType = {
    id: string | null
    moduleId: string | null
    intervenantId: string | null
    dateEnvoi: Date | null
    dateDebut: Date | null
    dateFin: Date | null
    lienEvaluation: string | null
    noteQualiteCours: number | null
    noteQualitePedagogie: number | null
    noteDisponibilite: number | null
    noteMoyenne: number | null
    nombreReponses: number | null
    nombreInvitations: number | null
    tauxParticipation: number | null
    commentaires: string | null
    statut: $Enums.StatutCampagne | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationEnseignementMaxAggregateOutputType = {
    id: string | null
    moduleId: string | null
    intervenantId: string | null
    dateEnvoi: Date | null
    dateDebut: Date | null
    dateFin: Date | null
    lienEvaluation: string | null
    noteQualiteCours: number | null
    noteQualitePedagogie: number | null
    noteDisponibilite: number | null
    noteMoyenne: number | null
    nombreReponses: number | null
    nombreInvitations: number | null
    tauxParticipation: number | null
    commentaires: string | null
    statut: $Enums.StatutCampagne | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvaluationEnseignementCountAggregateOutputType = {
    id: number
    moduleId: number
    intervenantId: number
    dateEnvoi: number
    dateDebut: number
    dateFin: number
    lienEvaluation: number
    noteQualiteCours: number
    noteQualitePedagogie: number
    noteDisponibilite: number
    noteMoyenne: number
    nombreReponses: number
    nombreInvitations: number
    tauxParticipation: number
    commentaires: number
    statut: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvaluationEnseignementAvgAggregateInputType = {
    noteQualiteCours?: true
    noteQualitePedagogie?: true
    noteDisponibilite?: true
    noteMoyenne?: true
    nombreReponses?: true
    nombreInvitations?: true
    tauxParticipation?: true
  }

  export type EvaluationEnseignementSumAggregateInputType = {
    noteQualiteCours?: true
    noteQualitePedagogie?: true
    noteDisponibilite?: true
    noteMoyenne?: true
    nombreReponses?: true
    nombreInvitations?: true
    tauxParticipation?: true
  }

  export type EvaluationEnseignementMinAggregateInputType = {
    id?: true
    moduleId?: true
    intervenantId?: true
    dateEnvoi?: true
    dateDebut?: true
    dateFin?: true
    lienEvaluation?: true
    noteQualiteCours?: true
    noteQualitePedagogie?: true
    noteDisponibilite?: true
    noteMoyenne?: true
    nombreReponses?: true
    nombreInvitations?: true
    tauxParticipation?: true
    commentaires?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationEnseignementMaxAggregateInputType = {
    id?: true
    moduleId?: true
    intervenantId?: true
    dateEnvoi?: true
    dateDebut?: true
    dateFin?: true
    lienEvaluation?: true
    noteQualiteCours?: true
    noteQualitePedagogie?: true
    noteDisponibilite?: true
    noteMoyenne?: true
    nombreReponses?: true
    nombreInvitations?: true
    tauxParticipation?: true
    commentaires?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvaluationEnseignementCountAggregateInputType = {
    id?: true
    moduleId?: true
    intervenantId?: true
    dateEnvoi?: true
    dateDebut?: true
    dateFin?: true
    lienEvaluation?: true
    noteQualiteCours?: true
    noteQualitePedagogie?: true
    noteDisponibilite?: true
    noteMoyenne?: true
    nombreReponses?: true
    nombreInvitations?: true
    tauxParticipation?: true
    commentaires?: true
    statut?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvaluationEnseignementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationEnseignement to aggregate.
     */
    where?: EvaluationEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEnseignements to fetch.
     */
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EvaluationEnseignements
    **/
    _count?: true | EvaluationEnseignementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationEnseignementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationEnseignementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationEnseignementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationEnseignementMaxAggregateInputType
  }

  export type GetEvaluationEnseignementAggregateType<T extends EvaluationEnseignementAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluationEnseignement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluationEnseignement[P]>
      : GetScalarType<T[P], AggregateEvaluationEnseignement[P]>
  }




  export type EvaluationEnseignementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationEnseignementWhereInput
    orderBy?: EvaluationEnseignementOrderByWithAggregationInput | EvaluationEnseignementOrderByWithAggregationInput[]
    by: EvaluationEnseignementScalarFieldEnum[] | EvaluationEnseignementScalarFieldEnum
    having?: EvaluationEnseignementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationEnseignementCountAggregateInputType | true
    _avg?: EvaluationEnseignementAvgAggregateInputType
    _sum?: EvaluationEnseignementSumAggregateInputType
    _min?: EvaluationEnseignementMinAggregateInputType
    _max?: EvaluationEnseignementMaxAggregateInputType
  }

  export type EvaluationEnseignementGroupByOutputType = {
    id: string
    moduleId: string
    intervenantId: string
    dateEnvoi: Date | null
    dateDebut: Date | null
    dateFin: Date | null
    lienEvaluation: string | null
    noteQualiteCours: number | null
    noteQualitePedagogie: number | null
    noteDisponibilite: number | null
    noteMoyenne: number | null
    nombreReponses: number
    nombreInvitations: number
    tauxParticipation: number | null
    commentaires: string | null
    statut: $Enums.StatutCampagne
    createdAt: Date
    updatedAt: Date
    _count: EvaluationEnseignementCountAggregateOutputType | null
    _avg: EvaluationEnseignementAvgAggregateOutputType | null
    _sum: EvaluationEnseignementSumAggregateOutputType | null
    _min: EvaluationEnseignementMinAggregateOutputType | null
    _max: EvaluationEnseignementMaxAggregateOutputType | null
  }

  type GetEvaluationEnseignementGroupByPayload<T extends EvaluationEnseignementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationEnseignementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationEnseignementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationEnseignementGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationEnseignementGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationEnseignementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    dateEnvoi?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lienEvaluation?: boolean
    noteQualiteCours?: boolean
    noteQualitePedagogie?: boolean
    noteDisponibilite?: boolean
    noteMoyenne?: boolean
    nombreReponses?: boolean
    nombreInvitations?: boolean
    tauxParticipation?: boolean
    commentaires?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationEnseignement"]>

  export type EvaluationEnseignementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    dateEnvoi?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lienEvaluation?: boolean
    noteQualiteCours?: boolean
    noteQualitePedagogie?: boolean
    noteDisponibilite?: boolean
    noteMoyenne?: boolean
    nombreReponses?: boolean
    nombreInvitations?: boolean
    tauxParticipation?: boolean
    commentaires?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluationEnseignement"]>

  export type EvaluationEnseignementSelectScalar = {
    id?: boolean
    moduleId?: boolean
    intervenantId?: boolean
    dateEnvoi?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    lienEvaluation?: boolean
    noteQualiteCours?: boolean
    noteQualitePedagogie?: boolean
    noteDisponibilite?: boolean
    noteMoyenne?: boolean
    nombreReponses?: boolean
    nombreInvitations?: boolean
    tauxParticipation?: boolean
    commentaires?: boolean
    statut?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvaluationEnseignementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type EvaluationEnseignementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    intervenant?: boolean | IntervenantDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $EvaluationEnseignementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvaluationEnseignement"
    objects: {
      intervenant: Prisma.$IntervenantPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      moduleId: string
      intervenantId: string
      dateEnvoi: Date | null
      dateDebut: Date | null
      dateFin: Date | null
      lienEvaluation: string | null
      noteQualiteCours: number | null
      noteQualitePedagogie: number | null
      noteDisponibilite: number | null
      noteMoyenne: number | null
      nombreReponses: number
      nombreInvitations: number
      tauxParticipation: number | null
      commentaires: string | null
      statut: $Enums.StatutCampagne
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evaluationEnseignement"]>
    composites: {}
  }

  type EvaluationEnseignementGetPayload<S extends boolean | null | undefined | EvaluationEnseignementDefaultArgs> = $Result.GetResult<Prisma.$EvaluationEnseignementPayload, S>

  type EvaluationEnseignementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationEnseignementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EvaluationEnseignementCountAggregateInputType | true
    }

  export interface EvaluationEnseignementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvaluationEnseignement'], meta: { name: 'EvaluationEnseignement' } }
    /**
     * Find zero or one EvaluationEnseignement that matches the filter.
     * @param {EvaluationEnseignementFindUniqueArgs} args - Arguments to find a EvaluationEnseignement
     * @example
     * // Get one EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluationEnseignementFindUniqueArgs>(args: SelectSubset<T, EvaluationEnseignementFindUniqueArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EvaluationEnseignement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EvaluationEnseignementFindUniqueOrThrowArgs} args - Arguments to find a EvaluationEnseignement
     * @example
     * // Get one EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluationEnseignementFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluationEnseignementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EvaluationEnseignement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementFindFirstArgs} args - Arguments to find a EvaluationEnseignement
     * @example
     * // Get one EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluationEnseignementFindFirstArgs>(args?: SelectSubset<T, EvaluationEnseignementFindFirstArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EvaluationEnseignement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementFindFirstOrThrowArgs} args - Arguments to find a EvaluationEnseignement
     * @example
     * // Get one EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluationEnseignementFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluationEnseignementFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EvaluationEnseignements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvaluationEnseignements
     * const evaluationEnseignements = await prisma.evaluationEnseignement.findMany()
     * 
     * // Get first 10 EvaluationEnseignements
     * const evaluationEnseignements = await prisma.evaluationEnseignement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationEnseignementWithIdOnly = await prisma.evaluationEnseignement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluationEnseignementFindManyArgs>(args?: SelectSubset<T, EvaluationEnseignementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EvaluationEnseignement.
     * @param {EvaluationEnseignementCreateArgs} args - Arguments to create a EvaluationEnseignement.
     * @example
     * // Create one EvaluationEnseignement
     * const EvaluationEnseignement = await prisma.evaluationEnseignement.create({
     *   data: {
     *     // ... data to create a EvaluationEnseignement
     *   }
     * })
     * 
     */
    create<T extends EvaluationEnseignementCreateArgs>(args: SelectSubset<T, EvaluationEnseignementCreateArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EvaluationEnseignements.
     * @param {EvaluationEnseignementCreateManyArgs} args - Arguments to create many EvaluationEnseignements.
     * @example
     * // Create many EvaluationEnseignements
     * const evaluationEnseignement = await prisma.evaluationEnseignement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluationEnseignementCreateManyArgs>(args?: SelectSubset<T, EvaluationEnseignementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvaluationEnseignements and returns the data saved in the database.
     * @param {EvaluationEnseignementCreateManyAndReturnArgs} args - Arguments to create many EvaluationEnseignements.
     * @example
     * // Create many EvaluationEnseignements
     * const evaluationEnseignement = await prisma.evaluationEnseignement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EvaluationEnseignements and only return the `id`
     * const evaluationEnseignementWithIdOnly = await prisma.evaluationEnseignement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluationEnseignementCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluationEnseignementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EvaluationEnseignement.
     * @param {EvaluationEnseignementDeleteArgs} args - Arguments to delete one EvaluationEnseignement.
     * @example
     * // Delete one EvaluationEnseignement
     * const EvaluationEnseignement = await prisma.evaluationEnseignement.delete({
     *   where: {
     *     // ... filter to delete one EvaluationEnseignement
     *   }
     * })
     * 
     */
    delete<T extends EvaluationEnseignementDeleteArgs>(args: SelectSubset<T, EvaluationEnseignementDeleteArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EvaluationEnseignement.
     * @param {EvaluationEnseignementUpdateArgs} args - Arguments to update one EvaluationEnseignement.
     * @example
     * // Update one EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluationEnseignementUpdateArgs>(args: SelectSubset<T, EvaluationEnseignementUpdateArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EvaluationEnseignements.
     * @param {EvaluationEnseignementDeleteManyArgs} args - Arguments to filter EvaluationEnseignements to delete.
     * @example
     * // Delete a few EvaluationEnseignements
     * const { count } = await prisma.evaluationEnseignement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluationEnseignementDeleteManyArgs>(args?: SelectSubset<T, EvaluationEnseignementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvaluationEnseignements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvaluationEnseignements
     * const evaluationEnseignement = await prisma.evaluationEnseignement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluationEnseignementUpdateManyArgs>(args: SelectSubset<T, EvaluationEnseignementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EvaluationEnseignement.
     * @param {EvaluationEnseignementUpsertArgs} args - Arguments to update or create a EvaluationEnseignement.
     * @example
     * // Update or create a EvaluationEnseignement
     * const evaluationEnseignement = await prisma.evaluationEnseignement.upsert({
     *   create: {
     *     // ... data to create a EvaluationEnseignement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvaluationEnseignement we want to update
     *   }
     * })
     */
    upsert<T extends EvaluationEnseignementUpsertArgs>(args: SelectSubset<T, EvaluationEnseignementUpsertArgs<ExtArgs>>): Prisma__EvaluationEnseignementClient<$Result.GetResult<Prisma.$EvaluationEnseignementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EvaluationEnseignements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementCountArgs} args - Arguments to filter EvaluationEnseignements to count.
     * @example
     * // Count the number of EvaluationEnseignements
     * const count = await prisma.evaluationEnseignement.count({
     *   where: {
     *     // ... the filter for the EvaluationEnseignements we want to count
     *   }
     * })
    **/
    count<T extends EvaluationEnseignementCountArgs>(
      args?: Subset<T, EvaluationEnseignementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationEnseignementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvaluationEnseignement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationEnseignementAggregateArgs>(args: Subset<T, EvaluationEnseignementAggregateArgs>): Prisma.PrismaPromise<GetEvaluationEnseignementAggregateType<T>>

    /**
     * Group by EvaluationEnseignement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationEnseignementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationEnseignementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationEnseignementGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationEnseignementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationEnseignementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationEnseignementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvaluationEnseignement model
   */
  readonly fields: EvaluationEnseignementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvaluationEnseignement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationEnseignementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    intervenant<T extends IntervenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntervenantDefaultArgs<ExtArgs>>): Prisma__IntervenantClient<$Result.GetResult<Prisma.$IntervenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvaluationEnseignement model
   */ 
  interface EvaluationEnseignementFieldRefs {
    readonly id: FieldRef<"EvaluationEnseignement", 'String'>
    readonly moduleId: FieldRef<"EvaluationEnseignement", 'String'>
    readonly intervenantId: FieldRef<"EvaluationEnseignement", 'String'>
    readonly dateEnvoi: FieldRef<"EvaluationEnseignement", 'DateTime'>
    readonly dateDebut: FieldRef<"EvaluationEnseignement", 'DateTime'>
    readonly dateFin: FieldRef<"EvaluationEnseignement", 'DateTime'>
    readonly lienEvaluation: FieldRef<"EvaluationEnseignement", 'String'>
    readonly noteQualiteCours: FieldRef<"EvaluationEnseignement", 'Float'>
    readonly noteQualitePedagogie: FieldRef<"EvaluationEnseignement", 'Float'>
    readonly noteDisponibilite: FieldRef<"EvaluationEnseignement", 'Float'>
    readonly noteMoyenne: FieldRef<"EvaluationEnseignement", 'Float'>
    readonly nombreReponses: FieldRef<"EvaluationEnseignement", 'Int'>
    readonly nombreInvitations: FieldRef<"EvaluationEnseignement", 'Int'>
    readonly tauxParticipation: FieldRef<"EvaluationEnseignement", 'Float'>
    readonly commentaires: FieldRef<"EvaluationEnseignement", 'String'>
    readonly statut: FieldRef<"EvaluationEnseignement", 'StatutCampagne'>
    readonly createdAt: FieldRef<"EvaluationEnseignement", 'DateTime'>
    readonly updatedAt: FieldRef<"EvaluationEnseignement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EvaluationEnseignement findUnique
   */
  export type EvaluationEnseignementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEnseignement to fetch.
     */
    where: EvaluationEnseignementWhereUniqueInput
  }

  /**
   * EvaluationEnseignement findUniqueOrThrow
   */
  export type EvaluationEnseignementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEnseignement to fetch.
     */
    where: EvaluationEnseignementWhereUniqueInput
  }

  /**
   * EvaluationEnseignement findFirst
   */
  export type EvaluationEnseignementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEnseignement to fetch.
     */
    where?: EvaluationEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEnseignements to fetch.
     */
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationEnseignements.
     */
    cursor?: EvaluationEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationEnseignements.
     */
    distinct?: EvaluationEnseignementScalarFieldEnum | EvaluationEnseignementScalarFieldEnum[]
  }

  /**
   * EvaluationEnseignement findFirstOrThrow
   */
  export type EvaluationEnseignementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEnseignement to fetch.
     */
    where?: EvaluationEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEnseignements to fetch.
     */
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EvaluationEnseignements.
     */
    cursor?: EvaluationEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEnseignements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EvaluationEnseignements.
     */
    distinct?: EvaluationEnseignementScalarFieldEnum | EvaluationEnseignementScalarFieldEnum[]
  }

  /**
   * EvaluationEnseignement findMany
   */
  export type EvaluationEnseignementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter, which EvaluationEnseignements to fetch.
     */
    where?: EvaluationEnseignementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EvaluationEnseignements to fetch.
     */
    orderBy?: EvaluationEnseignementOrderByWithRelationInput | EvaluationEnseignementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EvaluationEnseignements.
     */
    cursor?: EvaluationEnseignementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EvaluationEnseignements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EvaluationEnseignements.
     */
    skip?: number
    distinct?: EvaluationEnseignementScalarFieldEnum | EvaluationEnseignementScalarFieldEnum[]
  }

  /**
   * EvaluationEnseignement create
   */
  export type EvaluationEnseignementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * The data needed to create a EvaluationEnseignement.
     */
    data: XOR<EvaluationEnseignementCreateInput, EvaluationEnseignementUncheckedCreateInput>
  }

  /**
   * EvaluationEnseignement createMany
   */
  export type EvaluationEnseignementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvaluationEnseignements.
     */
    data: EvaluationEnseignementCreateManyInput | EvaluationEnseignementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvaluationEnseignement createManyAndReturn
   */
  export type EvaluationEnseignementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EvaluationEnseignements.
     */
    data: EvaluationEnseignementCreateManyInput | EvaluationEnseignementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvaluationEnseignement update
   */
  export type EvaluationEnseignementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * The data needed to update a EvaluationEnseignement.
     */
    data: XOR<EvaluationEnseignementUpdateInput, EvaluationEnseignementUncheckedUpdateInput>
    /**
     * Choose, which EvaluationEnseignement to update.
     */
    where: EvaluationEnseignementWhereUniqueInput
  }

  /**
   * EvaluationEnseignement updateMany
   */
  export type EvaluationEnseignementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvaluationEnseignements.
     */
    data: XOR<EvaluationEnseignementUpdateManyMutationInput, EvaluationEnseignementUncheckedUpdateManyInput>
    /**
     * Filter which EvaluationEnseignements to update
     */
    where?: EvaluationEnseignementWhereInput
  }

  /**
   * EvaluationEnseignement upsert
   */
  export type EvaluationEnseignementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * The filter to search for the EvaluationEnseignement to update in case it exists.
     */
    where: EvaluationEnseignementWhereUniqueInput
    /**
     * In case the EvaluationEnseignement found by the `where` argument doesn't exist, create a new EvaluationEnseignement with this data.
     */
    create: XOR<EvaluationEnseignementCreateInput, EvaluationEnseignementUncheckedCreateInput>
    /**
     * In case the EvaluationEnseignement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationEnseignementUpdateInput, EvaluationEnseignementUncheckedUpdateInput>
  }

  /**
   * EvaluationEnseignement delete
   */
  export type EvaluationEnseignementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
    /**
     * Filter which EvaluationEnseignement to delete.
     */
    where: EvaluationEnseignementWhereUniqueInput
  }

  /**
   * EvaluationEnseignement deleteMany
   */
  export type EvaluationEnseignementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvaluationEnseignements to delete
     */
    where?: EvaluationEnseignementWhereInput
  }

  /**
   * EvaluationEnseignement without action
   */
  export type EvaluationEnseignementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationEnseignement
     */
    select?: EvaluationEnseignementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluationEnseignementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    titre: string | null
    message: string | null
    type: $Enums.TypeNotification | null
    priorite: $Enums.PrioriteNotification | null
    lu: boolean | null
    destinataireId: string | null
    entite: string | null
    entiteId: string | null
    lienAction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    titre: string | null
    message: string | null
    type: $Enums.TypeNotification | null
    priorite: $Enums.PrioriteNotification | null
    lu: boolean | null
    destinataireId: string | null
    entite: string | null
    entiteId: string | null
    lienAction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    titre: number
    message: number
    type: number
    priorite: number
    lu: number
    destinataireId: number
    entite: number
    entiteId: number
    lienAction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    priorite?: true
    lu?: true
    destinataireId?: true
    entite?: true
    entiteId?: true
    lienAction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    priorite?: true
    lu?: true
    destinataireId?: true
    entite?: true
    entiteId?: true
    lienAction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    titre?: true
    message?: true
    type?: true
    priorite?: true
    lu?: true
    destinataireId?: true
    entite?: true
    entiteId?: true
    lienAction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    titre: string
    message: string
    type: $Enums.TypeNotification
    priorite: $Enums.PrioriteNotification
    lu: boolean
    destinataireId: string
    entite: string | null
    entiteId: string | null
    lienAction: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    message?: boolean
    type?: boolean
    priorite?: boolean
    lu?: boolean
    destinataireId?: boolean
    entite?: boolean
    entiteId?: boolean
    lienAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titre?: boolean
    message?: boolean
    type?: boolean
    priorite?: boolean
    lu?: boolean
    destinataireId?: boolean
    entite?: boolean
    entiteId?: boolean
    lienAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    titre?: boolean
    message?: boolean
    type?: boolean
    priorite?: boolean
    lu?: boolean
    destinataireId?: boolean
    entite?: boolean
    entiteId?: boolean
    lienAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titre: string
      message: string
      type: $Enums.TypeNotification
      priorite: $Enums.PrioriteNotification
      lu: boolean
      destinataireId: string
      entite: string | null
      entiteId: string | null
      lienAction: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly titre: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'TypeNotification'>
    readonly priorite: FieldRef<"Notification", 'PrioriteNotification'>
    readonly lu: FieldRef<"Notification", 'Boolean'>
    readonly destinataireId: FieldRef<"Notification", 'String'>
    readonly entite: FieldRef<"Notification", 'String'>
    readonly entiteId: FieldRef<"Notification", 'String'>
    readonly lienAction: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model RotationWeekend
   */

  export type AggregateRotationWeekend = {
    _count: RotationWeekendCountAggregateOutputType | null
    _avg: RotationWeekendAvgAggregateOutputType | null
    _sum: RotationWeekendSumAggregateOutputType | null
    _min: RotationWeekendMinAggregateOutputType | null
    _max: RotationWeekendMaxAggregateOutputType | null
  }

  export type RotationWeekendAvgAggregateOutputType = {
    semaineNumero: number | null
    annee: number | null
    nbSeancesTotal: number | null
    nbSeancesRealisees: number | null
  }

  export type RotationWeekendSumAggregateOutputType = {
    semaineNumero: number | null
    annee: number | null
    nbSeancesTotal: number | null
    nbSeancesRealisees: number | null
  }

  export type RotationWeekendMinAggregateOutputType = {
    id: string | null
    dateDebut: Date | null
    dateFin: Date | null
    semaineNumero: number | null
    annee: number | null
    responsableId: string | null
    substitutId: string | null
    status: $Enums.StatutRotation | null
    nbSeancesTotal: number | null
    nbSeancesRealisees: number | null
    commentaire: string | null
    estAbsence: boolean | null
    notificationEnvoyee: boolean | null
    rappelEnvoye: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RotationWeekendMaxAggregateOutputType = {
    id: string | null
    dateDebut: Date | null
    dateFin: Date | null
    semaineNumero: number | null
    annee: number | null
    responsableId: string | null
    substitutId: string | null
    status: $Enums.StatutRotation | null
    nbSeancesTotal: number | null
    nbSeancesRealisees: number | null
    commentaire: string | null
    estAbsence: boolean | null
    notificationEnvoyee: boolean | null
    rappelEnvoye: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type RotationWeekendCountAggregateOutputType = {
    id: number
    dateDebut: number
    dateFin: number
    semaineNumero: number
    annee: number
    responsableId: number
    substitutId: number
    status: number
    nbSeancesTotal: number
    nbSeancesRealisees: number
    commentaire: number
    estAbsence: number
    notificationEnvoyee: number
    rappelEnvoye: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type RotationWeekendAvgAggregateInputType = {
    semaineNumero?: true
    annee?: true
    nbSeancesTotal?: true
    nbSeancesRealisees?: true
  }

  export type RotationWeekendSumAggregateInputType = {
    semaineNumero?: true
    annee?: true
    nbSeancesTotal?: true
    nbSeancesRealisees?: true
  }

  export type RotationWeekendMinAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    semaineNumero?: true
    annee?: true
    responsableId?: true
    substitutId?: true
    status?: true
    nbSeancesTotal?: true
    nbSeancesRealisees?: true
    commentaire?: true
    estAbsence?: true
    notificationEnvoyee?: true
    rappelEnvoye?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RotationWeekendMaxAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    semaineNumero?: true
    annee?: true
    responsableId?: true
    substitutId?: true
    status?: true
    nbSeancesTotal?: true
    nbSeancesRealisees?: true
    commentaire?: true
    estAbsence?: true
    notificationEnvoyee?: true
    rappelEnvoye?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type RotationWeekendCountAggregateInputType = {
    id?: true
    dateDebut?: true
    dateFin?: true
    semaineNumero?: true
    annee?: true
    responsableId?: true
    substitutId?: true
    status?: true
    nbSeancesTotal?: true
    nbSeancesRealisees?: true
    commentaire?: true
    estAbsence?: true
    notificationEnvoyee?: true
    rappelEnvoye?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type RotationWeekendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RotationWeekend to aggregate.
     */
    where?: RotationWeekendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RotationWeekends to fetch.
     */
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RotationWeekendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RotationWeekends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RotationWeekends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RotationWeekends
    **/
    _count?: true | RotationWeekendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RotationWeekendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RotationWeekendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RotationWeekendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RotationWeekendMaxAggregateInputType
  }

  export type GetRotationWeekendAggregateType<T extends RotationWeekendAggregateArgs> = {
        [P in keyof T & keyof AggregateRotationWeekend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRotationWeekend[P]>
      : GetScalarType<T[P], AggregateRotationWeekend[P]>
  }




  export type RotationWeekendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RotationWeekendWhereInput
    orderBy?: RotationWeekendOrderByWithAggregationInput | RotationWeekendOrderByWithAggregationInput[]
    by: RotationWeekendScalarFieldEnum[] | RotationWeekendScalarFieldEnum
    having?: RotationWeekendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RotationWeekendCountAggregateInputType | true
    _avg?: RotationWeekendAvgAggregateInputType
    _sum?: RotationWeekendSumAggregateInputType
    _min?: RotationWeekendMinAggregateInputType
    _max?: RotationWeekendMaxAggregateInputType
  }

  export type RotationWeekendGroupByOutputType = {
    id: string
    dateDebut: Date
    dateFin: Date
    semaineNumero: number
    annee: number
    responsableId: string
    substitutId: string | null
    status: $Enums.StatutRotation
    nbSeancesTotal: number
    nbSeancesRealisees: number
    commentaire: string | null
    estAbsence: boolean
    notificationEnvoyee: boolean
    rappelEnvoye: boolean
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: RotationWeekendCountAggregateOutputType | null
    _avg: RotationWeekendAvgAggregateOutputType | null
    _sum: RotationWeekendSumAggregateOutputType | null
    _min: RotationWeekendMinAggregateOutputType | null
    _max: RotationWeekendMaxAggregateOutputType | null
  }

  type GetRotationWeekendGroupByPayload<T extends RotationWeekendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RotationWeekendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RotationWeekendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RotationWeekendGroupByOutputType[P]>
            : GetScalarType<T[P], RotationWeekendGroupByOutputType[P]>
        }
      >
    >


  export type RotationWeekendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    semaineNumero?: boolean
    annee?: boolean
    responsableId?: boolean
    substitutId?: boolean
    status?: boolean
    nbSeancesTotal?: boolean
    nbSeancesRealisees?: boolean
    commentaire?: boolean
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    responsable?: boolean | UserDefaultArgs<ExtArgs>
    substitut?: boolean | RotationWeekend$substitutArgs<ExtArgs>
    rapportSupervision?: boolean | RotationWeekend$rapportSupervisionArgs<ExtArgs>
  }, ExtArgs["result"]["rotationWeekend"]>

  export type RotationWeekendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    semaineNumero?: boolean
    annee?: boolean
    responsableId?: boolean
    substitutId?: boolean
    status?: boolean
    nbSeancesTotal?: boolean
    nbSeancesRealisees?: boolean
    commentaire?: boolean
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    responsable?: boolean | UserDefaultArgs<ExtArgs>
    substitut?: boolean | RotationWeekend$substitutArgs<ExtArgs>
  }, ExtArgs["result"]["rotationWeekend"]>

  export type RotationWeekendSelectScalar = {
    id?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    semaineNumero?: boolean
    annee?: boolean
    responsableId?: boolean
    substitutId?: boolean
    status?: boolean
    nbSeancesTotal?: boolean
    nbSeancesRealisees?: boolean
    commentaire?: boolean
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type RotationWeekendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsable?: boolean | UserDefaultArgs<ExtArgs>
    substitut?: boolean | RotationWeekend$substitutArgs<ExtArgs>
    rapportSupervision?: boolean | RotationWeekend$rapportSupervisionArgs<ExtArgs>
  }
  export type RotationWeekendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsable?: boolean | UserDefaultArgs<ExtArgs>
    substitut?: boolean | RotationWeekend$substitutArgs<ExtArgs>
  }

  export type $RotationWeekendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RotationWeekend"
    objects: {
      responsable: Prisma.$UserPayload<ExtArgs>
      substitut: Prisma.$UserPayload<ExtArgs> | null
      rapportSupervision: Prisma.$RapportSupervisionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dateDebut: Date
      dateFin: Date
      semaineNumero: number
      annee: number
      responsableId: string
      substitutId: string | null
      status: $Enums.StatutRotation
      nbSeancesTotal: number
      nbSeancesRealisees: number
      commentaire: string | null
      estAbsence: boolean
      notificationEnvoyee: boolean
      rappelEnvoye: boolean
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["rotationWeekend"]>
    composites: {}
  }

  type RotationWeekendGetPayload<S extends boolean | null | undefined | RotationWeekendDefaultArgs> = $Result.GetResult<Prisma.$RotationWeekendPayload, S>

  type RotationWeekendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RotationWeekendFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RotationWeekendCountAggregateInputType | true
    }

  export interface RotationWeekendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RotationWeekend'], meta: { name: 'RotationWeekend' } }
    /**
     * Find zero or one RotationWeekend that matches the filter.
     * @param {RotationWeekendFindUniqueArgs} args - Arguments to find a RotationWeekend
     * @example
     * // Get one RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RotationWeekendFindUniqueArgs>(args: SelectSubset<T, RotationWeekendFindUniqueArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RotationWeekend that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RotationWeekendFindUniqueOrThrowArgs} args - Arguments to find a RotationWeekend
     * @example
     * // Get one RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RotationWeekendFindUniqueOrThrowArgs>(args: SelectSubset<T, RotationWeekendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RotationWeekend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendFindFirstArgs} args - Arguments to find a RotationWeekend
     * @example
     * // Get one RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RotationWeekendFindFirstArgs>(args?: SelectSubset<T, RotationWeekendFindFirstArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RotationWeekend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendFindFirstOrThrowArgs} args - Arguments to find a RotationWeekend
     * @example
     * // Get one RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RotationWeekendFindFirstOrThrowArgs>(args?: SelectSubset<T, RotationWeekendFindFirstOrThrowArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RotationWeekends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RotationWeekends
     * const rotationWeekends = await prisma.rotationWeekend.findMany()
     * 
     * // Get first 10 RotationWeekends
     * const rotationWeekends = await prisma.rotationWeekend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rotationWeekendWithIdOnly = await prisma.rotationWeekend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RotationWeekendFindManyArgs>(args?: SelectSubset<T, RotationWeekendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RotationWeekend.
     * @param {RotationWeekendCreateArgs} args - Arguments to create a RotationWeekend.
     * @example
     * // Create one RotationWeekend
     * const RotationWeekend = await prisma.rotationWeekend.create({
     *   data: {
     *     // ... data to create a RotationWeekend
     *   }
     * })
     * 
     */
    create<T extends RotationWeekendCreateArgs>(args: SelectSubset<T, RotationWeekendCreateArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RotationWeekends.
     * @param {RotationWeekendCreateManyArgs} args - Arguments to create many RotationWeekends.
     * @example
     * // Create many RotationWeekends
     * const rotationWeekend = await prisma.rotationWeekend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RotationWeekendCreateManyArgs>(args?: SelectSubset<T, RotationWeekendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RotationWeekends and returns the data saved in the database.
     * @param {RotationWeekendCreateManyAndReturnArgs} args - Arguments to create many RotationWeekends.
     * @example
     * // Create many RotationWeekends
     * const rotationWeekend = await prisma.rotationWeekend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RotationWeekends and only return the `id`
     * const rotationWeekendWithIdOnly = await prisma.rotationWeekend.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RotationWeekendCreateManyAndReturnArgs>(args?: SelectSubset<T, RotationWeekendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RotationWeekend.
     * @param {RotationWeekendDeleteArgs} args - Arguments to delete one RotationWeekend.
     * @example
     * // Delete one RotationWeekend
     * const RotationWeekend = await prisma.rotationWeekend.delete({
     *   where: {
     *     // ... filter to delete one RotationWeekend
     *   }
     * })
     * 
     */
    delete<T extends RotationWeekendDeleteArgs>(args: SelectSubset<T, RotationWeekendDeleteArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RotationWeekend.
     * @param {RotationWeekendUpdateArgs} args - Arguments to update one RotationWeekend.
     * @example
     * // Update one RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RotationWeekendUpdateArgs>(args: SelectSubset<T, RotationWeekendUpdateArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RotationWeekends.
     * @param {RotationWeekendDeleteManyArgs} args - Arguments to filter RotationWeekends to delete.
     * @example
     * // Delete a few RotationWeekends
     * const { count } = await prisma.rotationWeekend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RotationWeekendDeleteManyArgs>(args?: SelectSubset<T, RotationWeekendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RotationWeekends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RotationWeekends
     * const rotationWeekend = await prisma.rotationWeekend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RotationWeekendUpdateManyArgs>(args: SelectSubset<T, RotationWeekendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RotationWeekend.
     * @param {RotationWeekendUpsertArgs} args - Arguments to update or create a RotationWeekend.
     * @example
     * // Update or create a RotationWeekend
     * const rotationWeekend = await prisma.rotationWeekend.upsert({
     *   create: {
     *     // ... data to create a RotationWeekend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RotationWeekend we want to update
     *   }
     * })
     */
    upsert<T extends RotationWeekendUpsertArgs>(args: SelectSubset<T, RotationWeekendUpsertArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RotationWeekends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendCountArgs} args - Arguments to filter RotationWeekends to count.
     * @example
     * // Count the number of RotationWeekends
     * const count = await prisma.rotationWeekend.count({
     *   where: {
     *     // ... the filter for the RotationWeekends we want to count
     *   }
     * })
    **/
    count<T extends RotationWeekendCountArgs>(
      args?: Subset<T, RotationWeekendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RotationWeekendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RotationWeekend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RotationWeekendAggregateArgs>(args: Subset<T, RotationWeekendAggregateArgs>): Prisma.PrismaPromise<GetRotationWeekendAggregateType<T>>

    /**
     * Group by RotationWeekend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RotationWeekendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RotationWeekendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RotationWeekendGroupByArgs['orderBy'] }
        : { orderBy?: RotationWeekendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RotationWeekendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRotationWeekendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RotationWeekend model
   */
  readonly fields: RotationWeekendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RotationWeekend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RotationWeekendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsable<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    substitut<T extends RotationWeekend$substitutArgs<ExtArgs> = {}>(args?: Subset<T, RotationWeekend$substitutArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    rapportSupervision<T extends RotationWeekend$rapportSupervisionArgs<ExtArgs> = {}>(args?: Subset<T, RotationWeekend$rapportSupervisionArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RotationWeekend model
   */ 
  interface RotationWeekendFieldRefs {
    readonly id: FieldRef<"RotationWeekend", 'String'>
    readonly dateDebut: FieldRef<"RotationWeekend", 'DateTime'>
    readonly dateFin: FieldRef<"RotationWeekend", 'DateTime'>
    readonly semaineNumero: FieldRef<"RotationWeekend", 'Int'>
    readonly annee: FieldRef<"RotationWeekend", 'Int'>
    readonly responsableId: FieldRef<"RotationWeekend", 'String'>
    readonly substitutId: FieldRef<"RotationWeekend", 'String'>
    readonly status: FieldRef<"RotationWeekend", 'StatutRotation'>
    readonly nbSeancesTotal: FieldRef<"RotationWeekend", 'Int'>
    readonly nbSeancesRealisees: FieldRef<"RotationWeekend", 'Int'>
    readonly commentaire: FieldRef<"RotationWeekend", 'String'>
    readonly estAbsence: FieldRef<"RotationWeekend", 'Boolean'>
    readonly notificationEnvoyee: FieldRef<"RotationWeekend", 'Boolean'>
    readonly rappelEnvoye: FieldRef<"RotationWeekend", 'Boolean'>
    readonly createdAt: FieldRef<"RotationWeekend", 'DateTime'>
    readonly updatedAt: FieldRef<"RotationWeekend", 'DateTime'>
    readonly createdBy: FieldRef<"RotationWeekend", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RotationWeekend findUnique
   */
  export type RotationWeekendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter, which RotationWeekend to fetch.
     */
    where: RotationWeekendWhereUniqueInput
  }

  /**
   * RotationWeekend findUniqueOrThrow
   */
  export type RotationWeekendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter, which RotationWeekend to fetch.
     */
    where: RotationWeekendWhereUniqueInput
  }

  /**
   * RotationWeekend findFirst
   */
  export type RotationWeekendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter, which RotationWeekend to fetch.
     */
    where?: RotationWeekendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RotationWeekends to fetch.
     */
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RotationWeekends.
     */
    cursor?: RotationWeekendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RotationWeekends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RotationWeekends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RotationWeekends.
     */
    distinct?: RotationWeekendScalarFieldEnum | RotationWeekendScalarFieldEnum[]
  }

  /**
   * RotationWeekend findFirstOrThrow
   */
  export type RotationWeekendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter, which RotationWeekend to fetch.
     */
    where?: RotationWeekendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RotationWeekends to fetch.
     */
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RotationWeekends.
     */
    cursor?: RotationWeekendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RotationWeekends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RotationWeekends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RotationWeekends.
     */
    distinct?: RotationWeekendScalarFieldEnum | RotationWeekendScalarFieldEnum[]
  }

  /**
   * RotationWeekend findMany
   */
  export type RotationWeekendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter, which RotationWeekends to fetch.
     */
    where?: RotationWeekendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RotationWeekends to fetch.
     */
    orderBy?: RotationWeekendOrderByWithRelationInput | RotationWeekendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RotationWeekends.
     */
    cursor?: RotationWeekendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RotationWeekends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RotationWeekends.
     */
    skip?: number
    distinct?: RotationWeekendScalarFieldEnum | RotationWeekendScalarFieldEnum[]
  }

  /**
   * RotationWeekend create
   */
  export type RotationWeekendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * The data needed to create a RotationWeekend.
     */
    data: XOR<RotationWeekendCreateInput, RotationWeekendUncheckedCreateInput>
  }

  /**
   * RotationWeekend createMany
   */
  export type RotationWeekendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RotationWeekends.
     */
    data: RotationWeekendCreateManyInput | RotationWeekendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RotationWeekend createManyAndReturn
   */
  export type RotationWeekendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RotationWeekends.
     */
    data: RotationWeekendCreateManyInput | RotationWeekendCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RotationWeekend update
   */
  export type RotationWeekendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * The data needed to update a RotationWeekend.
     */
    data: XOR<RotationWeekendUpdateInput, RotationWeekendUncheckedUpdateInput>
    /**
     * Choose, which RotationWeekend to update.
     */
    where: RotationWeekendWhereUniqueInput
  }

  /**
   * RotationWeekend updateMany
   */
  export type RotationWeekendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RotationWeekends.
     */
    data: XOR<RotationWeekendUpdateManyMutationInput, RotationWeekendUncheckedUpdateManyInput>
    /**
     * Filter which RotationWeekends to update
     */
    where?: RotationWeekendWhereInput
  }

  /**
   * RotationWeekend upsert
   */
  export type RotationWeekendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * The filter to search for the RotationWeekend to update in case it exists.
     */
    where: RotationWeekendWhereUniqueInput
    /**
     * In case the RotationWeekend found by the `where` argument doesn't exist, create a new RotationWeekend with this data.
     */
    create: XOR<RotationWeekendCreateInput, RotationWeekendUncheckedCreateInput>
    /**
     * In case the RotationWeekend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RotationWeekendUpdateInput, RotationWeekendUncheckedUpdateInput>
  }

  /**
   * RotationWeekend delete
   */
  export type RotationWeekendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
    /**
     * Filter which RotationWeekend to delete.
     */
    where: RotationWeekendWhereUniqueInput
  }

  /**
   * RotationWeekend deleteMany
   */
  export type RotationWeekendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RotationWeekends to delete
     */
    where?: RotationWeekendWhereInput
  }

  /**
   * RotationWeekend.substitut
   */
  export type RotationWeekend$substitutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RotationWeekend.rapportSupervision
   */
  export type RotationWeekend$rapportSupervisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    where?: RapportSupervisionWhereInput
  }

  /**
   * RotationWeekend without action
   */
  export type RotationWeekendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RotationWeekend
     */
    select?: RotationWeekendSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RotationWeekendInclude<ExtArgs> | null
  }


  /**
   * Model DisponibiliteResponsable
   */

  export type AggregateDisponibiliteResponsable = {
    _count: DisponibiliteResponsableCountAggregateOutputType | null
    _min: DisponibiliteResponsableMinAggregateOutputType | null
    _max: DisponibiliteResponsableMaxAggregateOutputType | null
  }

  export type DisponibiliteResponsableMinAggregateOutputType = {
    id: string | null
    responsableId: string | null
    dateDebut: Date | null
    dateFin: Date | null
    disponible: boolean | null
    raison: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibiliteResponsableMaxAggregateOutputType = {
    id: string | null
    responsableId: string | null
    dateDebut: Date | null
    dateFin: Date | null
    disponible: boolean | null
    raison: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisponibiliteResponsableCountAggregateOutputType = {
    id: number
    responsableId: number
    dateDebut: number
    dateFin: number
    disponible: number
    raison: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisponibiliteResponsableMinAggregateInputType = {
    id?: true
    responsableId?: true
    dateDebut?: true
    dateFin?: true
    disponible?: true
    raison?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibiliteResponsableMaxAggregateInputType = {
    id?: true
    responsableId?: true
    dateDebut?: true
    dateFin?: true
    disponible?: true
    raison?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisponibiliteResponsableCountAggregateInputType = {
    id?: true
    responsableId?: true
    dateDebut?: true
    dateFin?: true
    disponible?: true
    raison?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisponibiliteResponsableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibiliteResponsable to aggregate.
     */
    where?: DisponibiliteResponsableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteResponsables to fetch.
     */
    orderBy?: DisponibiliteResponsableOrderByWithRelationInput | DisponibiliteResponsableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisponibiliteResponsableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteResponsables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteResponsables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisponibiliteResponsables
    **/
    _count?: true | DisponibiliteResponsableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisponibiliteResponsableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisponibiliteResponsableMaxAggregateInputType
  }

  export type GetDisponibiliteResponsableAggregateType<T extends DisponibiliteResponsableAggregateArgs> = {
        [P in keyof T & keyof AggregateDisponibiliteResponsable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisponibiliteResponsable[P]>
      : GetScalarType<T[P], AggregateDisponibiliteResponsable[P]>
  }




  export type DisponibiliteResponsableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisponibiliteResponsableWhereInput
    orderBy?: DisponibiliteResponsableOrderByWithAggregationInput | DisponibiliteResponsableOrderByWithAggregationInput[]
    by: DisponibiliteResponsableScalarFieldEnum[] | DisponibiliteResponsableScalarFieldEnum
    having?: DisponibiliteResponsableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisponibiliteResponsableCountAggregateInputType | true
    _min?: DisponibiliteResponsableMinAggregateInputType
    _max?: DisponibiliteResponsableMaxAggregateInputType
  }

  export type DisponibiliteResponsableGroupByOutputType = {
    id: string
    responsableId: string
    dateDebut: Date
    dateFin: Date
    disponible: boolean
    raison: string | null
    createdAt: Date
    updatedAt: Date
    _count: DisponibiliteResponsableCountAggregateOutputType | null
    _min: DisponibiliteResponsableMinAggregateOutputType | null
    _max: DisponibiliteResponsableMaxAggregateOutputType | null
  }

  type GetDisponibiliteResponsableGroupByPayload<T extends DisponibiliteResponsableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisponibiliteResponsableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisponibiliteResponsableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisponibiliteResponsableGroupByOutputType[P]>
            : GetScalarType<T[P], DisponibiliteResponsableGroupByOutputType[P]>
        }
      >
    >


  export type DisponibiliteResponsableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responsableId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    disponible?: boolean
    raison?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibiliteResponsable"]>

  export type DisponibiliteResponsableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responsableId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    disponible?: boolean
    raison?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disponibiliteResponsable"]>

  export type DisponibiliteResponsableSelectScalar = {
    id?: boolean
    responsableId?: boolean
    dateDebut?: boolean
    dateFin?: boolean
    disponible?: boolean
    raison?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisponibiliteResponsableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisponibiliteResponsableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responsable?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisponibiliteResponsablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisponibiliteResponsable"
    objects: {
      responsable: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responsableId: string
      dateDebut: Date
      dateFin: Date
      disponible: boolean
      raison: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["disponibiliteResponsable"]>
    composites: {}
  }

  type DisponibiliteResponsableGetPayload<S extends boolean | null | undefined | DisponibiliteResponsableDefaultArgs> = $Result.GetResult<Prisma.$DisponibiliteResponsablePayload, S>

  type DisponibiliteResponsableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DisponibiliteResponsableFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DisponibiliteResponsableCountAggregateInputType | true
    }

  export interface DisponibiliteResponsableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisponibiliteResponsable'], meta: { name: 'DisponibiliteResponsable' } }
    /**
     * Find zero or one DisponibiliteResponsable that matches the filter.
     * @param {DisponibiliteResponsableFindUniqueArgs} args - Arguments to find a DisponibiliteResponsable
     * @example
     * // Get one DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisponibiliteResponsableFindUniqueArgs>(args: SelectSubset<T, DisponibiliteResponsableFindUniqueArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DisponibiliteResponsable that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DisponibiliteResponsableFindUniqueOrThrowArgs} args - Arguments to find a DisponibiliteResponsable
     * @example
     * // Get one DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisponibiliteResponsableFindUniqueOrThrowArgs>(args: SelectSubset<T, DisponibiliteResponsableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DisponibiliteResponsable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableFindFirstArgs} args - Arguments to find a DisponibiliteResponsable
     * @example
     * // Get one DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisponibiliteResponsableFindFirstArgs>(args?: SelectSubset<T, DisponibiliteResponsableFindFirstArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DisponibiliteResponsable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableFindFirstOrThrowArgs} args - Arguments to find a DisponibiliteResponsable
     * @example
     * // Get one DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisponibiliteResponsableFindFirstOrThrowArgs>(args?: SelectSubset<T, DisponibiliteResponsableFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DisponibiliteResponsables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisponibiliteResponsables
     * const disponibiliteResponsables = await prisma.disponibiliteResponsable.findMany()
     * 
     * // Get first 10 DisponibiliteResponsables
     * const disponibiliteResponsables = await prisma.disponibiliteResponsable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disponibiliteResponsableWithIdOnly = await prisma.disponibiliteResponsable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisponibiliteResponsableFindManyArgs>(args?: SelectSubset<T, DisponibiliteResponsableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DisponibiliteResponsable.
     * @param {DisponibiliteResponsableCreateArgs} args - Arguments to create a DisponibiliteResponsable.
     * @example
     * // Create one DisponibiliteResponsable
     * const DisponibiliteResponsable = await prisma.disponibiliteResponsable.create({
     *   data: {
     *     // ... data to create a DisponibiliteResponsable
     *   }
     * })
     * 
     */
    create<T extends DisponibiliteResponsableCreateArgs>(args: SelectSubset<T, DisponibiliteResponsableCreateArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DisponibiliteResponsables.
     * @param {DisponibiliteResponsableCreateManyArgs} args - Arguments to create many DisponibiliteResponsables.
     * @example
     * // Create many DisponibiliteResponsables
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisponibiliteResponsableCreateManyArgs>(args?: SelectSubset<T, DisponibiliteResponsableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisponibiliteResponsables and returns the data saved in the database.
     * @param {DisponibiliteResponsableCreateManyAndReturnArgs} args - Arguments to create many DisponibiliteResponsables.
     * @example
     * // Create many DisponibiliteResponsables
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisponibiliteResponsables and only return the `id`
     * const disponibiliteResponsableWithIdOnly = await prisma.disponibiliteResponsable.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisponibiliteResponsableCreateManyAndReturnArgs>(args?: SelectSubset<T, DisponibiliteResponsableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DisponibiliteResponsable.
     * @param {DisponibiliteResponsableDeleteArgs} args - Arguments to delete one DisponibiliteResponsable.
     * @example
     * // Delete one DisponibiliteResponsable
     * const DisponibiliteResponsable = await prisma.disponibiliteResponsable.delete({
     *   where: {
     *     // ... filter to delete one DisponibiliteResponsable
     *   }
     * })
     * 
     */
    delete<T extends DisponibiliteResponsableDeleteArgs>(args: SelectSubset<T, DisponibiliteResponsableDeleteArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DisponibiliteResponsable.
     * @param {DisponibiliteResponsableUpdateArgs} args - Arguments to update one DisponibiliteResponsable.
     * @example
     * // Update one DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisponibiliteResponsableUpdateArgs>(args: SelectSubset<T, DisponibiliteResponsableUpdateArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DisponibiliteResponsables.
     * @param {DisponibiliteResponsableDeleteManyArgs} args - Arguments to filter DisponibiliteResponsables to delete.
     * @example
     * // Delete a few DisponibiliteResponsables
     * const { count } = await prisma.disponibiliteResponsable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisponibiliteResponsableDeleteManyArgs>(args?: SelectSubset<T, DisponibiliteResponsableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisponibiliteResponsables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisponibiliteResponsables
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisponibiliteResponsableUpdateManyArgs>(args: SelectSubset<T, DisponibiliteResponsableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DisponibiliteResponsable.
     * @param {DisponibiliteResponsableUpsertArgs} args - Arguments to update or create a DisponibiliteResponsable.
     * @example
     * // Update or create a DisponibiliteResponsable
     * const disponibiliteResponsable = await prisma.disponibiliteResponsable.upsert({
     *   create: {
     *     // ... data to create a DisponibiliteResponsable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisponibiliteResponsable we want to update
     *   }
     * })
     */
    upsert<T extends DisponibiliteResponsableUpsertArgs>(args: SelectSubset<T, DisponibiliteResponsableUpsertArgs<ExtArgs>>): Prisma__DisponibiliteResponsableClient<$Result.GetResult<Prisma.$DisponibiliteResponsablePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DisponibiliteResponsables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableCountArgs} args - Arguments to filter DisponibiliteResponsables to count.
     * @example
     * // Count the number of DisponibiliteResponsables
     * const count = await prisma.disponibiliteResponsable.count({
     *   where: {
     *     // ... the filter for the DisponibiliteResponsables we want to count
     *   }
     * })
    **/
    count<T extends DisponibiliteResponsableCountArgs>(
      args?: Subset<T, DisponibiliteResponsableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisponibiliteResponsableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisponibiliteResponsable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisponibiliteResponsableAggregateArgs>(args: Subset<T, DisponibiliteResponsableAggregateArgs>): Prisma.PrismaPromise<GetDisponibiliteResponsableAggregateType<T>>

    /**
     * Group by DisponibiliteResponsable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisponibiliteResponsableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisponibiliteResponsableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisponibiliteResponsableGroupByArgs['orderBy'] }
        : { orderBy?: DisponibiliteResponsableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisponibiliteResponsableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisponibiliteResponsableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisponibiliteResponsable model
   */
  readonly fields: DisponibiliteResponsableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisponibiliteResponsable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisponibiliteResponsableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responsable<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisponibiliteResponsable model
   */ 
  interface DisponibiliteResponsableFieldRefs {
    readonly id: FieldRef<"DisponibiliteResponsable", 'String'>
    readonly responsableId: FieldRef<"DisponibiliteResponsable", 'String'>
    readonly dateDebut: FieldRef<"DisponibiliteResponsable", 'DateTime'>
    readonly dateFin: FieldRef<"DisponibiliteResponsable", 'DateTime'>
    readonly disponible: FieldRef<"DisponibiliteResponsable", 'Boolean'>
    readonly raison: FieldRef<"DisponibiliteResponsable", 'String'>
    readonly createdAt: FieldRef<"DisponibiliteResponsable", 'DateTime'>
    readonly updatedAt: FieldRef<"DisponibiliteResponsable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisponibiliteResponsable findUnique
   */
  export type DisponibiliteResponsableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteResponsable to fetch.
     */
    where: DisponibiliteResponsableWhereUniqueInput
  }

  /**
   * DisponibiliteResponsable findUniqueOrThrow
   */
  export type DisponibiliteResponsableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteResponsable to fetch.
     */
    where: DisponibiliteResponsableWhereUniqueInput
  }

  /**
   * DisponibiliteResponsable findFirst
   */
  export type DisponibiliteResponsableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteResponsable to fetch.
     */
    where?: DisponibiliteResponsableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteResponsables to fetch.
     */
    orderBy?: DisponibiliteResponsableOrderByWithRelationInput | DisponibiliteResponsableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibiliteResponsables.
     */
    cursor?: DisponibiliteResponsableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteResponsables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteResponsables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibiliteResponsables.
     */
    distinct?: DisponibiliteResponsableScalarFieldEnum | DisponibiliteResponsableScalarFieldEnum[]
  }

  /**
   * DisponibiliteResponsable findFirstOrThrow
   */
  export type DisponibiliteResponsableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteResponsable to fetch.
     */
    where?: DisponibiliteResponsableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteResponsables to fetch.
     */
    orderBy?: DisponibiliteResponsableOrderByWithRelationInput | DisponibiliteResponsableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisponibiliteResponsables.
     */
    cursor?: DisponibiliteResponsableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteResponsables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteResponsables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisponibiliteResponsables.
     */
    distinct?: DisponibiliteResponsableScalarFieldEnum | DisponibiliteResponsableScalarFieldEnum[]
  }

  /**
   * DisponibiliteResponsable findMany
   */
  export type DisponibiliteResponsableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter, which DisponibiliteResponsables to fetch.
     */
    where?: DisponibiliteResponsableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisponibiliteResponsables to fetch.
     */
    orderBy?: DisponibiliteResponsableOrderByWithRelationInput | DisponibiliteResponsableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisponibiliteResponsables.
     */
    cursor?: DisponibiliteResponsableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisponibiliteResponsables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisponibiliteResponsables.
     */
    skip?: number
    distinct?: DisponibiliteResponsableScalarFieldEnum | DisponibiliteResponsableScalarFieldEnum[]
  }

  /**
   * DisponibiliteResponsable create
   */
  export type DisponibiliteResponsableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * The data needed to create a DisponibiliteResponsable.
     */
    data: XOR<DisponibiliteResponsableCreateInput, DisponibiliteResponsableUncheckedCreateInput>
  }

  /**
   * DisponibiliteResponsable createMany
   */
  export type DisponibiliteResponsableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisponibiliteResponsables.
     */
    data: DisponibiliteResponsableCreateManyInput | DisponibiliteResponsableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisponibiliteResponsable createManyAndReturn
   */
  export type DisponibiliteResponsableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DisponibiliteResponsables.
     */
    data: DisponibiliteResponsableCreateManyInput | DisponibiliteResponsableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisponibiliteResponsable update
   */
  export type DisponibiliteResponsableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * The data needed to update a DisponibiliteResponsable.
     */
    data: XOR<DisponibiliteResponsableUpdateInput, DisponibiliteResponsableUncheckedUpdateInput>
    /**
     * Choose, which DisponibiliteResponsable to update.
     */
    where: DisponibiliteResponsableWhereUniqueInput
  }

  /**
   * DisponibiliteResponsable updateMany
   */
  export type DisponibiliteResponsableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisponibiliteResponsables.
     */
    data: XOR<DisponibiliteResponsableUpdateManyMutationInput, DisponibiliteResponsableUncheckedUpdateManyInput>
    /**
     * Filter which DisponibiliteResponsables to update
     */
    where?: DisponibiliteResponsableWhereInput
  }

  /**
   * DisponibiliteResponsable upsert
   */
  export type DisponibiliteResponsableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * The filter to search for the DisponibiliteResponsable to update in case it exists.
     */
    where: DisponibiliteResponsableWhereUniqueInput
    /**
     * In case the DisponibiliteResponsable found by the `where` argument doesn't exist, create a new DisponibiliteResponsable with this data.
     */
    create: XOR<DisponibiliteResponsableCreateInput, DisponibiliteResponsableUncheckedCreateInput>
    /**
     * In case the DisponibiliteResponsable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisponibiliteResponsableUpdateInput, DisponibiliteResponsableUncheckedUpdateInput>
  }

  /**
   * DisponibiliteResponsable delete
   */
  export type DisponibiliteResponsableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
    /**
     * Filter which DisponibiliteResponsable to delete.
     */
    where: DisponibiliteResponsableWhereUniqueInput
  }

  /**
   * DisponibiliteResponsable deleteMany
   */
  export type DisponibiliteResponsableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisponibiliteResponsables to delete
     */
    where?: DisponibiliteResponsableWhereInput
  }

  /**
   * DisponibiliteResponsable without action
   */
  export type DisponibiliteResponsableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisponibiliteResponsable
     */
    select?: DisponibiliteResponsableSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisponibiliteResponsableInclude<ExtArgs> | null
  }


  /**
   * Model RapportSupervision
   */

  export type AggregateRapportSupervision = {
    _count: RapportSupervisionCountAggregateOutputType | null
    _avg: RapportSupervisionAvgAggregateOutputType | null
    _sum: RapportSupervisionSumAggregateOutputType | null
    _min: RapportSupervisionMinAggregateOutputType | null
    _max: RapportSupervisionMaxAggregateOutputType | null
  }

  export type RapportSupervisionAvgAggregateOutputType = {
    nbSeancesVisitees: number | null
    satisfaction: number | null
  }

  export type RapportSupervisionSumAggregateOutputType = {
    nbSeancesVisitees: number | null
    satisfaction: number | null
  }

  export type RapportSupervisionMinAggregateOutputType = {
    id: string | null
    rotationId: string | null
    heureArrivee: string | null
    heureDepart: string | null
    nbSeancesVisitees: number | null
    incidents: string | null
    observations: string | null
    recommandations: string | null
    satisfaction: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RapportSupervisionMaxAggregateOutputType = {
    id: string | null
    rotationId: string | null
    heureArrivee: string | null
    heureDepart: string | null
    nbSeancesVisitees: number | null
    incidents: string | null
    observations: string | null
    recommandations: string | null
    satisfaction: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RapportSupervisionCountAggregateOutputType = {
    id: number
    rotationId: number
    heureArrivee: number
    heureDepart: number
    nbSeancesVisitees: number
    incidents: number
    observations: number
    recommandations: number
    satisfaction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RapportSupervisionAvgAggregateInputType = {
    nbSeancesVisitees?: true
    satisfaction?: true
  }

  export type RapportSupervisionSumAggregateInputType = {
    nbSeancesVisitees?: true
    satisfaction?: true
  }

  export type RapportSupervisionMinAggregateInputType = {
    id?: true
    rotationId?: true
    heureArrivee?: true
    heureDepart?: true
    nbSeancesVisitees?: true
    incidents?: true
    observations?: true
    recommandations?: true
    satisfaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RapportSupervisionMaxAggregateInputType = {
    id?: true
    rotationId?: true
    heureArrivee?: true
    heureDepart?: true
    nbSeancesVisitees?: true
    incidents?: true
    observations?: true
    recommandations?: true
    satisfaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RapportSupervisionCountAggregateInputType = {
    id?: true
    rotationId?: true
    heureArrivee?: true
    heureDepart?: true
    nbSeancesVisitees?: true
    incidents?: true
    observations?: true
    recommandations?: true
    satisfaction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RapportSupervisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportSupervision to aggregate.
     */
    where?: RapportSupervisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportSupervisions to fetch.
     */
    orderBy?: RapportSupervisionOrderByWithRelationInput | RapportSupervisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RapportSupervisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportSupervisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportSupervisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RapportSupervisions
    **/
    _count?: true | RapportSupervisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RapportSupervisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RapportSupervisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RapportSupervisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RapportSupervisionMaxAggregateInputType
  }

  export type GetRapportSupervisionAggregateType<T extends RapportSupervisionAggregateArgs> = {
        [P in keyof T & keyof AggregateRapportSupervision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRapportSupervision[P]>
      : GetScalarType<T[P], AggregateRapportSupervision[P]>
  }




  export type RapportSupervisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RapportSupervisionWhereInput
    orderBy?: RapportSupervisionOrderByWithAggregationInput | RapportSupervisionOrderByWithAggregationInput[]
    by: RapportSupervisionScalarFieldEnum[] | RapportSupervisionScalarFieldEnum
    having?: RapportSupervisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RapportSupervisionCountAggregateInputType | true
    _avg?: RapportSupervisionAvgAggregateInputType
    _sum?: RapportSupervisionSumAggregateInputType
    _min?: RapportSupervisionMinAggregateInputType
    _max?: RapportSupervisionMaxAggregateInputType
  }

  export type RapportSupervisionGroupByOutputType = {
    id: string
    rotationId: string
    heureArrivee: string | null
    heureDepart: string | null
    nbSeancesVisitees: number
    incidents: string | null
    observations: string | null
    recommandations: string | null
    satisfaction: number | null
    createdAt: Date
    updatedAt: Date
    _count: RapportSupervisionCountAggregateOutputType | null
    _avg: RapportSupervisionAvgAggregateOutputType | null
    _sum: RapportSupervisionSumAggregateOutputType | null
    _min: RapportSupervisionMinAggregateOutputType | null
    _max: RapportSupervisionMaxAggregateOutputType | null
  }

  type GetRapportSupervisionGroupByPayload<T extends RapportSupervisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RapportSupervisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RapportSupervisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RapportSupervisionGroupByOutputType[P]>
            : GetScalarType<T[P], RapportSupervisionGroupByOutputType[P]>
        }
      >
    >


  export type RapportSupervisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rotationId?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    nbSeancesVisitees?: boolean
    incidents?: boolean
    observations?: boolean
    recommandations?: boolean
    satisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotation?: boolean | RotationWeekendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportSupervision"]>

  export type RapportSupervisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rotationId?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    nbSeancesVisitees?: boolean
    incidents?: boolean
    observations?: boolean
    recommandations?: boolean
    satisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rotation?: boolean | RotationWeekendDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapportSupervision"]>

  export type RapportSupervisionSelectScalar = {
    id?: boolean
    rotationId?: boolean
    heureArrivee?: boolean
    heureDepart?: boolean
    nbSeancesVisitees?: boolean
    incidents?: boolean
    observations?: boolean
    recommandations?: boolean
    satisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RapportSupervisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rotation?: boolean | RotationWeekendDefaultArgs<ExtArgs>
  }
  export type RapportSupervisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rotation?: boolean | RotationWeekendDefaultArgs<ExtArgs>
  }

  export type $RapportSupervisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RapportSupervision"
    objects: {
      rotation: Prisma.$RotationWeekendPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      rotationId: string
      heureArrivee: string | null
      heureDepart: string | null
      nbSeancesVisitees: number
      incidents: string | null
      observations: string | null
      recommandations: string | null
      satisfaction: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rapportSupervision"]>
    composites: {}
  }

  type RapportSupervisionGetPayload<S extends boolean | null | undefined | RapportSupervisionDefaultArgs> = $Result.GetResult<Prisma.$RapportSupervisionPayload, S>

  type RapportSupervisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RapportSupervisionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RapportSupervisionCountAggregateInputType | true
    }

  export interface RapportSupervisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RapportSupervision'], meta: { name: 'RapportSupervision' } }
    /**
     * Find zero or one RapportSupervision that matches the filter.
     * @param {RapportSupervisionFindUniqueArgs} args - Arguments to find a RapportSupervision
     * @example
     * // Get one RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RapportSupervisionFindUniqueArgs>(args: SelectSubset<T, RapportSupervisionFindUniqueArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RapportSupervision that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RapportSupervisionFindUniqueOrThrowArgs} args - Arguments to find a RapportSupervision
     * @example
     * // Get one RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RapportSupervisionFindUniqueOrThrowArgs>(args: SelectSubset<T, RapportSupervisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RapportSupervision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionFindFirstArgs} args - Arguments to find a RapportSupervision
     * @example
     * // Get one RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RapportSupervisionFindFirstArgs>(args?: SelectSubset<T, RapportSupervisionFindFirstArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RapportSupervision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionFindFirstOrThrowArgs} args - Arguments to find a RapportSupervision
     * @example
     * // Get one RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RapportSupervisionFindFirstOrThrowArgs>(args?: SelectSubset<T, RapportSupervisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RapportSupervisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RapportSupervisions
     * const rapportSupervisions = await prisma.rapportSupervision.findMany()
     * 
     * // Get first 10 RapportSupervisions
     * const rapportSupervisions = await prisma.rapportSupervision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rapportSupervisionWithIdOnly = await prisma.rapportSupervision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RapportSupervisionFindManyArgs>(args?: SelectSubset<T, RapportSupervisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RapportSupervision.
     * @param {RapportSupervisionCreateArgs} args - Arguments to create a RapportSupervision.
     * @example
     * // Create one RapportSupervision
     * const RapportSupervision = await prisma.rapportSupervision.create({
     *   data: {
     *     // ... data to create a RapportSupervision
     *   }
     * })
     * 
     */
    create<T extends RapportSupervisionCreateArgs>(args: SelectSubset<T, RapportSupervisionCreateArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RapportSupervisions.
     * @param {RapportSupervisionCreateManyArgs} args - Arguments to create many RapportSupervisions.
     * @example
     * // Create many RapportSupervisions
     * const rapportSupervision = await prisma.rapportSupervision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RapportSupervisionCreateManyArgs>(args?: SelectSubset<T, RapportSupervisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RapportSupervisions and returns the data saved in the database.
     * @param {RapportSupervisionCreateManyAndReturnArgs} args - Arguments to create many RapportSupervisions.
     * @example
     * // Create many RapportSupervisions
     * const rapportSupervision = await prisma.rapportSupervision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RapportSupervisions and only return the `id`
     * const rapportSupervisionWithIdOnly = await prisma.rapportSupervision.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RapportSupervisionCreateManyAndReturnArgs>(args?: SelectSubset<T, RapportSupervisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RapportSupervision.
     * @param {RapportSupervisionDeleteArgs} args - Arguments to delete one RapportSupervision.
     * @example
     * // Delete one RapportSupervision
     * const RapportSupervision = await prisma.rapportSupervision.delete({
     *   where: {
     *     // ... filter to delete one RapportSupervision
     *   }
     * })
     * 
     */
    delete<T extends RapportSupervisionDeleteArgs>(args: SelectSubset<T, RapportSupervisionDeleteArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RapportSupervision.
     * @param {RapportSupervisionUpdateArgs} args - Arguments to update one RapportSupervision.
     * @example
     * // Update one RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RapportSupervisionUpdateArgs>(args: SelectSubset<T, RapportSupervisionUpdateArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RapportSupervisions.
     * @param {RapportSupervisionDeleteManyArgs} args - Arguments to filter RapportSupervisions to delete.
     * @example
     * // Delete a few RapportSupervisions
     * const { count } = await prisma.rapportSupervision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RapportSupervisionDeleteManyArgs>(args?: SelectSubset<T, RapportSupervisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RapportSupervisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RapportSupervisions
     * const rapportSupervision = await prisma.rapportSupervision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RapportSupervisionUpdateManyArgs>(args: SelectSubset<T, RapportSupervisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RapportSupervision.
     * @param {RapportSupervisionUpsertArgs} args - Arguments to update or create a RapportSupervision.
     * @example
     * // Update or create a RapportSupervision
     * const rapportSupervision = await prisma.rapportSupervision.upsert({
     *   create: {
     *     // ... data to create a RapportSupervision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RapportSupervision we want to update
     *   }
     * })
     */
    upsert<T extends RapportSupervisionUpsertArgs>(args: SelectSubset<T, RapportSupervisionUpsertArgs<ExtArgs>>): Prisma__RapportSupervisionClient<$Result.GetResult<Prisma.$RapportSupervisionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RapportSupervisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionCountArgs} args - Arguments to filter RapportSupervisions to count.
     * @example
     * // Count the number of RapportSupervisions
     * const count = await prisma.rapportSupervision.count({
     *   where: {
     *     // ... the filter for the RapportSupervisions we want to count
     *   }
     * })
    **/
    count<T extends RapportSupervisionCountArgs>(
      args?: Subset<T, RapportSupervisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RapportSupervisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RapportSupervision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RapportSupervisionAggregateArgs>(args: Subset<T, RapportSupervisionAggregateArgs>): Prisma.PrismaPromise<GetRapportSupervisionAggregateType<T>>

    /**
     * Group by RapportSupervision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportSupervisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RapportSupervisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RapportSupervisionGroupByArgs['orderBy'] }
        : { orderBy?: RapportSupervisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RapportSupervisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRapportSupervisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RapportSupervision model
   */
  readonly fields: RapportSupervisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RapportSupervision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RapportSupervisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rotation<T extends RotationWeekendDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RotationWeekendDefaultArgs<ExtArgs>>): Prisma__RotationWeekendClient<$Result.GetResult<Prisma.$RotationWeekendPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RapportSupervision model
   */ 
  interface RapportSupervisionFieldRefs {
    readonly id: FieldRef<"RapportSupervision", 'String'>
    readonly rotationId: FieldRef<"RapportSupervision", 'String'>
    readonly heureArrivee: FieldRef<"RapportSupervision", 'String'>
    readonly heureDepart: FieldRef<"RapportSupervision", 'String'>
    readonly nbSeancesVisitees: FieldRef<"RapportSupervision", 'Int'>
    readonly incidents: FieldRef<"RapportSupervision", 'String'>
    readonly observations: FieldRef<"RapportSupervision", 'String'>
    readonly recommandations: FieldRef<"RapportSupervision", 'String'>
    readonly satisfaction: FieldRef<"RapportSupervision", 'Int'>
    readonly createdAt: FieldRef<"RapportSupervision", 'DateTime'>
    readonly updatedAt: FieldRef<"RapportSupervision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RapportSupervision findUnique
   */
  export type RapportSupervisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter, which RapportSupervision to fetch.
     */
    where: RapportSupervisionWhereUniqueInput
  }

  /**
   * RapportSupervision findUniqueOrThrow
   */
  export type RapportSupervisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter, which RapportSupervision to fetch.
     */
    where: RapportSupervisionWhereUniqueInput
  }

  /**
   * RapportSupervision findFirst
   */
  export type RapportSupervisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter, which RapportSupervision to fetch.
     */
    where?: RapportSupervisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportSupervisions to fetch.
     */
    orderBy?: RapportSupervisionOrderByWithRelationInput | RapportSupervisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportSupervisions.
     */
    cursor?: RapportSupervisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportSupervisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportSupervisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportSupervisions.
     */
    distinct?: RapportSupervisionScalarFieldEnum | RapportSupervisionScalarFieldEnum[]
  }

  /**
   * RapportSupervision findFirstOrThrow
   */
  export type RapportSupervisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter, which RapportSupervision to fetch.
     */
    where?: RapportSupervisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportSupervisions to fetch.
     */
    orderBy?: RapportSupervisionOrderByWithRelationInput | RapportSupervisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RapportSupervisions.
     */
    cursor?: RapportSupervisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportSupervisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportSupervisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RapportSupervisions.
     */
    distinct?: RapportSupervisionScalarFieldEnum | RapportSupervisionScalarFieldEnum[]
  }

  /**
   * RapportSupervision findMany
   */
  export type RapportSupervisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter, which RapportSupervisions to fetch.
     */
    where?: RapportSupervisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RapportSupervisions to fetch.
     */
    orderBy?: RapportSupervisionOrderByWithRelationInput | RapportSupervisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RapportSupervisions.
     */
    cursor?: RapportSupervisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RapportSupervisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RapportSupervisions.
     */
    skip?: number
    distinct?: RapportSupervisionScalarFieldEnum | RapportSupervisionScalarFieldEnum[]
  }

  /**
   * RapportSupervision create
   */
  export type RapportSupervisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * The data needed to create a RapportSupervision.
     */
    data: XOR<RapportSupervisionCreateInput, RapportSupervisionUncheckedCreateInput>
  }

  /**
   * RapportSupervision createMany
   */
  export type RapportSupervisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RapportSupervisions.
     */
    data: RapportSupervisionCreateManyInput | RapportSupervisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RapportSupervision createManyAndReturn
   */
  export type RapportSupervisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RapportSupervisions.
     */
    data: RapportSupervisionCreateManyInput | RapportSupervisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RapportSupervision update
   */
  export type RapportSupervisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * The data needed to update a RapportSupervision.
     */
    data: XOR<RapportSupervisionUpdateInput, RapportSupervisionUncheckedUpdateInput>
    /**
     * Choose, which RapportSupervision to update.
     */
    where: RapportSupervisionWhereUniqueInput
  }

  /**
   * RapportSupervision updateMany
   */
  export type RapportSupervisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RapportSupervisions.
     */
    data: XOR<RapportSupervisionUpdateManyMutationInput, RapportSupervisionUncheckedUpdateManyInput>
    /**
     * Filter which RapportSupervisions to update
     */
    where?: RapportSupervisionWhereInput
  }

  /**
   * RapportSupervision upsert
   */
  export type RapportSupervisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * The filter to search for the RapportSupervision to update in case it exists.
     */
    where: RapportSupervisionWhereUniqueInput
    /**
     * In case the RapportSupervision found by the `where` argument doesn't exist, create a new RapportSupervision with this data.
     */
    create: XOR<RapportSupervisionCreateInput, RapportSupervisionUncheckedCreateInput>
    /**
     * In case the RapportSupervision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RapportSupervisionUpdateInput, RapportSupervisionUncheckedUpdateInput>
  }

  /**
   * RapportSupervision delete
   */
  export type RapportSupervisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
    /**
     * Filter which RapportSupervision to delete.
     */
    where: RapportSupervisionWhereUniqueInput
  }

  /**
   * RapportSupervision deleteMany
   */
  export type RapportSupervisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RapportSupervisions to delete
     */
    where?: RapportSupervisionWhereInput
  }

  /**
   * RapportSupervision without action
   */
  export type RapportSupervisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RapportSupervision
     */
    select?: RapportSupervisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RapportSupervisionInclude<ExtArgs> | null
  }


  /**
   * Model StatistiqueRotation
   */

  export type AggregateStatistiqueRotation = {
    _count: StatistiqueRotationCountAggregateOutputType | null
    _avg: StatistiqueRotationAvgAggregateOutputType | null
    _sum: StatistiqueRotationSumAggregateOutputType | null
    _min: StatistiqueRotationMinAggregateOutputType | null
    _max: StatistiqueRotationMaxAggregateOutputType | null
  }

  export type StatistiqueRotationAvgAggregateOutputType = {
    annee: number | null
    mois: number | null
    nbWeekendTotal: number | null
    nbWeekendRealises: number | null
    nbWeekendAbsences: number | null
    nbWeekendSubstitut: number | null
    tauxPresence: number | null
    nbSeancesTotal: number | null
    moyenneSatisfaction: number | null
  }

  export type StatistiqueRotationSumAggregateOutputType = {
    annee: number | null
    mois: number | null
    nbWeekendTotal: number | null
    nbWeekendRealises: number | null
    nbWeekendAbsences: number | null
    nbWeekendSubstitut: number | null
    tauxPresence: number | null
    nbSeancesTotal: number | null
    moyenneSatisfaction: number | null
  }

  export type StatistiqueRotationMinAggregateOutputType = {
    id: string | null
    responsableId: string | null
    annee: number | null
    mois: number | null
    nbWeekendTotal: number | null
    nbWeekendRealises: number | null
    nbWeekendAbsences: number | null
    nbWeekendSubstitut: number | null
    tauxPresence: number | null
    nbSeancesTotal: number | null
    moyenneSatisfaction: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatistiqueRotationMaxAggregateOutputType = {
    id: string | null
    responsableId: string | null
    annee: number | null
    mois: number | null
    nbWeekendTotal: number | null
    nbWeekendRealises: number | null
    nbWeekendAbsences: number | null
    nbWeekendSubstitut: number | null
    tauxPresence: number | null
    nbSeancesTotal: number | null
    moyenneSatisfaction: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatistiqueRotationCountAggregateOutputType = {
    id: number
    responsableId: number
    annee: number
    mois: number
    nbWeekendTotal: number
    nbWeekendRealises: number
    nbWeekendAbsences: number
    nbWeekendSubstitut: number
    tauxPresence: number
    nbSeancesTotal: number
    moyenneSatisfaction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatistiqueRotationAvgAggregateInputType = {
    annee?: true
    mois?: true
    nbWeekendTotal?: true
    nbWeekendRealises?: true
    nbWeekendAbsences?: true
    nbWeekendSubstitut?: true
    tauxPresence?: true
    nbSeancesTotal?: true
    moyenneSatisfaction?: true
  }

  export type StatistiqueRotationSumAggregateInputType = {
    annee?: true
    mois?: true
    nbWeekendTotal?: true
    nbWeekendRealises?: true
    nbWeekendAbsences?: true
    nbWeekendSubstitut?: true
    tauxPresence?: true
    nbSeancesTotal?: true
    moyenneSatisfaction?: true
  }

  export type StatistiqueRotationMinAggregateInputType = {
    id?: true
    responsableId?: true
    annee?: true
    mois?: true
    nbWeekendTotal?: true
    nbWeekendRealises?: true
    nbWeekendAbsences?: true
    nbWeekendSubstitut?: true
    tauxPresence?: true
    nbSeancesTotal?: true
    moyenneSatisfaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatistiqueRotationMaxAggregateInputType = {
    id?: true
    responsableId?: true
    annee?: true
    mois?: true
    nbWeekendTotal?: true
    nbWeekendRealises?: true
    nbWeekendAbsences?: true
    nbWeekendSubstitut?: true
    tauxPresence?: true
    nbSeancesTotal?: true
    moyenneSatisfaction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatistiqueRotationCountAggregateInputType = {
    id?: true
    responsableId?: true
    annee?: true
    mois?: true
    nbWeekendTotal?: true
    nbWeekendRealises?: true
    nbWeekendAbsences?: true
    nbWeekendSubstitut?: true
    tauxPresence?: true
    nbSeancesTotal?: true
    moyenneSatisfaction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatistiqueRotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatistiqueRotation to aggregate.
     */
    where?: StatistiqueRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatistiqueRotations to fetch.
     */
    orderBy?: StatistiqueRotationOrderByWithRelationInput | StatistiqueRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatistiqueRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatistiqueRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatistiqueRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatistiqueRotations
    **/
    _count?: true | StatistiqueRotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StatistiqueRotationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StatistiqueRotationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatistiqueRotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatistiqueRotationMaxAggregateInputType
  }

  export type GetStatistiqueRotationAggregateType<T extends StatistiqueRotationAggregateArgs> = {
        [P in keyof T & keyof AggregateStatistiqueRotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatistiqueRotation[P]>
      : GetScalarType<T[P], AggregateStatistiqueRotation[P]>
  }




  export type StatistiqueRotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatistiqueRotationWhereInput
    orderBy?: StatistiqueRotationOrderByWithAggregationInput | StatistiqueRotationOrderByWithAggregationInput[]
    by: StatistiqueRotationScalarFieldEnum[] | StatistiqueRotationScalarFieldEnum
    having?: StatistiqueRotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatistiqueRotationCountAggregateInputType | true
    _avg?: StatistiqueRotationAvgAggregateInputType
    _sum?: StatistiqueRotationSumAggregateInputType
    _min?: StatistiqueRotationMinAggregateInputType
    _max?: StatistiqueRotationMaxAggregateInputType
  }

  export type StatistiqueRotationGroupByOutputType = {
    id: string
    responsableId: string
    annee: number
    mois: number | null
    nbWeekendTotal: number
    nbWeekendRealises: number
    nbWeekendAbsences: number
    nbWeekendSubstitut: number
    tauxPresence: number
    nbSeancesTotal: number
    moyenneSatisfaction: number | null
    createdAt: Date
    updatedAt: Date
    _count: StatistiqueRotationCountAggregateOutputType | null
    _avg: StatistiqueRotationAvgAggregateOutputType | null
    _sum: StatistiqueRotationSumAggregateOutputType | null
    _min: StatistiqueRotationMinAggregateOutputType | null
    _max: StatistiqueRotationMaxAggregateOutputType | null
  }

  type GetStatistiqueRotationGroupByPayload<T extends StatistiqueRotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatistiqueRotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatistiqueRotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatistiqueRotationGroupByOutputType[P]>
            : GetScalarType<T[P], StatistiqueRotationGroupByOutputType[P]>
        }
      >
    >


  export type StatistiqueRotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responsableId?: boolean
    annee?: boolean
    mois?: boolean
    nbWeekendTotal?: boolean
    nbWeekendRealises?: boolean
    nbWeekendAbsences?: boolean
    nbWeekendSubstitut?: boolean
    tauxPresence?: boolean
    nbSeancesTotal?: boolean
    moyenneSatisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statistiqueRotation"]>

  export type StatistiqueRotationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responsableId?: boolean
    annee?: boolean
    mois?: boolean
    nbWeekendTotal?: boolean
    nbWeekendRealises?: boolean
    nbWeekendAbsences?: boolean
    nbWeekendSubstitut?: boolean
    tauxPresence?: boolean
    nbSeancesTotal?: boolean
    moyenneSatisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["statistiqueRotation"]>

  export type StatistiqueRotationSelectScalar = {
    id?: boolean
    responsableId?: boolean
    annee?: boolean
    mois?: boolean
    nbWeekendTotal?: boolean
    nbWeekendRealises?: boolean
    nbWeekendAbsences?: boolean
    nbWeekendSubstitut?: boolean
    tauxPresence?: boolean
    nbSeancesTotal?: boolean
    moyenneSatisfaction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $StatistiqueRotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatistiqueRotation"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responsableId: string
      annee: number
      mois: number | null
      nbWeekendTotal: number
      nbWeekendRealises: number
      nbWeekendAbsences: number
      nbWeekendSubstitut: number
      tauxPresence: number
      nbSeancesTotal: number
      moyenneSatisfaction: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["statistiqueRotation"]>
    composites: {}
  }

  type StatistiqueRotationGetPayload<S extends boolean | null | undefined | StatistiqueRotationDefaultArgs> = $Result.GetResult<Prisma.$StatistiqueRotationPayload, S>

  type StatistiqueRotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StatistiqueRotationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StatistiqueRotationCountAggregateInputType | true
    }

  export interface StatistiqueRotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatistiqueRotation'], meta: { name: 'StatistiqueRotation' } }
    /**
     * Find zero or one StatistiqueRotation that matches the filter.
     * @param {StatistiqueRotationFindUniqueArgs} args - Arguments to find a StatistiqueRotation
     * @example
     * // Get one StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatistiqueRotationFindUniqueArgs>(args: SelectSubset<T, StatistiqueRotationFindUniqueArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StatistiqueRotation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StatistiqueRotationFindUniqueOrThrowArgs} args - Arguments to find a StatistiqueRotation
     * @example
     * // Get one StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatistiqueRotationFindUniqueOrThrowArgs>(args: SelectSubset<T, StatistiqueRotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StatistiqueRotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationFindFirstArgs} args - Arguments to find a StatistiqueRotation
     * @example
     * // Get one StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatistiqueRotationFindFirstArgs>(args?: SelectSubset<T, StatistiqueRotationFindFirstArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StatistiqueRotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationFindFirstOrThrowArgs} args - Arguments to find a StatistiqueRotation
     * @example
     * // Get one StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatistiqueRotationFindFirstOrThrowArgs>(args?: SelectSubset<T, StatistiqueRotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StatistiqueRotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatistiqueRotations
     * const statistiqueRotations = await prisma.statistiqueRotation.findMany()
     * 
     * // Get first 10 StatistiqueRotations
     * const statistiqueRotations = await prisma.statistiqueRotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statistiqueRotationWithIdOnly = await prisma.statistiqueRotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatistiqueRotationFindManyArgs>(args?: SelectSubset<T, StatistiqueRotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StatistiqueRotation.
     * @param {StatistiqueRotationCreateArgs} args - Arguments to create a StatistiqueRotation.
     * @example
     * // Create one StatistiqueRotation
     * const StatistiqueRotation = await prisma.statistiqueRotation.create({
     *   data: {
     *     // ... data to create a StatistiqueRotation
     *   }
     * })
     * 
     */
    create<T extends StatistiqueRotationCreateArgs>(args: SelectSubset<T, StatistiqueRotationCreateArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StatistiqueRotations.
     * @param {StatistiqueRotationCreateManyArgs} args - Arguments to create many StatistiqueRotations.
     * @example
     * // Create many StatistiqueRotations
     * const statistiqueRotation = await prisma.statistiqueRotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatistiqueRotationCreateManyArgs>(args?: SelectSubset<T, StatistiqueRotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatistiqueRotations and returns the data saved in the database.
     * @param {StatistiqueRotationCreateManyAndReturnArgs} args - Arguments to create many StatistiqueRotations.
     * @example
     * // Create many StatistiqueRotations
     * const statistiqueRotation = await prisma.statistiqueRotation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatistiqueRotations and only return the `id`
     * const statistiqueRotationWithIdOnly = await prisma.statistiqueRotation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatistiqueRotationCreateManyAndReturnArgs>(args?: SelectSubset<T, StatistiqueRotationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StatistiqueRotation.
     * @param {StatistiqueRotationDeleteArgs} args - Arguments to delete one StatistiqueRotation.
     * @example
     * // Delete one StatistiqueRotation
     * const StatistiqueRotation = await prisma.statistiqueRotation.delete({
     *   where: {
     *     // ... filter to delete one StatistiqueRotation
     *   }
     * })
     * 
     */
    delete<T extends StatistiqueRotationDeleteArgs>(args: SelectSubset<T, StatistiqueRotationDeleteArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StatistiqueRotation.
     * @param {StatistiqueRotationUpdateArgs} args - Arguments to update one StatistiqueRotation.
     * @example
     * // Update one StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatistiqueRotationUpdateArgs>(args: SelectSubset<T, StatistiqueRotationUpdateArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StatistiqueRotations.
     * @param {StatistiqueRotationDeleteManyArgs} args - Arguments to filter StatistiqueRotations to delete.
     * @example
     * // Delete a few StatistiqueRotations
     * const { count } = await prisma.statistiqueRotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatistiqueRotationDeleteManyArgs>(args?: SelectSubset<T, StatistiqueRotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatistiqueRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatistiqueRotations
     * const statistiqueRotation = await prisma.statistiqueRotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatistiqueRotationUpdateManyArgs>(args: SelectSubset<T, StatistiqueRotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StatistiqueRotation.
     * @param {StatistiqueRotationUpsertArgs} args - Arguments to update or create a StatistiqueRotation.
     * @example
     * // Update or create a StatistiqueRotation
     * const statistiqueRotation = await prisma.statistiqueRotation.upsert({
     *   create: {
     *     // ... data to create a StatistiqueRotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatistiqueRotation we want to update
     *   }
     * })
     */
    upsert<T extends StatistiqueRotationUpsertArgs>(args: SelectSubset<T, StatistiqueRotationUpsertArgs<ExtArgs>>): Prisma__StatistiqueRotationClient<$Result.GetResult<Prisma.$StatistiqueRotationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StatistiqueRotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationCountArgs} args - Arguments to filter StatistiqueRotations to count.
     * @example
     * // Count the number of StatistiqueRotations
     * const count = await prisma.statistiqueRotation.count({
     *   where: {
     *     // ... the filter for the StatistiqueRotations we want to count
     *   }
     * })
    **/
    count<T extends StatistiqueRotationCountArgs>(
      args?: Subset<T, StatistiqueRotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatistiqueRotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatistiqueRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatistiqueRotationAggregateArgs>(args: Subset<T, StatistiqueRotationAggregateArgs>): Prisma.PrismaPromise<GetStatistiqueRotationAggregateType<T>>

    /**
     * Group by StatistiqueRotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatistiqueRotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatistiqueRotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatistiqueRotationGroupByArgs['orderBy'] }
        : { orderBy?: StatistiqueRotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatistiqueRotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatistiqueRotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatistiqueRotation model
   */
  readonly fields: StatistiqueRotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatistiqueRotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatistiqueRotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatistiqueRotation model
   */ 
  interface StatistiqueRotationFieldRefs {
    readonly id: FieldRef<"StatistiqueRotation", 'String'>
    readonly responsableId: FieldRef<"StatistiqueRotation", 'String'>
    readonly annee: FieldRef<"StatistiqueRotation", 'Int'>
    readonly mois: FieldRef<"StatistiqueRotation", 'Int'>
    readonly nbWeekendTotal: FieldRef<"StatistiqueRotation", 'Int'>
    readonly nbWeekendRealises: FieldRef<"StatistiqueRotation", 'Int'>
    readonly nbWeekendAbsences: FieldRef<"StatistiqueRotation", 'Int'>
    readonly nbWeekendSubstitut: FieldRef<"StatistiqueRotation", 'Int'>
    readonly tauxPresence: FieldRef<"StatistiqueRotation", 'Float'>
    readonly nbSeancesTotal: FieldRef<"StatistiqueRotation", 'Int'>
    readonly moyenneSatisfaction: FieldRef<"StatistiqueRotation", 'Float'>
    readonly createdAt: FieldRef<"StatistiqueRotation", 'DateTime'>
    readonly updatedAt: FieldRef<"StatistiqueRotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatistiqueRotation findUnique
   */
  export type StatistiqueRotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter, which StatistiqueRotation to fetch.
     */
    where: StatistiqueRotationWhereUniqueInput
  }

  /**
   * StatistiqueRotation findUniqueOrThrow
   */
  export type StatistiqueRotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter, which StatistiqueRotation to fetch.
     */
    where: StatistiqueRotationWhereUniqueInput
  }

  /**
   * StatistiqueRotation findFirst
   */
  export type StatistiqueRotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter, which StatistiqueRotation to fetch.
     */
    where?: StatistiqueRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatistiqueRotations to fetch.
     */
    orderBy?: StatistiqueRotationOrderByWithRelationInput | StatistiqueRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatistiqueRotations.
     */
    cursor?: StatistiqueRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatistiqueRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatistiqueRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatistiqueRotations.
     */
    distinct?: StatistiqueRotationScalarFieldEnum | StatistiqueRotationScalarFieldEnum[]
  }

  /**
   * StatistiqueRotation findFirstOrThrow
   */
  export type StatistiqueRotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter, which StatistiqueRotation to fetch.
     */
    where?: StatistiqueRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatistiqueRotations to fetch.
     */
    orderBy?: StatistiqueRotationOrderByWithRelationInput | StatistiqueRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatistiqueRotations.
     */
    cursor?: StatistiqueRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatistiqueRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatistiqueRotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatistiqueRotations.
     */
    distinct?: StatistiqueRotationScalarFieldEnum | StatistiqueRotationScalarFieldEnum[]
  }

  /**
   * StatistiqueRotation findMany
   */
  export type StatistiqueRotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter, which StatistiqueRotations to fetch.
     */
    where?: StatistiqueRotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatistiqueRotations to fetch.
     */
    orderBy?: StatistiqueRotationOrderByWithRelationInput | StatistiqueRotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatistiqueRotations.
     */
    cursor?: StatistiqueRotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatistiqueRotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatistiqueRotations.
     */
    skip?: number
    distinct?: StatistiqueRotationScalarFieldEnum | StatistiqueRotationScalarFieldEnum[]
  }

  /**
   * StatistiqueRotation create
   */
  export type StatistiqueRotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * The data needed to create a StatistiqueRotation.
     */
    data: XOR<StatistiqueRotationCreateInput, StatistiqueRotationUncheckedCreateInput>
  }

  /**
   * StatistiqueRotation createMany
   */
  export type StatistiqueRotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatistiqueRotations.
     */
    data: StatistiqueRotationCreateManyInput | StatistiqueRotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatistiqueRotation createManyAndReturn
   */
  export type StatistiqueRotationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StatistiqueRotations.
     */
    data: StatistiqueRotationCreateManyInput | StatistiqueRotationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatistiqueRotation update
   */
  export type StatistiqueRotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * The data needed to update a StatistiqueRotation.
     */
    data: XOR<StatistiqueRotationUpdateInput, StatistiqueRotationUncheckedUpdateInput>
    /**
     * Choose, which StatistiqueRotation to update.
     */
    where: StatistiqueRotationWhereUniqueInput
  }

  /**
   * StatistiqueRotation updateMany
   */
  export type StatistiqueRotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatistiqueRotations.
     */
    data: XOR<StatistiqueRotationUpdateManyMutationInput, StatistiqueRotationUncheckedUpdateManyInput>
    /**
     * Filter which StatistiqueRotations to update
     */
    where?: StatistiqueRotationWhereInput
  }

  /**
   * StatistiqueRotation upsert
   */
  export type StatistiqueRotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * The filter to search for the StatistiqueRotation to update in case it exists.
     */
    where: StatistiqueRotationWhereUniqueInput
    /**
     * In case the StatistiqueRotation found by the `where` argument doesn't exist, create a new StatistiqueRotation with this data.
     */
    create: XOR<StatistiqueRotationCreateInput, StatistiqueRotationUncheckedCreateInput>
    /**
     * In case the StatistiqueRotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatistiqueRotationUpdateInput, StatistiqueRotationUncheckedUpdateInput>
  }

  /**
   * StatistiqueRotation delete
   */
  export type StatistiqueRotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
    /**
     * Filter which StatistiqueRotation to delete.
     */
    where: StatistiqueRotationWhereUniqueInput
  }

  /**
   * StatistiqueRotation deleteMany
   */
  export type StatistiqueRotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatistiqueRotations to delete
     */
    where?: StatistiqueRotationWhereInput
  }

  /**
   * StatistiqueRotation without action
   */
  export type StatistiqueRotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatistiqueRotation
     */
    select?: StatistiqueRotationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    password: 'password'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProgrammeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    semestre: 'semestre',
    niveau: 'niveau',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    status: 'status',
    progression: 'progression',
    totalVHT: 'totalVHT',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProgrammeScalarFieldEnum = (typeof ProgrammeScalarFieldEnum)[keyof typeof ProgrammeScalarFieldEnum]


  export const IntervenantScalarFieldEnum: {
    id: 'id',
    civilite: 'civilite',
    nom: 'nom',
    prenom: 'prenom',
    email: 'email',
    telephone: 'telephone',
    grade: 'grade',
    specialite: 'specialite',
    etablissement: 'etablissement',
    disponible: 'disponible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    creneauxPreferences: 'creneauxPreferences',
    heuresMaxJour: 'heuresMaxJour',
    heuresMaxSemaine: 'heuresMaxSemaine',
    joursPreferences: 'joursPreferences'
  };

  export type IntervenantScalarFieldEnum = (typeof IntervenantScalarFieldEnum)[keyof typeof IntervenantScalarFieldEnum]


  export const DisponibiliteIntervenantScalarFieldEnum: {
    id: 'id',
    jourSemaine: 'jourSemaine',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    type: 'type',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    recurrent: 'recurrent',
    intervenantId: 'intervenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisponibiliteIntervenantScalarFieldEnum = (typeof DisponibiliteIntervenantScalarFieldEnum)[keyof typeof DisponibiliteIntervenantScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    cm: 'cm',
    td: 'td',
    tp: 'tp',
    tpe: 'tpe',
    vht: 'vht',
    coefficient: 'coefficient',
    credits: 'credits',
    status: 'status',
    progression: 'progression',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    programmeId: 'programmeId',
    intervenantId: 'intervenantId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const SalleScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    batiment: 'batiment',
    capacite: 'capacite',
    equipements: 'equipements',
    disponible: 'disponible',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalleScalarFieldEnum = (typeof SalleScalarFieldEnum)[keyof typeof SalleScalarFieldEnum]


  export const SeanceScalarFieldEnum: {
    id: 'id',
    dateSeance: 'dateSeance',
    heureDebut: 'heureDebut',
    heureFin: 'heureFin',
    duree: 'duree',
    typeSeance: 'typeSeance',
    salle: 'salle',
    batiment: 'batiment',
    status: 'status',
    moduleId: 'moduleId',
    intervenantId: 'intervenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    notes: 'notes',
    objectifs: 'objectifs'
  };

  export type SeanceScalarFieldEnum = (typeof SeanceScalarFieldEnum)[keyof typeof SeanceScalarFieldEnum]


  export const ConflitScalarFieldEnum: {
    id: 'id',
    type: 'type',
    description: 'description',
    seanceId1: 'seanceId1',
    seanceId2: 'seanceId2',
    ressourceType: 'ressourceType',
    ressourceId: 'ressourceId',
    resolu: 'resolu',
    resolution: 'resolution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resoluLe: 'resoluLe',
    resoluPar: 'resoluPar',
    severite: 'severite'
  };

  export type ConflitScalarFieldEnum = (typeof ConflitScalarFieldEnum)[keyof typeof ConflitScalarFieldEnum]


  export const PeriodeAcademiqueScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    annee: 'annee',
    debutS1: 'debutS1',
    finS1: 'finS1',
    debutS2: 'debutS2',
    finS2: 'finS2',
    vacancesNoel: 'vacancesNoel',
    finVacancesNoel: 'finVacancesNoel',
    vacancesPaques: 'vacancesPaques',
    finVacancesPaques: 'finVacancesPaques',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PeriodeAcademiqueScalarFieldEnum = (typeof PeriodeAcademiqueScalarFieldEnum)[keyof typeof PeriodeAcademiqueScalarFieldEnum]


  export const JournalActiviteScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entite: 'entite',
    entiteId: 'entiteId',
    description: 'description',
    ancienneValeur: 'ancienneValeur',
    nouvelleValeur: 'nouvelleValeur',
    userId: 'userId',
    userName: 'userName',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type JournalActiviteScalarFieldEnum = (typeof JournalActiviteScalarFieldEnum)[keyof typeof JournalActiviteScalarFieldEnum]


  export const ActiviteAcademiqueScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    datePrevue: 'datePrevue',
    dateReelle: 'dateReelle',
    type: 'type',
    programmeId: 'programmeId',
    periodeId: 'periodeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActiviteAcademiqueScalarFieldEnum = (typeof ActiviteAcademiqueScalarFieldEnum)[keyof typeof ActiviteAcademiqueScalarFieldEnum]


  export const IndicateurAcademiqueScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    description: 'description',
    valeurCible: 'valeurCible',
    valeurReelle: 'valeurReelle',
    periodicite: 'periodicite',
    methodeCalcul: 'methodeCalcul',
    unite: 'unite',
    type: 'type',
    programmeId: 'programmeId',
    periodeId: 'periodeId',
    responsableId: 'responsableId',
    dateCollecte: 'dateCollecte',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IndicateurAcademiqueScalarFieldEnum = (typeof IndicateurAcademiqueScalarFieldEnum)[keyof typeof IndicateurAcademiqueScalarFieldEnum]


  export const ResultatEtudiantScalarFieldEnum: {
    id: 'id',
    numeroEtudiant: 'numeroEtudiant',
    nomEtudiant: 'nomEtudiant',
    prenomEtudiant: 'prenomEtudiant',
    emailEtudiant: 'emailEtudiant',
    moduleId: 'moduleId',
    noteCC: 'noteCC',
    noteExamen: 'noteExamen',
    noteFinale: 'noteFinale',
    statut: 'statut',
    mention: 'mention',
    vhDeroule: 'vhDeroule',
    progressionPct: 'progressionPct',
    presences: 'presences',
    absences: 'absences',
    tauxPresence: 'tauxPresence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResultatEtudiantScalarFieldEnum = (typeof ResultatEtudiantScalarFieldEnum)[keyof typeof ResultatEtudiantScalarFieldEnum]


  export const EvaluationEnseignementScalarFieldEnum: {
    id: 'id',
    moduleId: 'moduleId',
    intervenantId: 'intervenantId',
    dateEnvoi: 'dateEnvoi',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    lienEvaluation: 'lienEvaluation',
    noteQualiteCours: 'noteQualiteCours',
    noteQualitePedagogie: 'noteQualitePedagogie',
    noteDisponibilite: 'noteDisponibilite',
    noteMoyenne: 'noteMoyenne',
    nombreReponses: 'nombreReponses',
    nombreInvitations: 'nombreInvitations',
    tauxParticipation: 'tauxParticipation',
    commentaires: 'commentaires',
    statut: 'statut',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvaluationEnseignementScalarFieldEnum = (typeof EvaluationEnseignementScalarFieldEnum)[keyof typeof EvaluationEnseignementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    titre: 'titre',
    message: 'message',
    type: 'type',
    priorite: 'priorite',
    lu: 'lu',
    destinataireId: 'destinataireId',
    entite: 'entite',
    entiteId: 'entiteId',
    lienAction: 'lienAction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const RotationWeekendScalarFieldEnum: {
    id: 'id',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    semaineNumero: 'semaineNumero',
    annee: 'annee',
    responsableId: 'responsableId',
    substitutId: 'substitutId',
    status: 'status',
    nbSeancesTotal: 'nbSeancesTotal',
    nbSeancesRealisees: 'nbSeancesRealisees',
    commentaire: 'commentaire',
    estAbsence: 'estAbsence',
    notificationEnvoyee: 'notificationEnvoyee',
    rappelEnvoye: 'rappelEnvoye',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type RotationWeekendScalarFieldEnum = (typeof RotationWeekendScalarFieldEnum)[keyof typeof RotationWeekendScalarFieldEnum]


  export const DisponibiliteResponsableScalarFieldEnum: {
    id: 'id',
    responsableId: 'responsableId',
    dateDebut: 'dateDebut',
    dateFin: 'dateFin',
    disponible: 'disponible',
    raison: 'raison',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisponibiliteResponsableScalarFieldEnum = (typeof DisponibiliteResponsableScalarFieldEnum)[keyof typeof DisponibiliteResponsableScalarFieldEnum]


  export const RapportSupervisionScalarFieldEnum: {
    id: 'id',
    rotationId: 'rotationId',
    heureArrivee: 'heureArrivee',
    heureDepart: 'heureDepart',
    nbSeancesVisitees: 'nbSeancesVisitees',
    incidents: 'incidents',
    observations: 'observations',
    recommandations: 'recommandations',
    satisfaction: 'satisfaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RapportSupervisionScalarFieldEnum = (typeof RapportSupervisionScalarFieldEnum)[keyof typeof RapportSupervisionScalarFieldEnum]


  export const StatistiqueRotationScalarFieldEnum: {
    id: 'id',
    responsableId: 'responsableId',
    annee: 'annee',
    mois: 'mois',
    nbWeekendTotal: 'nbWeekendTotal',
    nbWeekendRealises: 'nbWeekendRealises',
    nbWeekendAbsences: 'nbWeekendAbsences',
    nbWeekendSubstitut: 'nbWeekendSubstitut',
    tauxPresence: 'tauxPresence',
    nbSeancesTotal: 'nbSeancesTotal',
    moyenneSatisfaction: 'moyenneSatisfaction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatistiqueRotationScalarFieldEnum = (typeof StatistiqueRotationScalarFieldEnum)[keyof typeof StatistiqueRotationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Semestre'
   */
  export type EnumSemestreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Semestre'>
    


  /**
   * Reference to a field of type 'Semestre[]'
   */
  export type ListEnumSemestreFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Semestre[]'>
    


  /**
   * Reference to a field of type 'StatusProgramme'
   */
  export type EnumStatusProgrammeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusProgramme'>
    


  /**
   * Reference to a field of type 'StatusProgramme[]'
   */
  export type ListEnumStatusProgrammeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusProgramme[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'TypeDisponibilite'
   */
  export type EnumTypeDisponibiliteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeDisponibilite'>
    


  /**
   * Reference to a field of type 'TypeDisponibilite[]'
   */
  export type ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeDisponibilite[]'>
    


  /**
   * Reference to a field of type 'StatusModule'
   */
  export type EnumStatusModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusModule'>
    


  /**
   * Reference to a field of type 'StatusModule[]'
   */
  export type ListEnumStatusModuleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusModule[]'>
    


  /**
   * Reference to a field of type 'TypeSeance'
   */
  export type EnumTypeSeanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeSeance'>
    


  /**
   * Reference to a field of type 'TypeSeance[]'
   */
  export type ListEnumTypeSeanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeSeance[]'>
    


  /**
   * Reference to a field of type 'StatusSeance'
   */
  export type EnumStatusSeanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusSeance'>
    


  /**
   * Reference to a field of type 'StatusSeance[]'
   */
  export type ListEnumStatusSeanceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusSeance[]'>
    


  /**
   * Reference to a field of type 'TypeConflit'
   */
  export type EnumTypeConflitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeConflit'>
    


  /**
   * Reference to a field of type 'TypeConflit[]'
   */
  export type ListEnumTypeConflitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeConflit[]'>
    


  /**
   * Reference to a field of type 'SeveriteConflit'
   */
  export type EnumSeveriteConflitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeveriteConflit'>
    


  /**
   * Reference to a field of type 'SeveriteConflit[]'
   */
  export type ListEnumSeveriteConflitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeveriteConflit[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'StatutCampagne'
   */
  export type EnumStatutCampagneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCampagne'>
    


  /**
   * Reference to a field of type 'StatutCampagne[]'
   */
  export type ListEnumStatutCampagneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutCampagne[]'>
    


  /**
   * Reference to a field of type 'TypeNotification'
   */
  export type EnumTypeNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeNotification'>
    


  /**
   * Reference to a field of type 'TypeNotification[]'
   */
  export type ListEnumTypeNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TypeNotification[]'>
    


  /**
   * Reference to a field of type 'PrioriteNotification'
   */
  export type EnumPrioriteNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrioriteNotification'>
    


  /**
   * Reference to a field of type 'PrioriteNotification[]'
   */
  export type ListEnumPrioriteNotificationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrioriteNotification[]'>
    


  /**
   * Reference to a field of type 'StatutRotation'
   */
  export type EnumStatutRotationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutRotation'>
    


  /**
   * Reference to a field of type 'StatutRotation[]'
   */
  export type ListEnumStatutRotationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatutRotation[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
    modules?: ModuleListRelationFilter
    programmes?: ProgrammeListRelationFilter
    rotationsResponsable?: RotationWeekendListRelationFilter
    rotationsSubstitut?: RotationWeekendListRelationFilter
    disponibilites?: DisponibiliteResponsableListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    indicateursAcademiques?: IndicateurAcademiqueOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    programmes?: ProgrammeOrderByRelationAggregateInput
    rotationsResponsable?: RotationWeekendOrderByRelationAggregateInput
    rotationsSubstitut?: RotationWeekendOrderByRelationAggregateInput
    disponibilites?: DisponibiliteResponsableOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    password?: StringFilter<"User"> | string
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
    modules?: ModuleListRelationFilter
    programmes?: ProgrammeListRelationFilter
    rotationsResponsable?: RotationWeekendListRelationFilter
    rotationsSubstitut?: RotationWeekendListRelationFilter
    disponibilites?: DisponibiliteResponsableListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    password?: StringWithAggregatesFilter<"User"> | string
  }

  export type ProgrammeWhereInput = {
    AND?: ProgrammeWhereInput | ProgrammeWhereInput[]
    OR?: ProgrammeWhereInput[]
    NOT?: ProgrammeWhereInput | ProgrammeWhereInput[]
    id?: StringFilter<"Programme"> | string
    name?: StringFilter<"Programme"> | string
    code?: StringFilter<"Programme"> | string
    description?: StringNullableFilter<"Programme"> | string | null
    semestre?: EnumSemestreFilter<"Programme"> | $Enums.Semestre
    niveau?: StringFilter<"Programme"> | string
    dateDebut?: DateTimeFilter<"Programme"> | Date | string
    dateFin?: DateTimeFilter<"Programme"> | Date | string
    status?: EnumStatusProgrammeFilter<"Programme"> | $Enums.StatusProgramme
    progression?: IntFilter<"Programme"> | number
    totalVHT?: IntFilter<"Programme"> | number
    userId?: StringFilter<"Programme"> | string
    createdAt?: DateTimeFilter<"Programme"> | Date | string
    updatedAt?: DateTimeFilter<"Programme"> | Date | string
    activitesAcademiques?: ActiviteAcademiqueListRelationFilter
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
    modules?: ModuleListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProgrammeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    semestre?: SortOrder
    niveau?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    totalVHT?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activitesAcademiques?: ActiviteAcademiqueOrderByRelationAggregateInput
    indicateursAcademiques?: IndicateurAcademiqueOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type ProgrammeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ProgrammeWhereInput | ProgrammeWhereInput[]
    OR?: ProgrammeWhereInput[]
    NOT?: ProgrammeWhereInput | ProgrammeWhereInput[]
    name?: StringFilter<"Programme"> | string
    description?: StringNullableFilter<"Programme"> | string | null
    semestre?: EnumSemestreFilter<"Programme"> | $Enums.Semestre
    niveau?: StringFilter<"Programme"> | string
    dateDebut?: DateTimeFilter<"Programme"> | Date | string
    dateFin?: DateTimeFilter<"Programme"> | Date | string
    status?: EnumStatusProgrammeFilter<"Programme"> | $Enums.StatusProgramme
    progression?: IntFilter<"Programme"> | number
    totalVHT?: IntFilter<"Programme"> | number
    userId?: StringFilter<"Programme"> | string
    createdAt?: DateTimeFilter<"Programme"> | Date | string
    updatedAt?: DateTimeFilter<"Programme"> | Date | string
    activitesAcademiques?: ActiviteAcademiqueListRelationFilter
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
    modules?: ModuleListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type ProgrammeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    semestre?: SortOrder
    niveau?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    totalVHT?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProgrammeCountOrderByAggregateInput
    _avg?: ProgrammeAvgOrderByAggregateInput
    _max?: ProgrammeMaxOrderByAggregateInput
    _min?: ProgrammeMinOrderByAggregateInput
    _sum?: ProgrammeSumOrderByAggregateInput
  }

  export type ProgrammeScalarWhereWithAggregatesInput = {
    AND?: ProgrammeScalarWhereWithAggregatesInput | ProgrammeScalarWhereWithAggregatesInput[]
    OR?: ProgrammeScalarWhereWithAggregatesInput[]
    NOT?: ProgrammeScalarWhereWithAggregatesInput | ProgrammeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Programme"> | string
    name?: StringWithAggregatesFilter<"Programme"> | string
    code?: StringWithAggregatesFilter<"Programme"> | string
    description?: StringNullableWithAggregatesFilter<"Programme"> | string | null
    semestre?: EnumSemestreWithAggregatesFilter<"Programme"> | $Enums.Semestre
    niveau?: StringWithAggregatesFilter<"Programme"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
    status?: EnumStatusProgrammeWithAggregatesFilter<"Programme"> | $Enums.StatusProgramme
    progression?: IntWithAggregatesFilter<"Programme"> | number
    totalVHT?: IntWithAggregatesFilter<"Programme"> | number
    userId?: StringWithAggregatesFilter<"Programme"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Programme"> | Date | string
  }

  export type IntervenantWhereInput = {
    AND?: IntervenantWhereInput | IntervenantWhereInput[]
    OR?: IntervenantWhereInput[]
    NOT?: IntervenantWhereInput | IntervenantWhereInput[]
    id?: StringFilter<"Intervenant"> | string
    civilite?: StringFilter<"Intervenant"> | string
    nom?: StringFilter<"Intervenant"> | string
    prenom?: StringFilter<"Intervenant"> | string
    email?: StringFilter<"Intervenant"> | string
    telephone?: StringNullableFilter<"Intervenant"> | string | null
    grade?: StringNullableFilter<"Intervenant"> | string | null
    specialite?: StringNullableFilter<"Intervenant"> | string | null
    etablissement?: StringNullableFilter<"Intervenant"> | string | null
    disponible?: BoolFilter<"Intervenant"> | boolean
    createdAt?: DateTimeFilter<"Intervenant"> | Date | string
    updatedAt?: DateTimeFilter<"Intervenant"> | Date | string
    creneauxPreferences?: StringNullableFilter<"Intervenant"> | string | null
    heuresMaxJour?: IntFilter<"Intervenant"> | number
    heuresMaxSemaine?: IntFilter<"Intervenant"> | number
    joursPreferences?: StringNullableFilter<"Intervenant"> | string | null
    disponibilites?: DisponibiliteIntervenantListRelationFilter
    evaluations?: EvaluationEnseignementListRelationFilter
    modules?: ModuleListRelationFilter
    seances?: SeanceListRelationFilter
  }

  export type IntervenantOrderByWithRelationInput = {
    id?: SortOrder
    civilite?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    specialite?: SortOrderInput | SortOrder
    etablissement?: SortOrderInput | SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creneauxPreferences?: SortOrderInput | SortOrder
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
    joursPreferences?: SortOrderInput | SortOrder
    disponibilites?: DisponibiliteIntervenantOrderByRelationAggregateInput
    evaluations?: EvaluationEnseignementOrderByRelationAggregateInput
    modules?: ModuleOrderByRelationAggregateInput
    seances?: SeanceOrderByRelationAggregateInput
  }

  export type IntervenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: IntervenantWhereInput | IntervenantWhereInput[]
    OR?: IntervenantWhereInput[]
    NOT?: IntervenantWhereInput | IntervenantWhereInput[]
    civilite?: StringFilter<"Intervenant"> | string
    nom?: StringFilter<"Intervenant"> | string
    prenom?: StringFilter<"Intervenant"> | string
    telephone?: StringNullableFilter<"Intervenant"> | string | null
    grade?: StringNullableFilter<"Intervenant"> | string | null
    specialite?: StringNullableFilter<"Intervenant"> | string | null
    etablissement?: StringNullableFilter<"Intervenant"> | string | null
    disponible?: BoolFilter<"Intervenant"> | boolean
    createdAt?: DateTimeFilter<"Intervenant"> | Date | string
    updatedAt?: DateTimeFilter<"Intervenant"> | Date | string
    creneauxPreferences?: StringNullableFilter<"Intervenant"> | string | null
    heuresMaxJour?: IntFilter<"Intervenant"> | number
    heuresMaxSemaine?: IntFilter<"Intervenant"> | number
    joursPreferences?: StringNullableFilter<"Intervenant"> | string | null
    disponibilites?: DisponibiliteIntervenantListRelationFilter
    evaluations?: EvaluationEnseignementListRelationFilter
    modules?: ModuleListRelationFilter
    seances?: SeanceListRelationFilter
  }, "id" | "email">

  export type IntervenantOrderByWithAggregationInput = {
    id?: SortOrder
    civilite?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    specialite?: SortOrderInput | SortOrder
    etablissement?: SortOrderInput | SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creneauxPreferences?: SortOrderInput | SortOrder
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
    joursPreferences?: SortOrderInput | SortOrder
    _count?: IntervenantCountOrderByAggregateInput
    _avg?: IntervenantAvgOrderByAggregateInput
    _max?: IntervenantMaxOrderByAggregateInput
    _min?: IntervenantMinOrderByAggregateInput
    _sum?: IntervenantSumOrderByAggregateInput
  }

  export type IntervenantScalarWhereWithAggregatesInput = {
    AND?: IntervenantScalarWhereWithAggregatesInput | IntervenantScalarWhereWithAggregatesInput[]
    OR?: IntervenantScalarWhereWithAggregatesInput[]
    NOT?: IntervenantScalarWhereWithAggregatesInput | IntervenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Intervenant"> | string
    civilite?: StringWithAggregatesFilter<"Intervenant"> | string
    nom?: StringWithAggregatesFilter<"Intervenant"> | string
    prenom?: StringWithAggregatesFilter<"Intervenant"> | string
    email?: StringWithAggregatesFilter<"Intervenant"> | string
    telephone?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
    grade?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
    specialite?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
    etablissement?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
    disponible?: BoolWithAggregatesFilter<"Intervenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Intervenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Intervenant"> | Date | string
    creneauxPreferences?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
    heuresMaxJour?: IntWithAggregatesFilter<"Intervenant"> | number
    heuresMaxSemaine?: IntWithAggregatesFilter<"Intervenant"> | number
    joursPreferences?: StringNullableWithAggregatesFilter<"Intervenant"> | string | null
  }

  export type DisponibiliteIntervenantWhereInput = {
    AND?: DisponibiliteIntervenantWhereInput | DisponibiliteIntervenantWhereInput[]
    OR?: DisponibiliteIntervenantWhereInput[]
    NOT?: DisponibiliteIntervenantWhereInput | DisponibiliteIntervenantWhereInput[]
    id?: StringFilter<"DisponibiliteIntervenant"> | string
    jourSemaine?: IntFilter<"DisponibiliteIntervenant"> | number
    heureDebut?: StringFilter<"DisponibiliteIntervenant"> | string
    heureFin?: StringFilter<"DisponibiliteIntervenant"> | string
    type?: EnumTypeDisponibiliteFilter<"DisponibiliteIntervenant"> | $Enums.TypeDisponibilite
    dateDebut?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    recurrent?: BoolFilter<"DisponibiliteIntervenant"> | boolean
    intervenantId?: StringFilter<"DisponibiliteIntervenant"> | string
    createdAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
  }

  export type DisponibiliteIntervenantOrderByWithRelationInput = {
    id?: SortOrder
    jourSemaine?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    recurrent?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    intervenant?: IntervenantOrderByWithRelationInput
  }

  export type DisponibiliteIntervenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisponibiliteIntervenantWhereInput | DisponibiliteIntervenantWhereInput[]
    OR?: DisponibiliteIntervenantWhereInput[]
    NOT?: DisponibiliteIntervenantWhereInput | DisponibiliteIntervenantWhereInput[]
    jourSemaine?: IntFilter<"DisponibiliteIntervenant"> | number
    heureDebut?: StringFilter<"DisponibiliteIntervenant"> | string
    heureFin?: StringFilter<"DisponibiliteIntervenant"> | string
    type?: EnumTypeDisponibiliteFilter<"DisponibiliteIntervenant"> | $Enums.TypeDisponibilite
    dateDebut?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    recurrent?: BoolFilter<"DisponibiliteIntervenant"> | boolean
    intervenantId?: StringFilter<"DisponibiliteIntervenant"> | string
    createdAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
  }, "id">

  export type DisponibiliteIntervenantOrderByWithAggregationInput = {
    id?: SortOrder
    jourSemaine?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    recurrent?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisponibiliteIntervenantCountOrderByAggregateInput
    _avg?: DisponibiliteIntervenantAvgOrderByAggregateInput
    _max?: DisponibiliteIntervenantMaxOrderByAggregateInput
    _min?: DisponibiliteIntervenantMinOrderByAggregateInput
    _sum?: DisponibiliteIntervenantSumOrderByAggregateInput
  }

  export type DisponibiliteIntervenantScalarWhereWithAggregatesInput = {
    AND?: DisponibiliteIntervenantScalarWhereWithAggregatesInput | DisponibiliteIntervenantScalarWhereWithAggregatesInput[]
    OR?: DisponibiliteIntervenantScalarWhereWithAggregatesInput[]
    NOT?: DisponibiliteIntervenantScalarWhereWithAggregatesInput | DisponibiliteIntervenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisponibiliteIntervenant"> | string
    jourSemaine?: IntWithAggregatesFilter<"DisponibiliteIntervenant"> | number
    heureDebut?: StringWithAggregatesFilter<"DisponibiliteIntervenant"> | string
    heureFin?: StringWithAggregatesFilter<"DisponibiliteIntervenant"> | string
    type?: EnumTypeDisponibiliteWithAggregatesFilter<"DisponibiliteIntervenant"> | $Enums.TypeDisponibilite
    dateDebut?: DateTimeNullableWithAggregatesFilter<"DisponibiliteIntervenant"> | Date | string | null
    dateFin?: DateTimeNullableWithAggregatesFilter<"DisponibiliteIntervenant"> | Date | string | null
    recurrent?: BoolWithAggregatesFilter<"DisponibiliteIntervenant"> | boolean
    intervenantId?: StringWithAggregatesFilter<"DisponibiliteIntervenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DisponibiliteIntervenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DisponibiliteIntervenant"> | Date | string
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: StringFilter<"Module"> | string
    code?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    cm?: IntFilter<"Module"> | number
    td?: IntFilter<"Module"> | number
    tp?: IntFilter<"Module"> | number
    tpe?: IntFilter<"Module"> | number
    vht?: IntFilter<"Module"> | number
    coefficient?: IntFilter<"Module"> | number
    credits?: IntFilter<"Module"> | number
    status?: EnumStatusModuleFilter<"Module"> | $Enums.StatusModule
    progression?: IntFilter<"Module"> | number
    dateDebut?: DateTimeNullableFilter<"Module"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"Module"> | Date | string | null
    programmeId?: StringFilter<"Module"> | string
    intervenantId?: StringNullableFilter<"Module"> | string | null
    userId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    evaluations?: EvaluationEnseignementListRelationFilter
    intervenant?: XOR<IntervenantNullableRelationFilter, IntervenantWhereInput> | null
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    resultatsEtudiants?: ResultatEtudiantListRelationFilter
    seances?: SeanceListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    programmeId?: SortOrder
    intervenantId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evaluations?: EvaluationEnseignementOrderByRelationAggregateInput
    intervenant?: IntervenantOrderByWithRelationInput
    programme?: ProgrammeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    resultatsEtudiants?: ResultatEtudiantOrderByRelationAggregateInput
    seances?: SeanceOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    cm?: IntFilter<"Module"> | number
    td?: IntFilter<"Module"> | number
    tp?: IntFilter<"Module"> | number
    tpe?: IntFilter<"Module"> | number
    vht?: IntFilter<"Module"> | number
    coefficient?: IntFilter<"Module"> | number
    credits?: IntFilter<"Module"> | number
    status?: EnumStatusModuleFilter<"Module"> | $Enums.StatusModule
    progression?: IntFilter<"Module"> | number
    dateDebut?: DateTimeNullableFilter<"Module"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"Module"> | Date | string | null
    programmeId?: StringFilter<"Module"> | string
    intervenantId?: StringNullableFilter<"Module"> | string | null
    userId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    evaluations?: EvaluationEnseignementListRelationFilter
    intervenant?: XOR<IntervenantNullableRelationFilter, IntervenantWhereInput> | null
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    resultatsEtudiants?: ResultatEtudiantListRelationFilter
    seances?: SeanceListRelationFilter
  }, "id" | "code">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    programmeId?: SortOrder
    intervenantId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Module"> | string
    code?: StringWithAggregatesFilter<"Module"> | string
    name?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    cm?: IntWithAggregatesFilter<"Module"> | number
    td?: IntWithAggregatesFilter<"Module"> | number
    tp?: IntWithAggregatesFilter<"Module"> | number
    tpe?: IntWithAggregatesFilter<"Module"> | number
    vht?: IntWithAggregatesFilter<"Module"> | number
    coefficient?: IntWithAggregatesFilter<"Module"> | number
    credits?: IntWithAggregatesFilter<"Module"> | number
    status?: EnumStatusModuleWithAggregatesFilter<"Module"> | $Enums.StatusModule
    progression?: IntWithAggregatesFilter<"Module"> | number
    dateDebut?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    dateFin?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    programmeId?: StringWithAggregatesFilter<"Module"> | string
    intervenantId?: StringNullableWithAggregatesFilter<"Module"> | string | null
    userId?: StringWithAggregatesFilter<"Module"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type SalleWhereInput = {
    AND?: SalleWhereInput | SalleWhereInput[]
    OR?: SalleWhereInput[]
    NOT?: SalleWhereInput | SalleWhereInput[]
    id?: StringFilter<"Salle"> | string
    nom?: StringFilter<"Salle"> | string
    batiment?: StringFilter<"Salle"> | string
    capacite?: IntFilter<"Salle"> | number
    equipements?: StringNullableFilter<"Salle"> | string | null
    disponible?: BoolFilter<"Salle"> | boolean
    createdAt?: DateTimeFilter<"Salle"> | Date | string
    updatedAt?: DateTimeFilter<"Salle"> | Date | string
  }

  export type SalleOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    batiment?: SortOrder
    capacite?: SortOrder
    equipements?: SortOrderInput | SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nom?: string
    AND?: SalleWhereInput | SalleWhereInput[]
    OR?: SalleWhereInput[]
    NOT?: SalleWhereInput | SalleWhereInput[]
    batiment?: StringFilter<"Salle"> | string
    capacite?: IntFilter<"Salle"> | number
    equipements?: StringNullableFilter<"Salle"> | string | null
    disponible?: BoolFilter<"Salle"> | boolean
    createdAt?: DateTimeFilter<"Salle"> | Date | string
    updatedAt?: DateTimeFilter<"Salle"> | Date | string
  }, "id" | "nom">

  export type SalleOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    batiment?: SortOrder
    capacite?: SortOrder
    equipements?: SortOrderInput | SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalleCountOrderByAggregateInput
    _avg?: SalleAvgOrderByAggregateInput
    _max?: SalleMaxOrderByAggregateInput
    _min?: SalleMinOrderByAggregateInput
    _sum?: SalleSumOrderByAggregateInput
  }

  export type SalleScalarWhereWithAggregatesInput = {
    AND?: SalleScalarWhereWithAggregatesInput | SalleScalarWhereWithAggregatesInput[]
    OR?: SalleScalarWhereWithAggregatesInput[]
    NOT?: SalleScalarWhereWithAggregatesInput | SalleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Salle"> | string
    nom?: StringWithAggregatesFilter<"Salle"> | string
    batiment?: StringWithAggregatesFilter<"Salle"> | string
    capacite?: IntWithAggregatesFilter<"Salle"> | number
    equipements?: StringNullableWithAggregatesFilter<"Salle"> | string | null
    disponible?: BoolWithAggregatesFilter<"Salle"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Salle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Salle"> | Date | string
  }

  export type SeanceWhereInput = {
    AND?: SeanceWhereInput | SeanceWhereInput[]
    OR?: SeanceWhereInput[]
    NOT?: SeanceWhereInput | SeanceWhereInput[]
    id?: StringFilter<"Seance"> | string
    dateSeance?: DateTimeFilter<"Seance"> | Date | string
    heureDebut?: StringFilter<"Seance"> | string
    heureFin?: StringFilter<"Seance"> | string
    duree?: IntFilter<"Seance"> | number
    typeSeance?: EnumTypeSeanceFilter<"Seance"> | $Enums.TypeSeance
    salle?: StringNullableFilter<"Seance"> | string | null
    batiment?: StringNullableFilter<"Seance"> | string | null
    status?: EnumStatusSeanceFilter<"Seance"> | $Enums.StatusSeance
    moduleId?: StringFilter<"Seance"> | string
    intervenantId?: StringFilter<"Seance"> | string
    createdAt?: DateTimeFilter<"Seance"> | Date | string
    updatedAt?: DateTimeFilter<"Seance"> | Date | string
    notes?: StringNullableFilter<"Seance"> | string | null
    objectifs?: StringNullableFilter<"Seance"> | string | null
    conflitsAsSeance1?: ConflitListRelationFilter
    conflitsAsSeance2?: ConflitListRelationFilter
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type SeanceOrderByWithRelationInput = {
    id?: SortOrder
    dateSeance?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    duree?: SortOrder
    typeSeance?: SortOrder
    salle?: SortOrderInput | SortOrder
    batiment?: SortOrderInput | SortOrder
    status?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    objectifs?: SortOrderInput | SortOrder
    conflitsAsSeance1?: ConflitOrderByRelationAggregateInput
    conflitsAsSeance2?: ConflitOrderByRelationAggregateInput
    intervenant?: IntervenantOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type SeanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeanceWhereInput | SeanceWhereInput[]
    OR?: SeanceWhereInput[]
    NOT?: SeanceWhereInput | SeanceWhereInput[]
    dateSeance?: DateTimeFilter<"Seance"> | Date | string
    heureDebut?: StringFilter<"Seance"> | string
    heureFin?: StringFilter<"Seance"> | string
    duree?: IntFilter<"Seance"> | number
    typeSeance?: EnumTypeSeanceFilter<"Seance"> | $Enums.TypeSeance
    salle?: StringNullableFilter<"Seance"> | string | null
    batiment?: StringNullableFilter<"Seance"> | string | null
    status?: EnumStatusSeanceFilter<"Seance"> | $Enums.StatusSeance
    moduleId?: StringFilter<"Seance"> | string
    intervenantId?: StringFilter<"Seance"> | string
    createdAt?: DateTimeFilter<"Seance"> | Date | string
    updatedAt?: DateTimeFilter<"Seance"> | Date | string
    notes?: StringNullableFilter<"Seance"> | string | null
    objectifs?: StringNullableFilter<"Seance"> | string | null
    conflitsAsSeance1?: ConflitListRelationFilter
    conflitsAsSeance2?: ConflitListRelationFilter
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id">

  export type SeanceOrderByWithAggregationInput = {
    id?: SortOrder
    dateSeance?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    duree?: SortOrder
    typeSeance?: SortOrder
    salle?: SortOrderInput | SortOrder
    batiment?: SortOrderInput | SortOrder
    status?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    objectifs?: SortOrderInput | SortOrder
    _count?: SeanceCountOrderByAggregateInput
    _avg?: SeanceAvgOrderByAggregateInput
    _max?: SeanceMaxOrderByAggregateInput
    _min?: SeanceMinOrderByAggregateInput
    _sum?: SeanceSumOrderByAggregateInput
  }

  export type SeanceScalarWhereWithAggregatesInput = {
    AND?: SeanceScalarWhereWithAggregatesInput | SeanceScalarWhereWithAggregatesInput[]
    OR?: SeanceScalarWhereWithAggregatesInput[]
    NOT?: SeanceScalarWhereWithAggregatesInput | SeanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seance"> | string
    dateSeance?: DateTimeWithAggregatesFilter<"Seance"> | Date | string
    heureDebut?: StringWithAggregatesFilter<"Seance"> | string
    heureFin?: StringWithAggregatesFilter<"Seance"> | string
    duree?: IntWithAggregatesFilter<"Seance"> | number
    typeSeance?: EnumTypeSeanceWithAggregatesFilter<"Seance"> | $Enums.TypeSeance
    salle?: StringNullableWithAggregatesFilter<"Seance"> | string | null
    batiment?: StringNullableWithAggregatesFilter<"Seance"> | string | null
    status?: EnumStatusSeanceWithAggregatesFilter<"Seance"> | $Enums.StatusSeance
    moduleId?: StringWithAggregatesFilter<"Seance"> | string
    intervenantId?: StringWithAggregatesFilter<"Seance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Seance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Seance"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Seance"> | string | null
    objectifs?: StringNullableWithAggregatesFilter<"Seance"> | string | null
  }

  export type ConflitWhereInput = {
    AND?: ConflitWhereInput | ConflitWhereInput[]
    OR?: ConflitWhereInput[]
    NOT?: ConflitWhereInput | ConflitWhereInput[]
    id?: StringFilter<"Conflit"> | string
    type?: EnumTypeConflitFilter<"Conflit"> | $Enums.TypeConflit
    description?: StringFilter<"Conflit"> | string
    seanceId1?: StringFilter<"Conflit"> | string
    seanceId2?: StringNullableFilter<"Conflit"> | string | null
    ressourceType?: StringFilter<"Conflit"> | string
    ressourceId?: StringFilter<"Conflit"> | string
    resolu?: BoolFilter<"Conflit"> | boolean
    resolution?: StringNullableFilter<"Conflit"> | string | null
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
    resoluLe?: DateTimeNullableFilter<"Conflit"> | Date | string | null
    resoluPar?: StringNullableFilter<"Conflit"> | string | null
    severite?: EnumSeveriteConflitFilter<"Conflit"> | $Enums.SeveriteConflit
    seance1?: XOR<SeanceRelationFilter, SeanceWhereInput>
    seance2?: XOR<SeanceNullableRelationFilter, SeanceWhereInput> | null
  }

  export type ConflitOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    seanceId1?: SortOrder
    seanceId2?: SortOrderInput | SortOrder
    ressourceType?: SortOrder
    ressourceId?: SortOrder
    resolu?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resoluLe?: SortOrderInput | SortOrder
    resoluPar?: SortOrderInput | SortOrder
    severite?: SortOrder
    seance1?: SeanceOrderByWithRelationInput
    seance2?: SeanceOrderByWithRelationInput
  }

  export type ConflitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConflitWhereInput | ConflitWhereInput[]
    OR?: ConflitWhereInput[]
    NOT?: ConflitWhereInput | ConflitWhereInput[]
    type?: EnumTypeConflitFilter<"Conflit"> | $Enums.TypeConflit
    description?: StringFilter<"Conflit"> | string
    seanceId1?: StringFilter<"Conflit"> | string
    seanceId2?: StringNullableFilter<"Conflit"> | string | null
    ressourceType?: StringFilter<"Conflit"> | string
    ressourceId?: StringFilter<"Conflit"> | string
    resolu?: BoolFilter<"Conflit"> | boolean
    resolution?: StringNullableFilter<"Conflit"> | string | null
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
    resoluLe?: DateTimeNullableFilter<"Conflit"> | Date | string | null
    resoluPar?: StringNullableFilter<"Conflit"> | string | null
    severite?: EnumSeveriteConflitFilter<"Conflit"> | $Enums.SeveriteConflit
    seance1?: XOR<SeanceRelationFilter, SeanceWhereInput>
    seance2?: XOR<SeanceNullableRelationFilter, SeanceWhereInput> | null
  }, "id">

  export type ConflitOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    seanceId1?: SortOrder
    seanceId2?: SortOrderInput | SortOrder
    ressourceType?: SortOrder
    ressourceId?: SortOrder
    resolu?: SortOrder
    resolution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resoluLe?: SortOrderInput | SortOrder
    resoluPar?: SortOrderInput | SortOrder
    severite?: SortOrder
    _count?: ConflitCountOrderByAggregateInput
    _max?: ConflitMaxOrderByAggregateInput
    _min?: ConflitMinOrderByAggregateInput
  }

  export type ConflitScalarWhereWithAggregatesInput = {
    AND?: ConflitScalarWhereWithAggregatesInput | ConflitScalarWhereWithAggregatesInput[]
    OR?: ConflitScalarWhereWithAggregatesInput[]
    NOT?: ConflitScalarWhereWithAggregatesInput | ConflitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conflit"> | string
    type?: EnumTypeConflitWithAggregatesFilter<"Conflit"> | $Enums.TypeConflit
    description?: StringWithAggregatesFilter<"Conflit"> | string
    seanceId1?: StringWithAggregatesFilter<"Conflit"> | string
    seanceId2?: StringNullableWithAggregatesFilter<"Conflit"> | string | null
    ressourceType?: StringWithAggregatesFilter<"Conflit"> | string
    ressourceId?: StringWithAggregatesFilter<"Conflit"> | string
    resolu?: BoolWithAggregatesFilter<"Conflit"> | boolean
    resolution?: StringNullableWithAggregatesFilter<"Conflit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conflit"> | Date | string
    resoluLe?: DateTimeNullableWithAggregatesFilter<"Conflit"> | Date | string | null
    resoluPar?: StringNullableWithAggregatesFilter<"Conflit"> | string | null
    severite?: EnumSeveriteConflitWithAggregatesFilter<"Conflit"> | $Enums.SeveriteConflit
  }

  export type PeriodeAcademiqueWhereInput = {
    AND?: PeriodeAcademiqueWhereInput | PeriodeAcademiqueWhereInput[]
    OR?: PeriodeAcademiqueWhereInput[]
    NOT?: PeriodeAcademiqueWhereInput | PeriodeAcademiqueWhereInput[]
    id?: StringFilter<"PeriodeAcademique"> | string
    nom?: StringFilter<"PeriodeAcademique"> | string
    annee?: StringFilter<"PeriodeAcademique"> | string
    debutS1?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finS1?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    debutS2?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finS2?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    vacancesNoel?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finVacancesNoel?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    vacancesPaques?: DateTimeNullableFilter<"PeriodeAcademique"> | Date | string | null
    finVacancesPaques?: DateTimeNullableFilter<"PeriodeAcademique"> | Date | string | null
    active?: BoolFilter<"PeriodeAcademique"> | boolean
    createdAt?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    activitesAcademiques?: ActiviteAcademiqueListRelationFilter
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
  }

  export type PeriodeAcademiqueOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    debutS1?: SortOrder
    finS1?: SortOrder
    debutS2?: SortOrder
    finS2?: SortOrder
    vacancesNoel?: SortOrder
    finVacancesNoel?: SortOrder
    vacancesPaques?: SortOrderInput | SortOrder
    finVacancesPaques?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    activitesAcademiques?: ActiviteAcademiqueOrderByRelationAggregateInput
    indicateursAcademiques?: IndicateurAcademiqueOrderByRelationAggregateInput
  }

  export type PeriodeAcademiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PeriodeAcademiqueWhereInput | PeriodeAcademiqueWhereInput[]
    OR?: PeriodeAcademiqueWhereInput[]
    NOT?: PeriodeAcademiqueWhereInput | PeriodeAcademiqueWhereInput[]
    nom?: StringFilter<"PeriodeAcademique"> | string
    annee?: StringFilter<"PeriodeAcademique"> | string
    debutS1?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finS1?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    debutS2?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finS2?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    vacancesNoel?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    finVacancesNoel?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    vacancesPaques?: DateTimeNullableFilter<"PeriodeAcademique"> | Date | string | null
    finVacancesPaques?: DateTimeNullableFilter<"PeriodeAcademique"> | Date | string | null
    active?: BoolFilter<"PeriodeAcademique"> | boolean
    createdAt?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"PeriodeAcademique"> | Date | string
    activitesAcademiques?: ActiviteAcademiqueListRelationFilter
    indicateursAcademiques?: IndicateurAcademiqueListRelationFilter
  }, "id">

  export type PeriodeAcademiqueOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    debutS1?: SortOrder
    finS1?: SortOrder
    debutS2?: SortOrder
    finS2?: SortOrder
    vacancesNoel?: SortOrder
    finVacancesNoel?: SortOrder
    vacancesPaques?: SortOrderInput | SortOrder
    finVacancesPaques?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PeriodeAcademiqueCountOrderByAggregateInput
    _max?: PeriodeAcademiqueMaxOrderByAggregateInput
    _min?: PeriodeAcademiqueMinOrderByAggregateInput
  }

  export type PeriodeAcademiqueScalarWhereWithAggregatesInput = {
    AND?: PeriodeAcademiqueScalarWhereWithAggregatesInput | PeriodeAcademiqueScalarWhereWithAggregatesInput[]
    OR?: PeriodeAcademiqueScalarWhereWithAggregatesInput[]
    NOT?: PeriodeAcademiqueScalarWhereWithAggregatesInput | PeriodeAcademiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PeriodeAcademique"> | string
    nom?: StringWithAggregatesFilter<"PeriodeAcademique"> | string
    annee?: StringWithAggregatesFilter<"PeriodeAcademique"> | string
    debutS1?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    finS1?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    debutS2?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    finS2?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    vacancesNoel?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    finVacancesNoel?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    vacancesPaques?: DateTimeNullableWithAggregatesFilter<"PeriodeAcademique"> | Date | string | null
    finVacancesPaques?: DateTimeNullableWithAggregatesFilter<"PeriodeAcademique"> | Date | string | null
    active?: BoolWithAggregatesFilter<"PeriodeAcademique"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PeriodeAcademique"> | Date | string
  }

  export type JournalActiviteWhereInput = {
    AND?: JournalActiviteWhereInput | JournalActiviteWhereInput[]
    OR?: JournalActiviteWhereInput[]
    NOT?: JournalActiviteWhereInput | JournalActiviteWhereInput[]
    id?: StringFilter<"JournalActivite"> | string
    action?: EnumActionTypeFilter<"JournalActivite"> | $Enums.ActionType
    entite?: StringFilter<"JournalActivite"> | string
    entiteId?: StringFilter<"JournalActivite"> | string
    description?: StringFilter<"JournalActivite"> | string
    ancienneValeur?: StringNullableFilter<"JournalActivite"> | string | null
    nouvelleValeur?: StringNullableFilter<"JournalActivite"> | string | null
    userId?: StringFilter<"JournalActivite"> | string
    userName?: StringNullableFilter<"JournalActivite"> | string | null
    ipAddress?: StringNullableFilter<"JournalActivite"> | string | null
    userAgent?: StringNullableFilter<"JournalActivite"> | string | null
    createdAt?: DateTimeFilter<"JournalActivite"> | Date | string
  }

  export type JournalActiviteOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    description?: SortOrder
    ancienneValeur?: SortOrderInput | SortOrder
    nouvelleValeur?: SortOrderInput | SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type JournalActiviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: JournalActiviteWhereInput | JournalActiviteWhereInput[]
    OR?: JournalActiviteWhereInput[]
    NOT?: JournalActiviteWhereInput | JournalActiviteWhereInput[]
    action?: EnumActionTypeFilter<"JournalActivite"> | $Enums.ActionType
    entite?: StringFilter<"JournalActivite"> | string
    entiteId?: StringFilter<"JournalActivite"> | string
    description?: StringFilter<"JournalActivite"> | string
    ancienneValeur?: StringNullableFilter<"JournalActivite"> | string | null
    nouvelleValeur?: StringNullableFilter<"JournalActivite"> | string | null
    userId?: StringFilter<"JournalActivite"> | string
    userName?: StringNullableFilter<"JournalActivite"> | string | null
    ipAddress?: StringNullableFilter<"JournalActivite"> | string | null
    userAgent?: StringNullableFilter<"JournalActivite"> | string | null
    createdAt?: DateTimeFilter<"JournalActivite"> | Date | string
  }, "id">

  export type JournalActiviteOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    description?: SortOrder
    ancienneValeur?: SortOrderInput | SortOrder
    nouvelleValeur?: SortOrderInput | SortOrder
    userId?: SortOrder
    userName?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: JournalActiviteCountOrderByAggregateInput
    _max?: JournalActiviteMaxOrderByAggregateInput
    _min?: JournalActiviteMinOrderByAggregateInput
  }

  export type JournalActiviteScalarWhereWithAggregatesInput = {
    AND?: JournalActiviteScalarWhereWithAggregatesInput | JournalActiviteScalarWhereWithAggregatesInput[]
    OR?: JournalActiviteScalarWhereWithAggregatesInput[]
    NOT?: JournalActiviteScalarWhereWithAggregatesInput | JournalActiviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JournalActivite"> | string
    action?: EnumActionTypeWithAggregatesFilter<"JournalActivite"> | $Enums.ActionType
    entite?: StringWithAggregatesFilter<"JournalActivite"> | string
    entiteId?: StringWithAggregatesFilter<"JournalActivite"> | string
    description?: StringWithAggregatesFilter<"JournalActivite"> | string
    ancienneValeur?: StringNullableWithAggregatesFilter<"JournalActivite"> | string | null
    nouvelleValeur?: StringNullableWithAggregatesFilter<"JournalActivite"> | string | null
    userId?: StringWithAggregatesFilter<"JournalActivite"> | string
    userName?: StringNullableWithAggregatesFilter<"JournalActivite"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"JournalActivite"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"JournalActivite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"JournalActivite"> | Date | string
  }

  export type ActiviteAcademiqueWhereInput = {
    AND?: ActiviteAcademiqueWhereInput | ActiviteAcademiqueWhereInput[]
    OR?: ActiviteAcademiqueWhereInput[]
    NOT?: ActiviteAcademiqueWhereInput | ActiviteAcademiqueWhereInput[]
    id?: StringFilter<"ActiviteAcademique"> | string
    nom?: StringFilter<"ActiviteAcademique"> | string
    description?: StringNullableFilter<"ActiviteAcademique"> | string | null
    datePrevue?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    dateReelle?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    type?: StringFilter<"ActiviteAcademique"> | string
    programmeId?: StringFilter<"ActiviteAcademique"> | string
    periodeId?: StringFilter<"ActiviteAcademique"> | string
    createdAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
    periode?: XOR<PeriodeAcademiqueRelationFilter, PeriodeAcademiqueWhereInput>
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
  }

  export type ActiviteAcademiqueOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    datePrevue?: SortOrderInput | SortOrder
    dateReelle?: SortOrderInput | SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    periode?: PeriodeAcademiqueOrderByWithRelationInput
    programme?: ProgrammeOrderByWithRelationInput
  }

  export type ActiviteAcademiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActiviteAcademiqueWhereInput | ActiviteAcademiqueWhereInput[]
    OR?: ActiviteAcademiqueWhereInput[]
    NOT?: ActiviteAcademiqueWhereInput | ActiviteAcademiqueWhereInput[]
    nom?: StringFilter<"ActiviteAcademique"> | string
    description?: StringNullableFilter<"ActiviteAcademique"> | string | null
    datePrevue?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    dateReelle?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    type?: StringFilter<"ActiviteAcademique"> | string
    programmeId?: StringFilter<"ActiviteAcademique"> | string
    periodeId?: StringFilter<"ActiviteAcademique"> | string
    createdAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
    periode?: XOR<PeriodeAcademiqueRelationFilter, PeriodeAcademiqueWhereInput>
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
  }, "id">

  export type ActiviteAcademiqueOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    datePrevue?: SortOrderInput | SortOrder
    dateReelle?: SortOrderInput | SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActiviteAcademiqueCountOrderByAggregateInput
    _max?: ActiviteAcademiqueMaxOrderByAggregateInput
    _min?: ActiviteAcademiqueMinOrderByAggregateInput
  }

  export type ActiviteAcademiqueScalarWhereWithAggregatesInput = {
    AND?: ActiviteAcademiqueScalarWhereWithAggregatesInput | ActiviteAcademiqueScalarWhereWithAggregatesInput[]
    OR?: ActiviteAcademiqueScalarWhereWithAggregatesInput[]
    NOT?: ActiviteAcademiqueScalarWhereWithAggregatesInput | ActiviteAcademiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActiviteAcademique"> | string
    nom?: StringWithAggregatesFilter<"ActiviteAcademique"> | string
    description?: StringNullableWithAggregatesFilter<"ActiviteAcademique"> | string | null
    datePrevue?: DateTimeNullableWithAggregatesFilter<"ActiviteAcademique"> | Date | string | null
    dateReelle?: DateTimeNullableWithAggregatesFilter<"ActiviteAcademique"> | Date | string | null
    type?: StringWithAggregatesFilter<"ActiviteAcademique"> | string
    programmeId?: StringWithAggregatesFilter<"ActiviteAcademique"> | string
    periodeId?: StringWithAggregatesFilter<"ActiviteAcademique"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ActiviteAcademique"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActiviteAcademique"> | Date | string
  }

  export type IndicateurAcademiqueWhereInput = {
    AND?: IndicateurAcademiqueWhereInput | IndicateurAcademiqueWhereInput[]
    OR?: IndicateurAcademiqueWhereInput[]
    NOT?: IndicateurAcademiqueWhereInput | IndicateurAcademiqueWhereInput[]
    id?: StringFilter<"IndicateurAcademique"> | string
    nom?: StringFilter<"IndicateurAcademique"> | string
    description?: StringNullableFilter<"IndicateurAcademique"> | string | null
    valeurCible?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    valeurReelle?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    periodicite?: StringFilter<"IndicateurAcademique"> | string
    methodeCalcul?: StringNullableFilter<"IndicateurAcademique"> | string | null
    unite?: StringFilter<"IndicateurAcademique"> | string
    type?: StringFilter<"IndicateurAcademique"> | string
    programmeId?: StringFilter<"IndicateurAcademique"> | string
    periodeId?: StringFilter<"IndicateurAcademique"> | string
    responsableId?: StringNullableFilter<"IndicateurAcademique"> | string | null
    dateCollecte?: DateTimeNullableFilter<"IndicateurAcademique"> | Date | string | null
    createdAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
    periode?: XOR<PeriodeAcademiqueRelationFilter, PeriodeAcademiqueWhereInput>
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
    responsable?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type IndicateurAcademiqueOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    valeurCible?: SortOrderInput | SortOrder
    valeurReelle?: SortOrderInput | SortOrder
    periodicite?: SortOrder
    methodeCalcul?: SortOrderInput | SortOrder
    unite?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    responsableId?: SortOrderInput | SortOrder
    dateCollecte?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    periode?: PeriodeAcademiqueOrderByWithRelationInput
    programme?: ProgrammeOrderByWithRelationInput
    responsable?: UserOrderByWithRelationInput
  }

  export type IndicateurAcademiqueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IndicateurAcademiqueWhereInput | IndicateurAcademiqueWhereInput[]
    OR?: IndicateurAcademiqueWhereInput[]
    NOT?: IndicateurAcademiqueWhereInput | IndicateurAcademiqueWhereInput[]
    nom?: StringFilter<"IndicateurAcademique"> | string
    description?: StringNullableFilter<"IndicateurAcademique"> | string | null
    valeurCible?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    valeurReelle?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    periodicite?: StringFilter<"IndicateurAcademique"> | string
    methodeCalcul?: StringNullableFilter<"IndicateurAcademique"> | string | null
    unite?: StringFilter<"IndicateurAcademique"> | string
    type?: StringFilter<"IndicateurAcademique"> | string
    programmeId?: StringFilter<"IndicateurAcademique"> | string
    periodeId?: StringFilter<"IndicateurAcademique"> | string
    responsableId?: StringNullableFilter<"IndicateurAcademique"> | string | null
    dateCollecte?: DateTimeNullableFilter<"IndicateurAcademique"> | Date | string | null
    createdAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
    periode?: XOR<PeriodeAcademiqueRelationFilter, PeriodeAcademiqueWhereInput>
    programme?: XOR<ProgrammeRelationFilter, ProgrammeWhereInput>
    responsable?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type IndicateurAcademiqueOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrderInput | SortOrder
    valeurCible?: SortOrderInput | SortOrder
    valeurReelle?: SortOrderInput | SortOrder
    periodicite?: SortOrder
    methodeCalcul?: SortOrderInput | SortOrder
    unite?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    responsableId?: SortOrderInput | SortOrder
    dateCollecte?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IndicateurAcademiqueCountOrderByAggregateInput
    _avg?: IndicateurAcademiqueAvgOrderByAggregateInput
    _max?: IndicateurAcademiqueMaxOrderByAggregateInput
    _min?: IndicateurAcademiqueMinOrderByAggregateInput
    _sum?: IndicateurAcademiqueSumOrderByAggregateInput
  }

  export type IndicateurAcademiqueScalarWhereWithAggregatesInput = {
    AND?: IndicateurAcademiqueScalarWhereWithAggregatesInput | IndicateurAcademiqueScalarWhereWithAggregatesInput[]
    OR?: IndicateurAcademiqueScalarWhereWithAggregatesInput[]
    NOT?: IndicateurAcademiqueScalarWhereWithAggregatesInput | IndicateurAcademiqueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    nom?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    description?: StringNullableWithAggregatesFilter<"IndicateurAcademique"> | string | null
    valeurCible?: FloatNullableWithAggregatesFilter<"IndicateurAcademique"> | number | null
    valeurReelle?: FloatNullableWithAggregatesFilter<"IndicateurAcademique"> | number | null
    periodicite?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    methodeCalcul?: StringNullableWithAggregatesFilter<"IndicateurAcademique"> | string | null
    unite?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    type?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    programmeId?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    periodeId?: StringWithAggregatesFilter<"IndicateurAcademique"> | string
    responsableId?: StringNullableWithAggregatesFilter<"IndicateurAcademique"> | string | null
    dateCollecte?: DateTimeNullableWithAggregatesFilter<"IndicateurAcademique"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"IndicateurAcademique"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IndicateurAcademique"> | Date | string
  }

  export type ResultatEtudiantWhereInput = {
    AND?: ResultatEtudiantWhereInput | ResultatEtudiantWhereInput[]
    OR?: ResultatEtudiantWhereInput[]
    NOT?: ResultatEtudiantWhereInput | ResultatEtudiantWhereInput[]
    id?: StringFilter<"ResultatEtudiant"> | string
    numeroEtudiant?: StringFilter<"ResultatEtudiant"> | string
    nomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    prenomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    emailEtudiant?: StringNullableFilter<"ResultatEtudiant"> | string | null
    moduleId?: StringFilter<"ResultatEtudiant"> | string
    noteCC?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteExamen?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteFinale?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    statut?: StringFilter<"ResultatEtudiant"> | string
    mention?: StringNullableFilter<"ResultatEtudiant"> | string | null
    vhDeroule?: IntFilter<"ResultatEtudiant"> | number
    progressionPct?: IntFilter<"ResultatEtudiant"> | number
    presences?: IntFilter<"ResultatEtudiant"> | number
    absences?: IntFilter<"ResultatEtudiant"> | number
    tauxPresence?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    createdAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type ResultatEtudiantOrderByWithRelationInput = {
    id?: SortOrder
    numeroEtudiant?: SortOrder
    nomEtudiant?: SortOrder
    prenomEtudiant?: SortOrder
    emailEtudiant?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    noteCC?: SortOrderInput | SortOrder
    noteExamen?: SortOrderInput | SortOrder
    noteFinale?: SortOrderInput | SortOrder
    statut?: SortOrder
    mention?: SortOrderInput | SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    module?: ModuleOrderByWithRelationInput
  }

  export type ResultatEtudiantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    numeroEtudiant_moduleId?: ResultatEtudiantNumeroEtudiantModuleIdCompoundUniqueInput
    AND?: ResultatEtudiantWhereInput | ResultatEtudiantWhereInput[]
    OR?: ResultatEtudiantWhereInput[]
    NOT?: ResultatEtudiantWhereInput | ResultatEtudiantWhereInput[]
    numeroEtudiant?: StringFilter<"ResultatEtudiant"> | string
    nomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    prenomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    emailEtudiant?: StringNullableFilter<"ResultatEtudiant"> | string | null
    moduleId?: StringFilter<"ResultatEtudiant"> | string
    noteCC?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteExamen?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteFinale?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    statut?: StringFilter<"ResultatEtudiant"> | string
    mention?: StringNullableFilter<"ResultatEtudiant"> | string | null
    vhDeroule?: IntFilter<"ResultatEtudiant"> | number
    progressionPct?: IntFilter<"ResultatEtudiant"> | number
    presences?: IntFilter<"ResultatEtudiant"> | number
    absences?: IntFilter<"ResultatEtudiant"> | number
    tauxPresence?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    createdAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id" | "numeroEtudiant_moduleId">

  export type ResultatEtudiantOrderByWithAggregationInput = {
    id?: SortOrder
    numeroEtudiant?: SortOrder
    nomEtudiant?: SortOrder
    prenomEtudiant?: SortOrder
    emailEtudiant?: SortOrderInput | SortOrder
    moduleId?: SortOrder
    noteCC?: SortOrderInput | SortOrder
    noteExamen?: SortOrderInput | SortOrder
    noteFinale?: SortOrderInput | SortOrder
    statut?: SortOrder
    mention?: SortOrderInput | SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResultatEtudiantCountOrderByAggregateInput
    _avg?: ResultatEtudiantAvgOrderByAggregateInput
    _max?: ResultatEtudiantMaxOrderByAggregateInput
    _min?: ResultatEtudiantMinOrderByAggregateInput
    _sum?: ResultatEtudiantSumOrderByAggregateInput
  }

  export type ResultatEtudiantScalarWhereWithAggregatesInput = {
    AND?: ResultatEtudiantScalarWhereWithAggregatesInput | ResultatEtudiantScalarWhereWithAggregatesInput[]
    OR?: ResultatEtudiantScalarWhereWithAggregatesInput[]
    NOT?: ResultatEtudiantScalarWhereWithAggregatesInput | ResultatEtudiantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    numeroEtudiant?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    nomEtudiant?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    prenomEtudiant?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    emailEtudiant?: StringNullableWithAggregatesFilter<"ResultatEtudiant"> | string | null
    moduleId?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    noteCC?: FloatNullableWithAggregatesFilter<"ResultatEtudiant"> | number | null
    noteExamen?: FloatNullableWithAggregatesFilter<"ResultatEtudiant"> | number | null
    noteFinale?: FloatNullableWithAggregatesFilter<"ResultatEtudiant"> | number | null
    statut?: StringWithAggregatesFilter<"ResultatEtudiant"> | string
    mention?: StringNullableWithAggregatesFilter<"ResultatEtudiant"> | string | null
    vhDeroule?: IntWithAggregatesFilter<"ResultatEtudiant"> | number
    progressionPct?: IntWithAggregatesFilter<"ResultatEtudiant"> | number
    presences?: IntWithAggregatesFilter<"ResultatEtudiant"> | number
    absences?: IntWithAggregatesFilter<"ResultatEtudiant"> | number
    tauxPresence?: FloatNullableWithAggregatesFilter<"ResultatEtudiant"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ResultatEtudiant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ResultatEtudiant"> | Date | string
  }

  export type EvaluationEnseignementWhereInput = {
    AND?: EvaluationEnseignementWhereInput | EvaluationEnseignementWhereInput[]
    OR?: EvaluationEnseignementWhereInput[]
    NOT?: EvaluationEnseignementWhereInput | EvaluationEnseignementWhereInput[]
    id?: StringFilter<"EvaluationEnseignement"> | string
    moduleId?: StringFilter<"EvaluationEnseignement"> | string
    intervenantId?: StringFilter<"EvaluationEnseignement"> | string
    dateEnvoi?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateDebut?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    lienEvaluation?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    noteQualiteCours?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteQualitePedagogie?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteDisponibilite?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteMoyenne?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    nombreReponses?: IntFilter<"EvaluationEnseignement"> | number
    nombreInvitations?: IntFilter<"EvaluationEnseignement"> | number
    tauxParticipation?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    commentaires?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    statut?: EnumStatutCampagneFilter<"EvaluationEnseignement"> | $Enums.StatutCampagne
    createdAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }

  export type EvaluationEnseignementOrderByWithRelationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    dateEnvoi?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    lienEvaluation?: SortOrderInput | SortOrder
    noteQualiteCours?: SortOrderInput | SortOrder
    noteQualitePedagogie?: SortOrderInput | SortOrder
    noteDisponibilite?: SortOrderInput | SortOrder
    noteMoyenne?: SortOrderInput | SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    intervenant?: IntervenantOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type EvaluationEnseignementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvaluationEnseignementWhereInput | EvaluationEnseignementWhereInput[]
    OR?: EvaluationEnseignementWhereInput[]
    NOT?: EvaluationEnseignementWhereInput | EvaluationEnseignementWhereInput[]
    moduleId?: StringFilter<"EvaluationEnseignement"> | string
    intervenantId?: StringFilter<"EvaluationEnseignement"> | string
    dateEnvoi?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateDebut?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    lienEvaluation?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    noteQualiteCours?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteQualitePedagogie?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteDisponibilite?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteMoyenne?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    nombreReponses?: IntFilter<"EvaluationEnseignement"> | number
    nombreInvitations?: IntFilter<"EvaluationEnseignement"> | number
    tauxParticipation?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    commentaires?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    statut?: EnumStatutCampagneFilter<"EvaluationEnseignement"> | $Enums.StatutCampagne
    createdAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
    intervenant?: XOR<IntervenantRelationFilter, IntervenantWhereInput>
    module?: XOR<ModuleRelationFilter, ModuleWhereInput>
  }, "id">

  export type EvaluationEnseignementOrderByWithAggregationInput = {
    id?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    dateEnvoi?: SortOrderInput | SortOrder
    dateDebut?: SortOrderInput | SortOrder
    dateFin?: SortOrderInput | SortOrder
    lienEvaluation?: SortOrderInput | SortOrder
    noteQualiteCours?: SortOrderInput | SortOrder
    noteQualitePedagogie?: SortOrderInput | SortOrder
    noteDisponibilite?: SortOrderInput | SortOrder
    noteMoyenne?: SortOrderInput | SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrderInput | SortOrder
    commentaires?: SortOrderInput | SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvaluationEnseignementCountOrderByAggregateInput
    _avg?: EvaluationEnseignementAvgOrderByAggregateInput
    _max?: EvaluationEnseignementMaxOrderByAggregateInput
    _min?: EvaluationEnseignementMinOrderByAggregateInput
    _sum?: EvaluationEnseignementSumOrderByAggregateInput
  }

  export type EvaluationEnseignementScalarWhereWithAggregatesInput = {
    AND?: EvaluationEnseignementScalarWhereWithAggregatesInput | EvaluationEnseignementScalarWhereWithAggregatesInput[]
    OR?: EvaluationEnseignementScalarWhereWithAggregatesInput[]
    NOT?: EvaluationEnseignementScalarWhereWithAggregatesInput | EvaluationEnseignementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvaluationEnseignement"> | string
    moduleId?: StringWithAggregatesFilter<"EvaluationEnseignement"> | string
    intervenantId?: StringWithAggregatesFilter<"EvaluationEnseignement"> | string
    dateEnvoi?: DateTimeNullableWithAggregatesFilter<"EvaluationEnseignement"> | Date | string | null
    dateDebut?: DateTimeNullableWithAggregatesFilter<"EvaluationEnseignement"> | Date | string | null
    dateFin?: DateTimeNullableWithAggregatesFilter<"EvaluationEnseignement"> | Date | string | null
    lienEvaluation?: StringNullableWithAggregatesFilter<"EvaluationEnseignement"> | string | null
    noteQualiteCours?: FloatNullableWithAggregatesFilter<"EvaluationEnseignement"> | number | null
    noteQualitePedagogie?: FloatNullableWithAggregatesFilter<"EvaluationEnseignement"> | number | null
    noteDisponibilite?: FloatNullableWithAggregatesFilter<"EvaluationEnseignement"> | number | null
    noteMoyenne?: FloatNullableWithAggregatesFilter<"EvaluationEnseignement"> | number | null
    nombreReponses?: IntWithAggregatesFilter<"EvaluationEnseignement"> | number
    nombreInvitations?: IntWithAggregatesFilter<"EvaluationEnseignement"> | number
    tauxParticipation?: FloatNullableWithAggregatesFilter<"EvaluationEnseignement"> | number | null
    commentaires?: StringNullableWithAggregatesFilter<"EvaluationEnseignement"> | string | null
    statut?: EnumStatutCampagneWithAggregatesFilter<"EvaluationEnseignement"> | $Enums.StatutCampagne
    createdAt?: DateTimeWithAggregatesFilter<"EvaluationEnseignement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EvaluationEnseignement"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    titre?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumTypeNotificationFilter<"Notification"> | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFilter<"Notification"> | $Enums.PrioriteNotification
    lu?: BoolFilter<"Notification"> | boolean
    destinataireId?: StringFilter<"Notification"> | string
    entite?: StringNullableFilter<"Notification"> | string | null
    entiteId?: StringNullableFilter<"Notification"> | string | null
    lienAction?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    lu?: SortOrder
    destinataireId?: SortOrder
    entite?: SortOrderInput | SortOrder
    entiteId?: SortOrderInput | SortOrder
    lienAction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    titre?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumTypeNotificationFilter<"Notification"> | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFilter<"Notification"> | $Enums.PrioriteNotification
    lu?: BoolFilter<"Notification"> | boolean
    destinataireId?: StringFilter<"Notification"> | string
    entite?: StringNullableFilter<"Notification"> | string | null
    entiteId?: StringNullableFilter<"Notification"> | string | null
    lienAction?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    lu?: SortOrder
    destinataireId?: SortOrder
    entite?: SortOrderInput | SortOrder
    entiteId?: SortOrderInput | SortOrder
    lienAction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    titre?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumTypeNotificationWithAggregatesFilter<"Notification"> | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationWithAggregatesFilter<"Notification"> | $Enums.PrioriteNotification
    lu?: BoolWithAggregatesFilter<"Notification"> | boolean
    destinataireId?: StringWithAggregatesFilter<"Notification"> | string
    entite?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entiteId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    lienAction?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type RotationWeekendWhereInput = {
    AND?: RotationWeekendWhereInput | RotationWeekendWhereInput[]
    OR?: RotationWeekendWhereInput[]
    NOT?: RotationWeekendWhereInput | RotationWeekendWhereInput[]
    id?: StringFilter<"RotationWeekend"> | string
    dateDebut?: DateTimeFilter<"RotationWeekend"> | Date | string
    dateFin?: DateTimeFilter<"RotationWeekend"> | Date | string
    semaineNumero?: IntFilter<"RotationWeekend"> | number
    annee?: IntFilter<"RotationWeekend"> | number
    responsableId?: StringFilter<"RotationWeekend"> | string
    substitutId?: StringNullableFilter<"RotationWeekend"> | string | null
    status?: EnumStatutRotationFilter<"RotationWeekend"> | $Enums.StatutRotation
    nbSeancesTotal?: IntFilter<"RotationWeekend"> | number
    nbSeancesRealisees?: IntFilter<"RotationWeekend"> | number
    commentaire?: StringNullableFilter<"RotationWeekend"> | string | null
    estAbsence?: BoolFilter<"RotationWeekend"> | boolean
    notificationEnvoyee?: BoolFilter<"RotationWeekend"> | boolean
    rappelEnvoye?: BoolFilter<"RotationWeekend"> | boolean
    createdAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    updatedAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    createdBy?: StringNullableFilter<"RotationWeekend"> | string | null
    responsable?: XOR<UserRelationFilter, UserWhereInput>
    substitut?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rapportSupervision?: XOR<RapportSupervisionNullableRelationFilter, RapportSupervisionWhereInput> | null
  }

  export type RotationWeekendOrderByWithRelationInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    semaineNumero?: SortOrder
    annee?: SortOrder
    responsableId?: SortOrder
    substitutId?: SortOrderInput | SortOrder
    status?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    estAbsence?: SortOrder
    notificationEnvoyee?: SortOrder
    rappelEnvoye?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    responsable?: UserOrderByWithRelationInput
    substitut?: UserOrderByWithRelationInput
    rapportSupervision?: RapportSupervisionOrderByWithRelationInput
  }

  export type RotationWeekendWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dateDebut_responsableId?: RotationWeekendDateDebutResponsableIdCompoundUniqueInput
    AND?: RotationWeekendWhereInput | RotationWeekendWhereInput[]
    OR?: RotationWeekendWhereInput[]
    NOT?: RotationWeekendWhereInput | RotationWeekendWhereInput[]
    dateDebut?: DateTimeFilter<"RotationWeekend"> | Date | string
    dateFin?: DateTimeFilter<"RotationWeekend"> | Date | string
    semaineNumero?: IntFilter<"RotationWeekend"> | number
    annee?: IntFilter<"RotationWeekend"> | number
    responsableId?: StringFilter<"RotationWeekend"> | string
    substitutId?: StringNullableFilter<"RotationWeekend"> | string | null
    status?: EnumStatutRotationFilter<"RotationWeekend"> | $Enums.StatutRotation
    nbSeancesTotal?: IntFilter<"RotationWeekend"> | number
    nbSeancesRealisees?: IntFilter<"RotationWeekend"> | number
    commentaire?: StringNullableFilter<"RotationWeekend"> | string | null
    estAbsence?: BoolFilter<"RotationWeekend"> | boolean
    notificationEnvoyee?: BoolFilter<"RotationWeekend"> | boolean
    rappelEnvoye?: BoolFilter<"RotationWeekend"> | boolean
    createdAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    updatedAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    createdBy?: StringNullableFilter<"RotationWeekend"> | string | null
    responsable?: XOR<UserRelationFilter, UserWhereInput>
    substitut?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    rapportSupervision?: XOR<RapportSupervisionNullableRelationFilter, RapportSupervisionWhereInput> | null
  }, "id" | "dateDebut_responsableId">

  export type RotationWeekendOrderByWithAggregationInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    semaineNumero?: SortOrder
    annee?: SortOrder
    responsableId?: SortOrder
    substitutId?: SortOrderInput | SortOrder
    status?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
    commentaire?: SortOrderInput | SortOrder
    estAbsence?: SortOrder
    notificationEnvoyee?: SortOrder
    rappelEnvoye?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: RotationWeekendCountOrderByAggregateInput
    _avg?: RotationWeekendAvgOrderByAggregateInput
    _max?: RotationWeekendMaxOrderByAggregateInput
    _min?: RotationWeekendMinOrderByAggregateInput
    _sum?: RotationWeekendSumOrderByAggregateInput
  }

  export type RotationWeekendScalarWhereWithAggregatesInput = {
    AND?: RotationWeekendScalarWhereWithAggregatesInput | RotationWeekendScalarWhereWithAggregatesInput[]
    OR?: RotationWeekendScalarWhereWithAggregatesInput[]
    NOT?: RotationWeekendScalarWhereWithAggregatesInput | RotationWeekendScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RotationWeekend"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"RotationWeekend"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"RotationWeekend"> | Date | string
    semaineNumero?: IntWithAggregatesFilter<"RotationWeekend"> | number
    annee?: IntWithAggregatesFilter<"RotationWeekend"> | number
    responsableId?: StringWithAggregatesFilter<"RotationWeekend"> | string
    substitutId?: StringNullableWithAggregatesFilter<"RotationWeekend"> | string | null
    status?: EnumStatutRotationWithAggregatesFilter<"RotationWeekend"> | $Enums.StatutRotation
    nbSeancesTotal?: IntWithAggregatesFilter<"RotationWeekend"> | number
    nbSeancesRealisees?: IntWithAggregatesFilter<"RotationWeekend"> | number
    commentaire?: StringNullableWithAggregatesFilter<"RotationWeekend"> | string | null
    estAbsence?: BoolWithAggregatesFilter<"RotationWeekend"> | boolean
    notificationEnvoyee?: BoolWithAggregatesFilter<"RotationWeekend"> | boolean
    rappelEnvoye?: BoolWithAggregatesFilter<"RotationWeekend"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RotationWeekend"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RotationWeekend"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"RotationWeekend"> | string | null
  }

  export type DisponibiliteResponsableWhereInput = {
    AND?: DisponibiliteResponsableWhereInput | DisponibiliteResponsableWhereInput[]
    OR?: DisponibiliteResponsableWhereInput[]
    NOT?: DisponibiliteResponsableWhereInput | DisponibiliteResponsableWhereInput[]
    id?: StringFilter<"DisponibiliteResponsable"> | string
    responsableId?: StringFilter<"DisponibiliteResponsable"> | string
    dateDebut?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    dateFin?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    disponible?: BoolFilter<"DisponibiliteResponsable"> | boolean
    raison?: StringNullableFilter<"DisponibiliteResponsable"> | string | null
    createdAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    responsable?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DisponibiliteResponsableOrderByWithRelationInput = {
    id?: SortOrder
    responsableId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    disponible?: SortOrder
    raison?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    responsable?: UserOrderByWithRelationInput
  }

  export type DisponibiliteResponsableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisponibiliteResponsableWhereInput | DisponibiliteResponsableWhereInput[]
    OR?: DisponibiliteResponsableWhereInput[]
    NOT?: DisponibiliteResponsableWhereInput | DisponibiliteResponsableWhereInput[]
    responsableId?: StringFilter<"DisponibiliteResponsable"> | string
    dateDebut?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    dateFin?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    disponible?: BoolFilter<"DisponibiliteResponsable"> | boolean
    raison?: StringNullableFilter<"DisponibiliteResponsable"> | string | null
    createdAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    responsable?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DisponibiliteResponsableOrderByWithAggregationInput = {
    id?: SortOrder
    responsableId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    disponible?: SortOrder
    raison?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisponibiliteResponsableCountOrderByAggregateInput
    _max?: DisponibiliteResponsableMaxOrderByAggregateInput
    _min?: DisponibiliteResponsableMinOrderByAggregateInput
  }

  export type DisponibiliteResponsableScalarWhereWithAggregatesInput = {
    AND?: DisponibiliteResponsableScalarWhereWithAggregatesInput | DisponibiliteResponsableScalarWhereWithAggregatesInput[]
    OR?: DisponibiliteResponsableScalarWhereWithAggregatesInput[]
    NOT?: DisponibiliteResponsableScalarWhereWithAggregatesInput | DisponibiliteResponsableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisponibiliteResponsable"> | string
    responsableId?: StringWithAggregatesFilter<"DisponibiliteResponsable"> | string
    dateDebut?: DateTimeWithAggregatesFilter<"DisponibiliteResponsable"> | Date | string
    dateFin?: DateTimeWithAggregatesFilter<"DisponibiliteResponsable"> | Date | string
    disponible?: BoolWithAggregatesFilter<"DisponibiliteResponsable"> | boolean
    raison?: StringNullableWithAggregatesFilter<"DisponibiliteResponsable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DisponibiliteResponsable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DisponibiliteResponsable"> | Date | string
  }

  export type RapportSupervisionWhereInput = {
    AND?: RapportSupervisionWhereInput | RapportSupervisionWhereInput[]
    OR?: RapportSupervisionWhereInput[]
    NOT?: RapportSupervisionWhereInput | RapportSupervisionWhereInput[]
    id?: StringFilter<"RapportSupervision"> | string
    rotationId?: StringFilter<"RapportSupervision"> | string
    heureArrivee?: StringNullableFilter<"RapportSupervision"> | string | null
    heureDepart?: StringNullableFilter<"RapportSupervision"> | string | null
    nbSeancesVisitees?: IntFilter<"RapportSupervision"> | number
    incidents?: StringNullableFilter<"RapportSupervision"> | string | null
    observations?: StringNullableFilter<"RapportSupervision"> | string | null
    recommandations?: StringNullableFilter<"RapportSupervision"> | string | null
    satisfaction?: IntNullableFilter<"RapportSupervision"> | number | null
    createdAt?: DateTimeFilter<"RapportSupervision"> | Date | string
    updatedAt?: DateTimeFilter<"RapportSupervision"> | Date | string
    rotation?: XOR<RotationWeekendRelationFilter, RotationWeekendWhereInput>
  }

  export type RapportSupervisionOrderByWithRelationInput = {
    id?: SortOrder
    rotationId?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    nbSeancesVisitees?: SortOrder
    incidents?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    recommandations?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rotation?: RotationWeekendOrderByWithRelationInput
  }

  export type RapportSupervisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    rotationId?: string
    AND?: RapportSupervisionWhereInput | RapportSupervisionWhereInput[]
    OR?: RapportSupervisionWhereInput[]
    NOT?: RapportSupervisionWhereInput | RapportSupervisionWhereInput[]
    heureArrivee?: StringNullableFilter<"RapportSupervision"> | string | null
    heureDepart?: StringNullableFilter<"RapportSupervision"> | string | null
    nbSeancesVisitees?: IntFilter<"RapportSupervision"> | number
    incidents?: StringNullableFilter<"RapportSupervision"> | string | null
    observations?: StringNullableFilter<"RapportSupervision"> | string | null
    recommandations?: StringNullableFilter<"RapportSupervision"> | string | null
    satisfaction?: IntNullableFilter<"RapportSupervision"> | number | null
    createdAt?: DateTimeFilter<"RapportSupervision"> | Date | string
    updatedAt?: DateTimeFilter<"RapportSupervision"> | Date | string
    rotation?: XOR<RotationWeekendRelationFilter, RotationWeekendWhereInput>
  }, "id" | "rotationId">

  export type RapportSupervisionOrderByWithAggregationInput = {
    id?: SortOrder
    rotationId?: SortOrder
    heureArrivee?: SortOrderInput | SortOrder
    heureDepart?: SortOrderInput | SortOrder
    nbSeancesVisitees?: SortOrder
    incidents?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    recommandations?: SortOrderInput | SortOrder
    satisfaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RapportSupervisionCountOrderByAggregateInput
    _avg?: RapportSupervisionAvgOrderByAggregateInput
    _max?: RapportSupervisionMaxOrderByAggregateInput
    _min?: RapportSupervisionMinOrderByAggregateInput
    _sum?: RapportSupervisionSumOrderByAggregateInput
  }

  export type RapportSupervisionScalarWhereWithAggregatesInput = {
    AND?: RapportSupervisionScalarWhereWithAggregatesInput | RapportSupervisionScalarWhereWithAggregatesInput[]
    OR?: RapportSupervisionScalarWhereWithAggregatesInput[]
    NOT?: RapportSupervisionScalarWhereWithAggregatesInput | RapportSupervisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RapportSupervision"> | string
    rotationId?: StringWithAggregatesFilter<"RapportSupervision"> | string
    heureArrivee?: StringNullableWithAggregatesFilter<"RapportSupervision"> | string | null
    heureDepart?: StringNullableWithAggregatesFilter<"RapportSupervision"> | string | null
    nbSeancesVisitees?: IntWithAggregatesFilter<"RapportSupervision"> | number
    incidents?: StringNullableWithAggregatesFilter<"RapportSupervision"> | string | null
    observations?: StringNullableWithAggregatesFilter<"RapportSupervision"> | string | null
    recommandations?: StringNullableWithAggregatesFilter<"RapportSupervision"> | string | null
    satisfaction?: IntNullableWithAggregatesFilter<"RapportSupervision"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RapportSupervision"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RapportSupervision"> | Date | string
  }

  export type StatistiqueRotationWhereInput = {
    AND?: StatistiqueRotationWhereInput | StatistiqueRotationWhereInput[]
    OR?: StatistiqueRotationWhereInput[]
    NOT?: StatistiqueRotationWhereInput | StatistiqueRotationWhereInput[]
    id?: StringFilter<"StatistiqueRotation"> | string
    responsableId?: StringFilter<"StatistiqueRotation"> | string
    annee?: IntFilter<"StatistiqueRotation"> | number
    mois?: IntNullableFilter<"StatistiqueRotation"> | number | null
    nbWeekendTotal?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendRealises?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendAbsences?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendSubstitut?: IntFilter<"StatistiqueRotation"> | number
    tauxPresence?: FloatFilter<"StatistiqueRotation"> | number
    nbSeancesTotal?: IntFilter<"StatistiqueRotation"> | number
    moyenneSatisfaction?: FloatNullableFilter<"StatistiqueRotation"> | number | null
    createdAt?: DateTimeFilter<"StatistiqueRotation"> | Date | string
    updatedAt?: DateTimeFilter<"StatistiqueRotation"> | Date | string
  }

  export type StatistiqueRotationOrderByWithRelationInput = {
    id?: SortOrder
    responsableId?: SortOrder
    annee?: SortOrder
    mois?: SortOrderInput | SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatistiqueRotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    responsableId_annee_mois?: StatistiqueRotationResponsableIdAnneeMoisCompoundUniqueInput
    AND?: StatistiqueRotationWhereInput | StatistiqueRotationWhereInput[]
    OR?: StatistiqueRotationWhereInput[]
    NOT?: StatistiqueRotationWhereInput | StatistiqueRotationWhereInput[]
    responsableId?: StringFilter<"StatistiqueRotation"> | string
    annee?: IntFilter<"StatistiqueRotation"> | number
    mois?: IntNullableFilter<"StatistiqueRotation"> | number | null
    nbWeekendTotal?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendRealises?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendAbsences?: IntFilter<"StatistiqueRotation"> | number
    nbWeekendSubstitut?: IntFilter<"StatistiqueRotation"> | number
    tauxPresence?: FloatFilter<"StatistiqueRotation"> | number
    nbSeancesTotal?: IntFilter<"StatistiqueRotation"> | number
    moyenneSatisfaction?: FloatNullableFilter<"StatistiqueRotation"> | number | null
    createdAt?: DateTimeFilter<"StatistiqueRotation"> | Date | string
    updatedAt?: DateTimeFilter<"StatistiqueRotation"> | Date | string
  }, "id" | "responsableId_annee_mois">

  export type StatistiqueRotationOrderByWithAggregationInput = {
    id?: SortOrder
    responsableId?: SortOrder
    annee?: SortOrder
    mois?: SortOrderInput | SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StatistiqueRotationCountOrderByAggregateInput
    _avg?: StatistiqueRotationAvgOrderByAggregateInput
    _max?: StatistiqueRotationMaxOrderByAggregateInput
    _min?: StatistiqueRotationMinOrderByAggregateInput
    _sum?: StatistiqueRotationSumOrderByAggregateInput
  }

  export type StatistiqueRotationScalarWhereWithAggregatesInput = {
    AND?: StatistiqueRotationScalarWhereWithAggregatesInput | StatistiqueRotationScalarWhereWithAggregatesInput[]
    OR?: StatistiqueRotationScalarWhereWithAggregatesInput[]
    NOT?: StatistiqueRotationScalarWhereWithAggregatesInput | StatistiqueRotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatistiqueRotation"> | string
    responsableId?: StringWithAggregatesFilter<"StatistiqueRotation"> | string
    annee?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    mois?: IntNullableWithAggregatesFilter<"StatistiqueRotation"> | number | null
    nbWeekendTotal?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    nbWeekendRealises?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    nbWeekendAbsences?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    nbWeekendSubstitut?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    tauxPresence?: FloatWithAggregatesFilter<"StatistiqueRotation"> | number
    nbSeancesTotal?: IntWithAggregatesFilter<"StatistiqueRotation"> | number
    moyenneSatisfaction?: FloatNullableWithAggregatesFilter<"StatistiqueRotation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"StatistiqueRotation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StatistiqueRotation"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    modules?: ModuleCreateNestedManyWithoutUserInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ProgrammeCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutProgrammeInput
    modules?: ModuleCreateNestedManyWithoutProgrammeInput
    user: UserCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUpdateManyWithoutProgrammeNestedInput
    user?: UserUpdateOneRequiredWithoutProgrammesNestedInput
  }

  export type ProgrammeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProgrammeNestedInput
  }

  export type ProgrammeCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgrammeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgrammeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntervenantCreateInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutIntervenantInput
    modules?: ModuleCreateNestedManyWithoutIntervenantInput
    seances?: SeanceCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUncheckedCreateInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantUncheckedCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutIntervenantInput
    modules?: ModuleUncheckedCreateNestedManyWithoutIntervenantInput
    seances?: SeanceUncheckedCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantCreateManyInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
  }

  export type IntervenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntervenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisponibiliteIntervenantCreateInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    intervenant: IntervenantCreateNestedOneWithoutDisponibilitesInput
  }

  export type DisponibiliteIntervenantUncheckedCreateInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteIntervenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervenant?: IntervenantUpdateOneRequiredWithoutDisponibilitesNestedInput
  }

  export type DisponibiliteIntervenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteIntervenantCreateManyInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteIntervenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteIntervenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalleCreateInput = {
    id?: string
    nom: string
    batiment: string
    capacite: number
    equipements?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalleUncheckedCreateInput = {
    id?: string
    nom: string
    batiment: string
    capacite: number
    equipements?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    batiment?: StringFieldUpdateOperationsInput | string
    capacite?: IntFieldUpdateOperationsInput | number
    equipements?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    batiment?: StringFieldUpdateOperationsInput | string
    capacite?: IntFieldUpdateOperationsInput | number
    equipements?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalleCreateManyInput = {
    id?: string
    nom: string
    batiment: string
    capacite: number
    equipements?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    batiment?: StringFieldUpdateOperationsInput | string
    capacite?: IntFieldUpdateOperationsInput | number
    equipements?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    batiment?: StringFieldUpdateOperationsInput | string
    capacite?: IntFieldUpdateOperationsInput | number
    equipements?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeanceCreateInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitCreateNestedManyWithoutSeance2Input
    intervenant: IntervenantCreateNestedOneWithoutSeancesInput
    module: ModuleCreateNestedOneWithoutSeancesInput
  }

  export type SeanceUncheckedCreateInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitUncheckedCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitUncheckedCreateNestedManyWithoutSeance2Input
  }

  export type SeanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUpdateManyWithoutSeance2NestedInput
    intervenant?: IntervenantUpdateOneRequiredWithoutSeancesNestedInput
    module?: ModuleUpdateOneRequiredWithoutSeancesNestedInput
  }

  export type SeanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUncheckedUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUncheckedUpdateManyWithoutSeance2NestedInput
  }

  export type SeanceCreateManyInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
  }

  export type SeanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConflitCreateInput = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
    seance1: SeanceCreateNestedOneWithoutConflitsAsSeance1Input
    seance2?: SeanceCreateNestedOneWithoutConflitsAsSeance2Input
  }

  export type ConflitUncheckedCreateInput = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId1: string
    seanceId2?: string | null
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
    seance1?: SeanceUpdateOneRequiredWithoutConflitsAsSeance1NestedInput
    seance2?: SeanceUpdateOneWithoutConflitsAsSeance2NestedInput
  }

  export type ConflitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId1?: StringFieldUpdateOperationsInput | string
    seanceId2?: NullableStringFieldUpdateOperationsInput | string | null
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ConflitCreateManyInput = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId1: string
    seanceId2?: string | null
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ConflitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId1?: StringFieldUpdateOperationsInput | string
    seanceId2?: NullableStringFieldUpdateOperationsInput | string | null
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type PeriodeAcademiqueCreateInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutPeriodeInput
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueUncheckedCreateInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutPeriodeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutPeriodeNestedInput
  }

  export type PeriodeAcademiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput
  }

  export type PeriodeAcademiqueCreateManyInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PeriodeAcademiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PeriodeAcademiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalActiviteCreateInput = {
    id?: string
    action: $Enums.ActionType
    entite: string
    entiteId: string
    description: string
    ancienneValeur?: string | null
    nouvelleValeur?: string | null
    userId: string
    userName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type JournalActiviteUncheckedCreateInput = {
    id?: string
    action: $Enums.ActionType
    entite: string
    entiteId: string
    description: string
    ancienneValeur?: string | null
    nouvelleValeur?: string | null
    userId: string
    userName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type JournalActiviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entite?: StringFieldUpdateOperationsInput | string
    entiteId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ancienneValeur?: NullableStringFieldUpdateOperationsInput | string | null
    nouvelleValeur?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalActiviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entite?: StringFieldUpdateOperationsInput | string
    entiteId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ancienneValeur?: NullableStringFieldUpdateOperationsInput | string | null
    nouvelleValeur?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalActiviteCreateManyInput = {
    id?: string
    action: $Enums.ActionType
    entite: string
    entiteId: string
    description: string
    ancienneValeur?: string | null
    nouvelleValeur?: string | null
    userId: string
    userName?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type JournalActiviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entite?: StringFieldUpdateOperationsInput | string
    entiteId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ancienneValeur?: NullableStringFieldUpdateOperationsInput | string | null
    nouvelleValeur?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JournalActiviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    entite?: StringFieldUpdateOperationsInput | string
    entiteId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ancienneValeur?: NullableStringFieldUpdateOperationsInput | string | null
    nouvelleValeur?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueCreateInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    periode: PeriodeAcademiqueCreateNestedOneWithoutActivitesAcademiquesInput
    programme: ProgrammeCreateNestedOneWithoutActivitesAcademiquesInput
  }

  export type ActiviteAcademiqueUncheckedCreateInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    programmeId: string
    periodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periode?: PeriodeAcademiqueUpdateOneRequiredWithoutActivitesAcademiquesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutActivitesAcademiquesNestedInput
  }

  export type ActiviteAcademiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueCreateManyInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    programmeId: string
    periodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueCreateInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    periode: PeriodeAcademiqueCreateNestedOneWithoutIndicateursAcademiquesInput
    programme: ProgrammeCreateNestedOneWithoutIndicateursAcademiquesInput
    responsable?: UserCreateNestedOneWithoutIndicateursAcademiquesInput
  }

  export type IndicateurAcademiqueUncheckedCreateInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    periodeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periode?: PeriodeAcademiqueUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
    responsable?: UserUpdateOneWithoutIndicateursAcademiquesNestedInput
  }

  export type IndicateurAcademiqueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueCreateManyInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    periodeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantCreateInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutResultatsEtudiantsInput
  }

  export type ResultatEtudiantUncheckedCreateInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    moduleId: string
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatEtudiantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutResultatsEtudiantsNestedInput
  }

  export type ResultatEtudiantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantCreateManyInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    moduleId: string
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatEtudiantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    moduleId?: StringFieldUpdateOperationsInput | string
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementCreateInput = {
    id?: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
    intervenant: IntervenantCreateNestedOneWithoutEvaluationsInput
    module: ModuleCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationEnseignementUncheckedCreateInput = {
    id?: string
    moduleId: string
    intervenantId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationEnseignementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervenant?: IntervenantUpdateOneRequiredWithoutEvaluationsNestedInput
    module?: ModuleUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationEnseignementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementCreateManyInput = {
    id?: string
    moduleId: string
    intervenantId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationEnseignementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    titre: string
    message: string
    type: $Enums.TypeNotification
    priorite?: $Enums.PrioriteNotification
    lu?: boolean
    destinataireId: string
    entite?: string | null
    entiteId?: string | null
    lienAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    titre: string
    message: string
    type: $Enums.TypeNotification
    priorite?: $Enums.PrioriteNotification
    lu?: boolean
    destinataireId: string
    entite?: string | null
    entiteId?: string | null
    lienAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFieldUpdateOperationsInput | $Enums.PrioriteNotification
    lu?: BoolFieldUpdateOperationsInput | boolean
    destinataireId?: StringFieldUpdateOperationsInput | string
    entite?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableStringFieldUpdateOperationsInput | string | null
    lienAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFieldUpdateOperationsInput | $Enums.PrioriteNotification
    lu?: BoolFieldUpdateOperationsInput | boolean
    destinataireId?: StringFieldUpdateOperationsInput | string
    entite?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableStringFieldUpdateOperationsInput | string | null
    lienAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    titre: string
    message: string
    type: $Enums.TypeNotification
    priorite?: $Enums.PrioriteNotification
    lu?: boolean
    destinataireId: string
    entite?: string | null
    entiteId?: string | null
    lienAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFieldUpdateOperationsInput | $Enums.PrioriteNotification
    lu?: BoolFieldUpdateOperationsInput | boolean
    destinataireId?: StringFieldUpdateOperationsInput | string
    entite?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableStringFieldUpdateOperationsInput | string | null
    lienAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titre?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeNotificationFieldUpdateOperationsInput | $Enums.TypeNotification
    priorite?: EnumPrioriteNotificationFieldUpdateOperationsInput | $Enums.PrioriteNotification
    lu?: BoolFieldUpdateOperationsInput | boolean
    destinataireId?: StringFieldUpdateOperationsInput | string
    entite?: NullableStringFieldUpdateOperationsInput | string | null
    entiteId?: NullableStringFieldUpdateOperationsInput | string | null
    lienAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RotationWeekendCreateInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    responsable: UserCreateNestedOneWithoutRotationsResponsableInput
    substitut?: UserCreateNestedOneWithoutRotationsSubstitutInput
    rapportSupervision?: RapportSupervisionCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendUncheckedCreateInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    responsableId: string
    substitutId?: string | null
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    rapportSupervision?: RapportSupervisionUncheckedCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: UserUpdateOneRequiredWithoutRotationsResponsableNestedInput
    substitut?: UserUpdateOneWithoutRotationsSubstitutNestedInput
    rapportSupervision?: RapportSupervisionUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    responsableId?: StringFieldUpdateOperationsInput | string
    substitutId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    rapportSupervision?: RapportSupervisionUncheckedUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendCreateManyInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    responsableId: string
    substitutId?: string | null
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RotationWeekendUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RotationWeekendUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    responsableId?: StringFieldUpdateOperationsInput | string
    substitutId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisponibiliteResponsableCreateInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responsable: UserCreateNestedOneWithoutDisponibilitesInput
  }

  export type DisponibiliteResponsableUncheckedCreateInput = {
    id?: string
    responsableId: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteResponsableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responsable?: UserUpdateOneRequiredWithoutDisponibilitesNestedInput
  }

  export type DisponibiliteResponsableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteResponsableCreateManyInput = {
    id?: string
    responsableId: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteResponsableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteResponsableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportSupervisionCreateInput = {
    id?: string
    heureArrivee?: string | null
    heureDepart?: string | null
    nbSeancesVisitees?: number
    incidents?: string | null
    observations?: string | null
    recommandations?: string | null
    satisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rotation: RotationWeekendCreateNestedOneWithoutRapportSupervisionInput
  }

  export type RapportSupervisionUncheckedCreateInput = {
    id?: string
    rotationId: string
    heureArrivee?: string | null
    heureDepart?: string | null
    nbSeancesVisitees?: number
    incidents?: string | null
    observations?: string | null
    recommandations?: string | null
    satisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportSupervisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rotation?: RotationWeekendUpdateOneRequiredWithoutRapportSupervisionNestedInput
  }

  export type RapportSupervisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationId?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportSupervisionCreateManyInput = {
    id?: string
    rotationId: string
    heureArrivee?: string | null
    heureDepart?: string | null
    nbSeancesVisitees?: number
    incidents?: string | null
    observations?: string | null
    recommandations?: string | null
    satisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportSupervisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportSupervisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rotationId?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatistiqueRotationCreateInput = {
    id?: string
    responsableId: string
    annee: number
    mois?: number | null
    nbWeekendTotal?: number
    nbWeekendRealises?: number
    nbWeekendAbsences?: number
    nbWeekendSubstitut?: number
    tauxPresence?: number
    nbSeancesTotal?: number
    moyenneSatisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatistiqueRotationUncheckedCreateInput = {
    id?: string
    responsableId: string
    annee: number
    mois?: number | null
    nbWeekendTotal?: number
    nbWeekendRealises?: number
    nbWeekendAbsences?: number
    nbWeekendSubstitut?: number
    tauxPresence?: number
    nbSeancesTotal?: number
    moyenneSatisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatistiqueRotationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    nbWeekendTotal?: IntFieldUpdateOperationsInput | number
    nbWeekendRealises?: IntFieldUpdateOperationsInput | number
    nbWeekendAbsences?: IntFieldUpdateOperationsInput | number
    nbWeekendSubstitut?: IntFieldUpdateOperationsInput | number
    tauxPresence?: FloatFieldUpdateOperationsInput | number
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    moyenneSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatistiqueRotationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    nbWeekendTotal?: IntFieldUpdateOperationsInput | number
    nbWeekendRealises?: IntFieldUpdateOperationsInput | number
    nbWeekendAbsences?: IntFieldUpdateOperationsInput | number
    nbWeekendSubstitut?: IntFieldUpdateOperationsInput | number
    tauxPresence?: FloatFieldUpdateOperationsInput | number
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    moyenneSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatistiqueRotationCreateManyInput = {
    id?: string
    responsableId: string
    annee: number
    mois?: number | null
    nbWeekendTotal?: number
    nbWeekendRealises?: number
    nbWeekendAbsences?: number
    nbWeekendSubstitut?: number
    tauxPresence?: number
    nbSeancesTotal?: number
    moyenneSatisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatistiqueRotationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    nbWeekendTotal?: IntFieldUpdateOperationsInput | number
    nbWeekendRealises?: IntFieldUpdateOperationsInput | number
    nbWeekendAbsences?: IntFieldUpdateOperationsInput | number
    nbWeekendSubstitut?: IntFieldUpdateOperationsInput | number
    tauxPresence?: FloatFieldUpdateOperationsInput | number
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    moyenneSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatistiqueRotationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responsableId?: StringFieldUpdateOperationsInput | string
    annee?: IntFieldUpdateOperationsInput | number
    mois?: NullableIntFieldUpdateOperationsInput | number | null
    nbWeekendTotal?: IntFieldUpdateOperationsInput | number
    nbWeekendRealises?: IntFieldUpdateOperationsInput | number
    nbWeekendAbsences?: IntFieldUpdateOperationsInput | number
    nbWeekendSubstitut?: IntFieldUpdateOperationsInput | number
    tauxPresence?: FloatFieldUpdateOperationsInput | number
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    moyenneSatisfaction?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IndicateurAcademiqueListRelationFilter = {
    every?: IndicateurAcademiqueWhereInput
    some?: IndicateurAcademiqueWhereInput
    none?: IndicateurAcademiqueWhereInput
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type ProgrammeListRelationFilter = {
    every?: ProgrammeWhereInput
    some?: ProgrammeWhereInput
    none?: ProgrammeWhereInput
  }

  export type RotationWeekendListRelationFilter = {
    every?: RotationWeekendWhereInput
    some?: RotationWeekendWhereInput
    none?: RotationWeekendWhereInput
  }

  export type DisponibiliteResponsableListRelationFilter = {
    every?: DisponibiliteResponsableWhereInput
    some?: DisponibiliteResponsableWhereInput
    none?: DisponibiliteResponsableWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type IndicateurAcademiqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgrammeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RotationWeekendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisponibiliteResponsableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    password?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumSemestreFilter<$PrismaModel = never> = {
    equals?: $Enums.Semestre | EnumSemestreFieldRefInput<$PrismaModel>
    in?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    not?: NestedEnumSemestreFilter<$PrismaModel> | $Enums.Semestre
  }

  export type EnumStatusProgrammeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusProgramme | EnumStatusProgrammeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusProgrammeFilter<$PrismaModel> | $Enums.StatusProgramme
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ActiviteAcademiqueListRelationFilter = {
    every?: ActiviteAcademiqueWhereInput
    some?: ActiviteAcademiqueWhereInput
    none?: ActiviteAcademiqueWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ActiviteAcademiqueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgrammeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semestre?: SortOrder
    niveau?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    totalVHT?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgrammeAvgOrderByAggregateInput = {
    progression?: SortOrder
    totalVHT?: SortOrder
  }

  export type ProgrammeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semestre?: SortOrder
    niveau?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    totalVHT?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgrammeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    semestre?: SortOrder
    niveau?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    totalVHT?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProgrammeSumOrderByAggregateInput = {
    progression?: SortOrder
    totalVHT?: SortOrder
  }

  export type EnumSemestreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Semestre | EnumSemestreFieldRefInput<$PrismaModel>
    in?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    not?: NestedEnumSemestreWithAggregatesFilter<$PrismaModel> | $Enums.Semestre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSemestreFilter<$PrismaModel>
    _max?: NestedEnumSemestreFilter<$PrismaModel>
  }

  export type EnumStatusProgrammeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusProgramme | EnumStatusProgrammeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusProgrammeWithAggregatesFilter<$PrismaModel> | $Enums.StatusProgramme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusProgrammeFilter<$PrismaModel>
    _max?: NestedEnumStatusProgrammeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DisponibiliteIntervenantListRelationFilter = {
    every?: DisponibiliteIntervenantWhereInput
    some?: DisponibiliteIntervenantWhereInput
    none?: DisponibiliteIntervenantWhereInput
  }

  export type EvaluationEnseignementListRelationFilter = {
    every?: EvaluationEnseignementWhereInput
    some?: EvaluationEnseignementWhereInput
    none?: EvaluationEnseignementWhereInput
  }

  export type SeanceListRelationFilter = {
    every?: SeanceWhereInput
    some?: SeanceWhereInput
    none?: SeanceWhereInput
  }

  export type DisponibiliteIntervenantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationEnseignementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntervenantCountOrderByAggregateInput = {
    id?: SortOrder
    civilite?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    grade?: SortOrder
    specialite?: SortOrder
    etablissement?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creneauxPreferences?: SortOrder
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
    joursPreferences?: SortOrder
  }

  export type IntervenantAvgOrderByAggregateInput = {
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
  }

  export type IntervenantMaxOrderByAggregateInput = {
    id?: SortOrder
    civilite?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    grade?: SortOrder
    specialite?: SortOrder
    etablissement?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creneauxPreferences?: SortOrder
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
    joursPreferences?: SortOrder
  }

  export type IntervenantMinOrderByAggregateInput = {
    id?: SortOrder
    civilite?: SortOrder
    nom?: SortOrder
    prenom?: SortOrder
    email?: SortOrder
    telephone?: SortOrder
    grade?: SortOrder
    specialite?: SortOrder
    etablissement?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creneauxPreferences?: SortOrder
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
    joursPreferences?: SortOrder
  }

  export type IntervenantSumOrderByAggregateInput = {
    heuresMaxJour?: SortOrder
    heuresMaxSemaine?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTypeDisponibiliteFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDisponibilite | EnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDisponibiliteFilter<$PrismaModel> | $Enums.TypeDisponibilite
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntervenantRelationFilter = {
    is?: IntervenantWhereInput
    isNot?: IntervenantWhereInput
  }

  export type DisponibiliteIntervenantCountOrderByAggregateInput = {
    id?: SortOrder
    jourSemaine?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    recurrent?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibiliteIntervenantAvgOrderByAggregateInput = {
    jourSemaine?: SortOrder
  }

  export type DisponibiliteIntervenantMaxOrderByAggregateInput = {
    id?: SortOrder
    jourSemaine?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    recurrent?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibiliteIntervenantMinOrderByAggregateInput = {
    id?: SortOrder
    jourSemaine?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    type?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    recurrent?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibiliteIntervenantSumOrderByAggregateInput = {
    jourSemaine?: SortOrder
  }

  export type EnumTypeDisponibiliteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDisponibilite | EnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDisponibiliteWithAggregatesFilter<$PrismaModel> | $Enums.TypeDisponibilite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeDisponibiliteFilter<$PrismaModel>
    _max?: NestedEnumTypeDisponibiliteFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumStatusModuleFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusModule | EnumStatusModuleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusModuleFilter<$PrismaModel> | $Enums.StatusModule
  }

  export type IntervenantNullableRelationFilter = {
    is?: IntervenantWhereInput | null
    isNot?: IntervenantWhereInput | null
  }

  export type ProgrammeRelationFilter = {
    is?: ProgrammeWhereInput
    isNot?: ProgrammeWhereInput
  }

  export type ResultatEtudiantListRelationFilter = {
    every?: ResultatEtudiantWhereInput
    some?: ResultatEtudiantWhereInput
    none?: ResultatEtudiantWhereInput
  }

  export type ResultatEtudiantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    programmeId?: SortOrder
    intervenantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    progression?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    programmeId?: SortOrder
    intervenantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    status?: SortOrder
    progression?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    programmeId?: SortOrder
    intervenantId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    cm?: SortOrder
    td?: SortOrder
    tp?: SortOrder
    tpe?: SortOrder
    vht?: SortOrder
    coefficient?: SortOrder
    credits?: SortOrder
    progression?: SortOrder
  }

  export type EnumStatusModuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusModule | EnumStatusModuleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusModuleWithAggregatesFilter<$PrismaModel> | $Enums.StatusModule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusModuleFilter<$PrismaModel>
    _max?: NestedEnumStatusModuleFilter<$PrismaModel>
  }

  export type SalleCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    batiment?: SortOrder
    capacite?: SortOrder
    equipements?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalleAvgOrderByAggregateInput = {
    capacite?: SortOrder
  }

  export type SalleMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    batiment?: SortOrder
    capacite?: SortOrder
    equipements?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalleMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    batiment?: SortOrder
    capacite?: SortOrder
    equipements?: SortOrder
    disponible?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalleSumOrderByAggregateInput = {
    capacite?: SortOrder
  }

  export type EnumTypeSeanceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeSeance | EnumTypeSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeSeanceFilter<$PrismaModel> | $Enums.TypeSeance
  }

  export type EnumStatusSeanceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusSeance | EnumStatusSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusSeanceFilter<$PrismaModel> | $Enums.StatusSeance
  }

  export type ConflitListRelationFilter = {
    every?: ConflitWhereInput
    some?: ConflitWhereInput
    none?: ConflitWhereInput
  }

  export type ModuleRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ConflitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeanceCountOrderByAggregateInput = {
    id?: SortOrder
    dateSeance?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    duree?: SortOrder
    typeSeance?: SortOrder
    salle?: SortOrder
    batiment?: SortOrder
    status?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    objectifs?: SortOrder
  }

  export type SeanceAvgOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type SeanceMaxOrderByAggregateInput = {
    id?: SortOrder
    dateSeance?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    duree?: SortOrder
    typeSeance?: SortOrder
    salle?: SortOrder
    batiment?: SortOrder
    status?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    objectifs?: SortOrder
  }

  export type SeanceMinOrderByAggregateInput = {
    id?: SortOrder
    dateSeance?: SortOrder
    heureDebut?: SortOrder
    heureFin?: SortOrder
    duree?: SortOrder
    typeSeance?: SortOrder
    salle?: SortOrder
    batiment?: SortOrder
    status?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notes?: SortOrder
    objectifs?: SortOrder
  }

  export type SeanceSumOrderByAggregateInput = {
    duree?: SortOrder
  }

  export type EnumTypeSeanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeSeance | EnumTypeSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeSeanceWithAggregatesFilter<$PrismaModel> | $Enums.TypeSeance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeSeanceFilter<$PrismaModel>
    _max?: NestedEnumTypeSeanceFilter<$PrismaModel>
  }

  export type EnumStatusSeanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusSeance | EnumStatusSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusSeanceWithAggregatesFilter<$PrismaModel> | $Enums.StatusSeance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusSeanceFilter<$PrismaModel>
    _max?: NestedEnumStatusSeanceFilter<$PrismaModel>
  }

  export type EnumTypeConflitFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConflit | EnumTypeConflitFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConflitFilter<$PrismaModel> | $Enums.TypeConflit
  }

  export type EnumSeveriteConflitFilter<$PrismaModel = never> = {
    equals?: $Enums.SeveriteConflit | EnumSeveriteConflitFieldRefInput<$PrismaModel>
    in?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumSeveriteConflitFilter<$PrismaModel> | $Enums.SeveriteConflit
  }

  export type SeanceRelationFilter = {
    is?: SeanceWhereInput
    isNot?: SeanceWhereInput
  }

  export type SeanceNullableRelationFilter = {
    is?: SeanceWhereInput | null
    isNot?: SeanceWhereInput | null
  }

  export type ConflitCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    seanceId1?: SortOrder
    seanceId2?: SortOrder
    ressourceType?: SortOrder
    ressourceId?: SortOrder
    resolu?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resoluLe?: SortOrder
    resoluPar?: SortOrder
    severite?: SortOrder
  }

  export type ConflitMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    seanceId1?: SortOrder
    seanceId2?: SortOrder
    ressourceType?: SortOrder
    ressourceId?: SortOrder
    resolu?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resoluLe?: SortOrder
    resoluPar?: SortOrder
    severite?: SortOrder
  }

  export type ConflitMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    description?: SortOrder
    seanceId1?: SortOrder
    seanceId2?: SortOrder
    ressourceType?: SortOrder
    ressourceId?: SortOrder
    resolu?: SortOrder
    resolution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resoluLe?: SortOrder
    resoluPar?: SortOrder
    severite?: SortOrder
  }

  export type EnumTypeConflitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConflit | EnumTypeConflitFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConflitWithAggregatesFilter<$PrismaModel> | $Enums.TypeConflit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeConflitFilter<$PrismaModel>
    _max?: NestedEnumTypeConflitFilter<$PrismaModel>
  }

  export type EnumSeveriteConflitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeveriteConflit | EnumSeveriteConflitFieldRefInput<$PrismaModel>
    in?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumSeveriteConflitWithAggregatesFilter<$PrismaModel> | $Enums.SeveriteConflit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeveriteConflitFilter<$PrismaModel>
    _max?: NestedEnumSeveriteConflitFilter<$PrismaModel>
  }

  export type PeriodeAcademiqueCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    debutS1?: SortOrder
    finS1?: SortOrder
    debutS2?: SortOrder
    finS2?: SortOrder
    vacancesNoel?: SortOrder
    finVacancesNoel?: SortOrder
    vacancesPaques?: SortOrder
    finVacancesPaques?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PeriodeAcademiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    debutS1?: SortOrder
    finS1?: SortOrder
    debutS2?: SortOrder
    finS2?: SortOrder
    vacancesNoel?: SortOrder
    finVacancesNoel?: SortOrder
    vacancesPaques?: SortOrder
    finVacancesPaques?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PeriodeAcademiqueMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    annee?: SortOrder
    debutS1?: SortOrder
    finS1?: SortOrder
    debutS2?: SortOrder
    finS2?: SortOrder
    vacancesNoel?: SortOrder
    finVacancesNoel?: SortOrder
    vacancesPaques?: SortOrder
    finVacancesPaques?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type JournalActiviteCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    description?: SortOrder
    ancienneValeur?: SortOrder
    nouvelleValeur?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalActiviteMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    description?: SortOrder
    ancienneValeur?: SortOrder
    nouvelleValeur?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type JournalActiviteMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    description?: SortOrder
    ancienneValeur?: SortOrder
    nouvelleValeur?: SortOrder
    userId?: SortOrder
    userName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type PeriodeAcademiqueRelationFilter = {
    is?: PeriodeAcademiqueWhereInput
    isNot?: PeriodeAcademiqueWhereInput
  }

  export type ActiviteAcademiqueCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    datePrevue?: SortOrder
    dateReelle?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActiviteAcademiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    datePrevue?: SortOrder
    dateReelle?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActiviteAcademiqueMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    datePrevue?: SortOrder
    dateReelle?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type IndicateurAcademiqueCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    valeurCible?: SortOrder
    valeurReelle?: SortOrder
    periodicite?: SortOrder
    methodeCalcul?: SortOrder
    unite?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    responsableId?: SortOrder
    dateCollecte?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicateurAcademiqueAvgOrderByAggregateInput = {
    valeurCible?: SortOrder
    valeurReelle?: SortOrder
  }

  export type IndicateurAcademiqueMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    valeurCible?: SortOrder
    valeurReelle?: SortOrder
    periodicite?: SortOrder
    methodeCalcul?: SortOrder
    unite?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    responsableId?: SortOrder
    dateCollecte?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicateurAcademiqueMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    description?: SortOrder
    valeurCible?: SortOrder
    valeurReelle?: SortOrder
    periodicite?: SortOrder
    methodeCalcul?: SortOrder
    unite?: SortOrder
    type?: SortOrder
    programmeId?: SortOrder
    periodeId?: SortOrder
    responsableId?: SortOrder
    dateCollecte?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IndicateurAcademiqueSumOrderByAggregateInput = {
    valeurCible?: SortOrder
    valeurReelle?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ResultatEtudiantNumeroEtudiantModuleIdCompoundUniqueInput = {
    numeroEtudiant: string
    moduleId: string
  }

  export type ResultatEtudiantCountOrderByAggregateInput = {
    id?: SortOrder
    numeroEtudiant?: SortOrder
    nomEtudiant?: SortOrder
    prenomEtudiant?: SortOrder
    emailEtudiant?: SortOrder
    moduleId?: SortOrder
    noteCC?: SortOrder
    noteExamen?: SortOrder
    noteFinale?: SortOrder
    statut?: SortOrder
    mention?: SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultatEtudiantAvgOrderByAggregateInput = {
    noteCC?: SortOrder
    noteExamen?: SortOrder
    noteFinale?: SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrder
  }

  export type ResultatEtudiantMaxOrderByAggregateInput = {
    id?: SortOrder
    numeroEtudiant?: SortOrder
    nomEtudiant?: SortOrder
    prenomEtudiant?: SortOrder
    emailEtudiant?: SortOrder
    moduleId?: SortOrder
    noteCC?: SortOrder
    noteExamen?: SortOrder
    noteFinale?: SortOrder
    statut?: SortOrder
    mention?: SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultatEtudiantMinOrderByAggregateInput = {
    id?: SortOrder
    numeroEtudiant?: SortOrder
    nomEtudiant?: SortOrder
    prenomEtudiant?: SortOrder
    emailEtudiant?: SortOrder
    moduleId?: SortOrder
    noteCC?: SortOrder
    noteExamen?: SortOrder
    noteFinale?: SortOrder
    statut?: SortOrder
    mention?: SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResultatEtudiantSumOrderByAggregateInput = {
    noteCC?: SortOrder
    noteExamen?: SortOrder
    noteFinale?: SortOrder
    vhDeroule?: SortOrder
    progressionPct?: SortOrder
    presences?: SortOrder
    absences?: SortOrder
    tauxPresence?: SortOrder
  }

  export type EnumStatutCampagneFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCampagne | EnumStatutCampagneFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCampagneFilter<$PrismaModel> | $Enums.StatutCampagne
  }

  export type EvaluationEnseignementCountOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    dateEnvoi?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lienEvaluation?: SortOrder
    noteQualiteCours?: SortOrder
    noteQualitePedagogie?: SortOrder
    noteDisponibilite?: SortOrder
    noteMoyenne?: SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrder
    commentaires?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationEnseignementAvgOrderByAggregateInput = {
    noteQualiteCours?: SortOrder
    noteQualitePedagogie?: SortOrder
    noteDisponibilite?: SortOrder
    noteMoyenne?: SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrder
  }

  export type EvaluationEnseignementMaxOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    dateEnvoi?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lienEvaluation?: SortOrder
    noteQualiteCours?: SortOrder
    noteQualitePedagogie?: SortOrder
    noteDisponibilite?: SortOrder
    noteMoyenne?: SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrder
    commentaires?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationEnseignementMinOrderByAggregateInput = {
    id?: SortOrder
    moduleId?: SortOrder
    intervenantId?: SortOrder
    dateEnvoi?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    lienEvaluation?: SortOrder
    noteQualiteCours?: SortOrder
    noteQualitePedagogie?: SortOrder
    noteDisponibilite?: SortOrder
    noteMoyenne?: SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrder
    commentaires?: SortOrder
    statut?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvaluationEnseignementSumOrderByAggregateInput = {
    noteQualiteCours?: SortOrder
    noteQualitePedagogie?: SortOrder
    noteDisponibilite?: SortOrder
    noteMoyenne?: SortOrder
    nombreReponses?: SortOrder
    nombreInvitations?: SortOrder
    tauxParticipation?: SortOrder
  }

  export type EnumStatutCampagneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCampagne | EnumStatutCampagneFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCampagneWithAggregatesFilter<$PrismaModel> | $Enums.StatutCampagne
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCampagneFilter<$PrismaModel>
    _max?: NestedEnumStatutCampagneFilter<$PrismaModel>
  }

  export type EnumTypeNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeNotification | EnumTypeNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeNotificationFilter<$PrismaModel> | $Enums.TypeNotification
  }

  export type EnumPrioriteNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.PrioriteNotification | EnumPrioriteNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioriteNotificationFilter<$PrismaModel> | $Enums.PrioriteNotification
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    lu?: SortOrder
    destinataireId?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    lienAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    lu?: SortOrder
    destinataireId?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    lienAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    titre?: SortOrder
    message?: SortOrder
    type?: SortOrder
    priorite?: SortOrder
    lu?: SortOrder
    destinataireId?: SortOrder
    entite?: SortOrder
    entiteId?: SortOrder
    lienAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTypeNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeNotification | EnumTypeNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeNotificationWithAggregatesFilter<$PrismaModel> | $Enums.TypeNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeNotificationFilter<$PrismaModel>
    _max?: NestedEnumTypeNotificationFilter<$PrismaModel>
  }

  export type EnumPrioriteNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrioriteNotification | EnumPrioriteNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioriteNotificationWithAggregatesFilter<$PrismaModel> | $Enums.PrioriteNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrioriteNotificationFilter<$PrismaModel>
    _max?: NestedEnumPrioriteNotificationFilter<$PrismaModel>
  }

  export type EnumStatutRotationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutRotation | EnumStatutRotationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutRotationFilter<$PrismaModel> | $Enums.StatutRotation
  }

  export type RapportSupervisionNullableRelationFilter = {
    is?: RapportSupervisionWhereInput | null
    isNot?: RapportSupervisionWhereInput | null
  }

  export type RotationWeekendDateDebutResponsableIdCompoundUniqueInput = {
    dateDebut: Date | string
    responsableId: string
  }

  export type RotationWeekendCountOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    semaineNumero?: SortOrder
    annee?: SortOrder
    responsableId?: SortOrder
    substitutId?: SortOrder
    status?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
    commentaire?: SortOrder
    estAbsence?: SortOrder
    notificationEnvoyee?: SortOrder
    rappelEnvoye?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RotationWeekendAvgOrderByAggregateInput = {
    semaineNumero?: SortOrder
    annee?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
  }

  export type RotationWeekendMaxOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    semaineNumero?: SortOrder
    annee?: SortOrder
    responsableId?: SortOrder
    substitutId?: SortOrder
    status?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
    commentaire?: SortOrder
    estAbsence?: SortOrder
    notificationEnvoyee?: SortOrder
    rappelEnvoye?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RotationWeekendMinOrderByAggregateInput = {
    id?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    semaineNumero?: SortOrder
    annee?: SortOrder
    responsableId?: SortOrder
    substitutId?: SortOrder
    status?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
    commentaire?: SortOrder
    estAbsence?: SortOrder
    notificationEnvoyee?: SortOrder
    rappelEnvoye?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type RotationWeekendSumOrderByAggregateInput = {
    semaineNumero?: SortOrder
    annee?: SortOrder
    nbSeancesTotal?: SortOrder
    nbSeancesRealisees?: SortOrder
  }

  export type EnumStatutRotationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutRotation | EnumStatutRotationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutRotationWithAggregatesFilter<$PrismaModel> | $Enums.StatutRotation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutRotationFilter<$PrismaModel>
    _max?: NestedEnumStatutRotationFilter<$PrismaModel>
  }

  export type DisponibiliteResponsableCountOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    disponible?: SortOrder
    raison?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibiliteResponsableMaxOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    disponible?: SortOrder
    raison?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisponibiliteResponsableMinOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    dateDebut?: SortOrder
    dateFin?: SortOrder
    disponible?: SortOrder
    raison?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type RotationWeekendRelationFilter = {
    is?: RotationWeekendWhereInput
    isNot?: RotationWeekendWhereInput
  }

  export type RapportSupervisionCountOrderByAggregateInput = {
    id?: SortOrder
    rotationId?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    nbSeancesVisitees?: SortOrder
    incidents?: SortOrder
    observations?: SortOrder
    recommandations?: SortOrder
    satisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportSupervisionAvgOrderByAggregateInput = {
    nbSeancesVisitees?: SortOrder
    satisfaction?: SortOrder
  }

  export type RapportSupervisionMaxOrderByAggregateInput = {
    id?: SortOrder
    rotationId?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    nbSeancesVisitees?: SortOrder
    incidents?: SortOrder
    observations?: SortOrder
    recommandations?: SortOrder
    satisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportSupervisionMinOrderByAggregateInput = {
    id?: SortOrder
    rotationId?: SortOrder
    heureArrivee?: SortOrder
    heureDepart?: SortOrder
    nbSeancesVisitees?: SortOrder
    incidents?: SortOrder
    observations?: SortOrder
    recommandations?: SortOrder
    satisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RapportSupervisionSumOrderByAggregateInput = {
    nbSeancesVisitees?: SortOrder
    satisfaction?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StatistiqueRotationResponsableIdAnneeMoisCompoundUniqueInput = {
    responsableId: string
    annee: number
    mois: number
  }

  export type StatistiqueRotationCountOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    annee?: SortOrder
    mois?: SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatistiqueRotationAvgOrderByAggregateInput = {
    annee?: SortOrder
    mois?: SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrder
  }

  export type StatistiqueRotationMaxOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    annee?: SortOrder
    mois?: SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatistiqueRotationMinOrderByAggregateInput = {
    id?: SortOrder
    responsableId?: SortOrder
    annee?: SortOrder
    mois?: SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatistiqueRotationSumOrderByAggregateInput = {
    annee?: SortOrder
    mois?: SortOrder
    nbWeekendTotal?: SortOrder
    nbWeekendRealises?: SortOrder
    nbWeekendAbsences?: SortOrder
    nbWeekendSubstitut?: SortOrder
    tauxPresence?: SortOrder
    nbSeancesTotal?: SortOrder
    moyenneSatisfaction?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IndicateurAcademiqueCreateNestedManyWithoutResponsableInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput> | IndicateurAcademiqueCreateWithoutResponsableInput[] | IndicateurAcademiqueUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutResponsableInput | IndicateurAcademiqueCreateOrConnectWithoutResponsableInput[]
    createMany?: IndicateurAcademiqueCreateManyResponsableInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutUserInput = {
    create?: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput> | ModuleCreateWithoutUserInput[] | ModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutUserInput | ModuleCreateOrConnectWithoutUserInput[]
    createMany?: ModuleCreateManyUserInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ProgrammeCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput> | ProgrammeCreateWithoutUserInput[] | ProgrammeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgrammeCreateOrConnectWithoutUserInput | ProgrammeCreateOrConnectWithoutUserInput[]
    createMany?: ProgrammeCreateManyUserInputEnvelope
    connect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
  }

  export type RotationWeekendCreateNestedManyWithoutResponsableInput = {
    create?: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput> | RotationWeekendCreateWithoutResponsableInput[] | RotationWeekendUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutResponsableInput | RotationWeekendCreateOrConnectWithoutResponsableInput[]
    createMany?: RotationWeekendCreateManyResponsableInputEnvelope
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
  }

  export type RotationWeekendCreateNestedManyWithoutSubstitutInput = {
    create?: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput> | RotationWeekendCreateWithoutSubstitutInput[] | RotationWeekendUncheckedCreateWithoutSubstitutInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutSubstitutInput | RotationWeekendCreateOrConnectWithoutSubstitutInput[]
    createMany?: RotationWeekendCreateManySubstitutInputEnvelope
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
  }

  export type DisponibiliteResponsableCreateNestedManyWithoutResponsableInput = {
    create?: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput> | DisponibiliteResponsableCreateWithoutResponsableInput[] | DisponibiliteResponsableUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: DisponibiliteResponsableCreateOrConnectWithoutResponsableInput | DisponibiliteResponsableCreateOrConnectWithoutResponsableInput[]
    createMany?: DisponibiliteResponsableCreateManyResponsableInputEnvelope
    connect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
  }

  export type IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput> | IndicateurAcademiqueCreateWithoutResponsableInput[] | IndicateurAcademiqueUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutResponsableInput | IndicateurAcademiqueCreateOrConnectWithoutResponsableInput[]
    createMany?: IndicateurAcademiqueCreateManyResponsableInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput> | ModuleCreateWithoutUserInput[] | ModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutUserInput | ModuleCreateOrConnectWithoutUserInput[]
    createMany?: ModuleCreateManyUserInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type ProgrammeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput> | ProgrammeCreateWithoutUserInput[] | ProgrammeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgrammeCreateOrConnectWithoutUserInput | ProgrammeCreateOrConnectWithoutUserInput[]
    createMany?: ProgrammeCreateManyUserInputEnvelope
    connect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
  }

  export type RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput> | RotationWeekendCreateWithoutResponsableInput[] | RotationWeekendUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutResponsableInput | RotationWeekendCreateOrConnectWithoutResponsableInput[]
    createMany?: RotationWeekendCreateManyResponsableInputEnvelope
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
  }

  export type RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput = {
    create?: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput> | RotationWeekendCreateWithoutSubstitutInput[] | RotationWeekendUncheckedCreateWithoutSubstitutInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutSubstitutInput | RotationWeekendCreateOrConnectWithoutSubstitutInput[]
    createMany?: RotationWeekendCreateManySubstitutInputEnvelope
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
  }

  export type DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput = {
    create?: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput> | DisponibiliteResponsableCreateWithoutResponsableInput[] | DisponibiliteResponsableUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: DisponibiliteResponsableCreateOrConnectWithoutResponsableInput | DisponibiliteResponsableCreateOrConnectWithoutResponsableInput[]
    createMany?: DisponibiliteResponsableCreateManyResponsableInputEnvelope
    connect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput> | IndicateurAcademiqueCreateWithoutResponsableInput[] | IndicateurAcademiqueUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutResponsableInput | IndicateurAcademiqueCreateOrConnectWithoutResponsableInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutResponsableInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: IndicateurAcademiqueCreateManyResponsableInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutResponsableInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutResponsableInput | IndicateurAcademiqueUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput> | ModuleCreateWithoutUserInput[] | ModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutUserInput | ModuleCreateOrConnectWithoutUserInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutUserInput | ModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModuleCreateManyUserInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutUserInput | ModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutUserInput | ModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ProgrammeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput> | ProgrammeCreateWithoutUserInput[] | ProgrammeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgrammeCreateOrConnectWithoutUserInput | ProgrammeCreateOrConnectWithoutUserInput[]
    upsert?: ProgrammeUpsertWithWhereUniqueWithoutUserInput | ProgrammeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgrammeCreateManyUserInputEnvelope
    set?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    disconnect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    delete?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    connect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    update?: ProgrammeUpdateWithWhereUniqueWithoutUserInput | ProgrammeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgrammeUpdateManyWithWhereWithoutUserInput | ProgrammeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgrammeScalarWhereInput | ProgrammeScalarWhereInput[]
  }

  export type RotationWeekendUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput> | RotationWeekendCreateWithoutResponsableInput[] | RotationWeekendUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutResponsableInput | RotationWeekendCreateOrConnectWithoutResponsableInput[]
    upsert?: RotationWeekendUpsertWithWhereUniqueWithoutResponsableInput | RotationWeekendUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: RotationWeekendCreateManyResponsableInputEnvelope
    set?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    disconnect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    delete?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    update?: RotationWeekendUpdateWithWhereUniqueWithoutResponsableInput | RotationWeekendUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: RotationWeekendUpdateManyWithWhereWithoutResponsableInput | RotationWeekendUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
  }

  export type RotationWeekendUpdateManyWithoutSubstitutNestedInput = {
    create?: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput> | RotationWeekendCreateWithoutSubstitutInput[] | RotationWeekendUncheckedCreateWithoutSubstitutInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutSubstitutInput | RotationWeekendCreateOrConnectWithoutSubstitutInput[]
    upsert?: RotationWeekendUpsertWithWhereUniqueWithoutSubstitutInput | RotationWeekendUpsertWithWhereUniqueWithoutSubstitutInput[]
    createMany?: RotationWeekendCreateManySubstitutInputEnvelope
    set?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    disconnect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    delete?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    update?: RotationWeekendUpdateWithWhereUniqueWithoutSubstitutInput | RotationWeekendUpdateWithWhereUniqueWithoutSubstitutInput[]
    updateMany?: RotationWeekendUpdateManyWithWhereWithoutSubstitutInput | RotationWeekendUpdateManyWithWhereWithoutSubstitutInput[]
    deleteMany?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
  }

  export type DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput> | DisponibiliteResponsableCreateWithoutResponsableInput[] | DisponibiliteResponsableUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: DisponibiliteResponsableCreateOrConnectWithoutResponsableInput | DisponibiliteResponsableCreateOrConnectWithoutResponsableInput[]
    upsert?: DisponibiliteResponsableUpsertWithWhereUniqueWithoutResponsableInput | DisponibiliteResponsableUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: DisponibiliteResponsableCreateManyResponsableInputEnvelope
    set?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    disconnect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    delete?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    connect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    update?: DisponibiliteResponsableUpdateWithWhereUniqueWithoutResponsableInput | DisponibiliteResponsableUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: DisponibiliteResponsableUpdateManyWithWhereWithoutResponsableInput | DisponibiliteResponsableUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: DisponibiliteResponsableScalarWhereInput | DisponibiliteResponsableScalarWhereInput[]
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput> | IndicateurAcademiqueCreateWithoutResponsableInput[] | IndicateurAcademiqueUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutResponsableInput | IndicateurAcademiqueCreateOrConnectWithoutResponsableInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutResponsableInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: IndicateurAcademiqueCreateManyResponsableInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutResponsableInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutResponsableInput | IndicateurAcademiqueUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput> | ModuleCreateWithoutUserInput[] | ModuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutUserInput | ModuleCreateOrConnectWithoutUserInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutUserInput | ModuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ModuleCreateManyUserInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutUserInput | ModuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutUserInput | ModuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type ProgrammeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput> | ProgrammeCreateWithoutUserInput[] | ProgrammeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProgrammeCreateOrConnectWithoutUserInput | ProgrammeCreateOrConnectWithoutUserInput[]
    upsert?: ProgrammeUpsertWithWhereUniqueWithoutUserInput | ProgrammeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProgrammeCreateManyUserInputEnvelope
    set?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    disconnect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    delete?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    connect?: ProgrammeWhereUniqueInput | ProgrammeWhereUniqueInput[]
    update?: ProgrammeUpdateWithWhereUniqueWithoutUserInput | ProgrammeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProgrammeUpdateManyWithWhereWithoutUserInput | ProgrammeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProgrammeScalarWhereInput | ProgrammeScalarWhereInput[]
  }

  export type RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput> | RotationWeekendCreateWithoutResponsableInput[] | RotationWeekendUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutResponsableInput | RotationWeekendCreateOrConnectWithoutResponsableInput[]
    upsert?: RotationWeekendUpsertWithWhereUniqueWithoutResponsableInput | RotationWeekendUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: RotationWeekendCreateManyResponsableInputEnvelope
    set?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    disconnect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    delete?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    update?: RotationWeekendUpdateWithWhereUniqueWithoutResponsableInput | RotationWeekendUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: RotationWeekendUpdateManyWithWhereWithoutResponsableInput | RotationWeekendUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
  }

  export type RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput = {
    create?: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput> | RotationWeekendCreateWithoutSubstitutInput[] | RotationWeekendUncheckedCreateWithoutSubstitutInput[]
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutSubstitutInput | RotationWeekendCreateOrConnectWithoutSubstitutInput[]
    upsert?: RotationWeekendUpsertWithWhereUniqueWithoutSubstitutInput | RotationWeekendUpsertWithWhereUniqueWithoutSubstitutInput[]
    createMany?: RotationWeekendCreateManySubstitutInputEnvelope
    set?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    disconnect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    delete?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    connect?: RotationWeekendWhereUniqueInput | RotationWeekendWhereUniqueInput[]
    update?: RotationWeekendUpdateWithWhereUniqueWithoutSubstitutInput | RotationWeekendUpdateWithWhereUniqueWithoutSubstitutInput[]
    updateMany?: RotationWeekendUpdateManyWithWhereWithoutSubstitutInput | RotationWeekendUpdateManyWithWhereWithoutSubstitutInput[]
    deleteMany?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
  }

  export type DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput = {
    create?: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput> | DisponibiliteResponsableCreateWithoutResponsableInput[] | DisponibiliteResponsableUncheckedCreateWithoutResponsableInput[]
    connectOrCreate?: DisponibiliteResponsableCreateOrConnectWithoutResponsableInput | DisponibiliteResponsableCreateOrConnectWithoutResponsableInput[]
    upsert?: DisponibiliteResponsableUpsertWithWhereUniqueWithoutResponsableInput | DisponibiliteResponsableUpsertWithWhereUniqueWithoutResponsableInput[]
    createMany?: DisponibiliteResponsableCreateManyResponsableInputEnvelope
    set?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    disconnect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    delete?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    connect?: DisponibiliteResponsableWhereUniqueInput | DisponibiliteResponsableWhereUniqueInput[]
    update?: DisponibiliteResponsableUpdateWithWhereUniqueWithoutResponsableInput | DisponibiliteResponsableUpdateWithWhereUniqueWithoutResponsableInput[]
    updateMany?: DisponibiliteResponsableUpdateManyWithWhereWithoutResponsableInput | DisponibiliteResponsableUpdateManyWithWhereWithoutResponsableInput[]
    deleteMany?: DisponibiliteResponsableScalarWhereInput | DisponibiliteResponsableScalarWhereInput[]
  }

  export type ActiviteAcademiqueCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput> | ActiviteAcademiqueCreateWithoutProgrammeInput[] | ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput | ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput[]
    createMany?: ActiviteAcademiqueCreateManyProgrammeInputEnvelope
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
  }

  export type IndicateurAcademiqueCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput> | IndicateurAcademiqueCreateWithoutProgrammeInput[] | IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput | IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput[]
    createMany?: IndicateurAcademiqueCreateManyProgrammeInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput> | ModuleCreateWithoutProgrammeInput[] | ModuleUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProgrammeInput | ModuleCreateOrConnectWithoutProgrammeInput[]
    createMany?: ModuleCreateManyProgrammeInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutProgrammesInput = {
    create?: XOR<UserCreateWithoutProgrammesInput, UserUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgrammesInput
    connect?: UserWhereUniqueInput
  }

  export type ActiviteAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput> | ActiviteAcademiqueCreateWithoutProgrammeInput[] | ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput | ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput[]
    createMany?: ActiviteAcademiqueCreateManyProgrammeInputEnvelope
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
  }

  export type IndicateurAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput> | IndicateurAcademiqueCreateWithoutProgrammeInput[] | IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput | IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput[]
    createMany?: IndicateurAcademiqueCreateManyProgrammeInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutProgrammeInput = {
    create?: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput> | ModuleCreateWithoutProgrammeInput[] | ModuleUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProgrammeInput | ModuleCreateOrConnectWithoutProgrammeInput[]
    createMany?: ModuleCreateManyProgrammeInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type EnumSemestreFieldUpdateOperationsInput = {
    set?: $Enums.Semestre
  }

  export type EnumStatusProgrammeFieldUpdateOperationsInput = {
    set?: $Enums.StatusProgramme
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActiviteAcademiqueUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput> | ActiviteAcademiqueCreateWithoutProgrammeInput[] | ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput | ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput[]
    upsert?: ActiviteAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput | ActiviteAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: ActiviteAcademiqueCreateManyProgrammeInputEnvelope
    set?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    disconnect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    delete?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    update?: ActiviteAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput | ActiviteAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: ActiviteAcademiqueUpdateManyWithWhereWithoutProgrammeInput | ActiviteAcademiqueUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
  }

  export type IndicateurAcademiqueUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput> | IndicateurAcademiqueCreateWithoutProgrammeInput[] | IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput | IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: IndicateurAcademiqueCreateManyProgrammeInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutProgrammeInput | IndicateurAcademiqueUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput> | ModuleCreateWithoutProgrammeInput[] | ModuleUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProgrammeInput | ModuleCreateOrConnectWithoutProgrammeInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutProgrammeInput | ModuleUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: ModuleCreateManyProgrammeInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutProgrammeInput | ModuleUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutProgrammeInput | ModuleUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutProgrammesNestedInput = {
    create?: XOR<UserCreateWithoutProgrammesInput, UserUncheckedCreateWithoutProgrammesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgrammesInput
    upsert?: UserUpsertWithoutProgrammesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgrammesInput, UserUpdateWithoutProgrammesInput>, UserUncheckedUpdateWithoutProgrammesInput>
  }

  export type ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput> | ActiviteAcademiqueCreateWithoutProgrammeInput[] | ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput | ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput[]
    upsert?: ActiviteAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput | ActiviteAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: ActiviteAcademiqueCreateManyProgrammeInputEnvelope
    set?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    disconnect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    delete?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    update?: ActiviteAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput | ActiviteAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: ActiviteAcademiqueUpdateManyWithWhereWithoutProgrammeInput | ActiviteAcademiqueUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput> | IndicateurAcademiqueCreateWithoutProgrammeInput[] | IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput | IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: IndicateurAcademiqueCreateManyProgrammeInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutProgrammeInput | IndicateurAcademiqueUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutProgrammeNestedInput = {
    create?: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput> | ModuleCreateWithoutProgrammeInput[] | ModuleUncheckedCreateWithoutProgrammeInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutProgrammeInput | ModuleCreateOrConnectWithoutProgrammeInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutProgrammeInput | ModuleUpsertWithWhereUniqueWithoutProgrammeInput[]
    createMany?: ModuleCreateManyProgrammeInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutProgrammeInput | ModuleUpdateWithWhereUniqueWithoutProgrammeInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutProgrammeInput | ModuleUpdateManyWithWhereWithoutProgrammeInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type DisponibiliteIntervenantCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput> | DisponibiliteIntervenantCreateWithoutIntervenantInput[] | DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput | DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput[]
    createMany?: DisponibiliteIntervenantCreateManyIntervenantInputEnvelope
    connect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
  }

  export type EvaluationEnseignementCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput> | EvaluationEnseignementCreateWithoutIntervenantInput[] | EvaluationEnseignementUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutIntervenantInput | EvaluationEnseignementCreateOrConnectWithoutIntervenantInput[]
    createMany?: EvaluationEnseignementCreateManyIntervenantInputEnvelope
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
  }

  export type ModuleCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput> | ModuleCreateWithoutIntervenantInput[] | ModuleUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutIntervenantInput | ModuleCreateOrConnectWithoutIntervenantInput[]
    createMany?: ModuleCreateManyIntervenantInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type SeanceCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput> | SeanceCreateWithoutIntervenantInput[] | SeanceUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutIntervenantInput | SeanceCreateOrConnectWithoutIntervenantInput[]
    createMany?: SeanceCreateManyIntervenantInputEnvelope
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
  }

  export type DisponibiliteIntervenantUncheckedCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput> | DisponibiliteIntervenantCreateWithoutIntervenantInput[] | DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput | DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput[]
    createMany?: DisponibiliteIntervenantCreateManyIntervenantInputEnvelope
    connect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
  }

  export type EvaluationEnseignementUncheckedCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput> | EvaluationEnseignementCreateWithoutIntervenantInput[] | EvaluationEnseignementUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutIntervenantInput | EvaluationEnseignementCreateOrConnectWithoutIntervenantInput[]
    createMany?: EvaluationEnseignementCreateManyIntervenantInputEnvelope
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput> | ModuleCreateWithoutIntervenantInput[] | ModuleUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutIntervenantInput | ModuleCreateOrConnectWithoutIntervenantInput[]
    createMany?: ModuleCreateManyIntervenantInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type SeanceUncheckedCreateNestedManyWithoutIntervenantInput = {
    create?: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput> | SeanceCreateWithoutIntervenantInput[] | SeanceUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutIntervenantInput | SeanceCreateOrConnectWithoutIntervenantInput[]
    createMany?: SeanceCreateManyIntervenantInputEnvelope
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DisponibiliteIntervenantUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput> | DisponibiliteIntervenantCreateWithoutIntervenantInput[] | DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput | DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput[]
    upsert?: DisponibiliteIntervenantUpsertWithWhereUniqueWithoutIntervenantInput | DisponibiliteIntervenantUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: DisponibiliteIntervenantCreateManyIntervenantInputEnvelope
    set?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    disconnect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    delete?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    connect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    update?: DisponibiliteIntervenantUpdateWithWhereUniqueWithoutIntervenantInput | DisponibiliteIntervenantUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: DisponibiliteIntervenantUpdateManyWithWhereWithoutIntervenantInput | DisponibiliteIntervenantUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: DisponibiliteIntervenantScalarWhereInput | DisponibiliteIntervenantScalarWhereInput[]
  }

  export type EvaluationEnseignementUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput> | EvaluationEnseignementCreateWithoutIntervenantInput[] | EvaluationEnseignementUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutIntervenantInput | EvaluationEnseignementCreateOrConnectWithoutIntervenantInput[]
    upsert?: EvaluationEnseignementUpsertWithWhereUniqueWithoutIntervenantInput | EvaluationEnseignementUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: EvaluationEnseignementCreateManyIntervenantInputEnvelope
    set?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    disconnect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    delete?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    update?: EvaluationEnseignementUpdateWithWhereUniqueWithoutIntervenantInput | EvaluationEnseignementUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: EvaluationEnseignementUpdateManyWithWhereWithoutIntervenantInput | EvaluationEnseignementUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
  }

  export type ModuleUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput> | ModuleCreateWithoutIntervenantInput[] | ModuleUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutIntervenantInput | ModuleCreateOrConnectWithoutIntervenantInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutIntervenantInput | ModuleUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: ModuleCreateManyIntervenantInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutIntervenantInput | ModuleUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutIntervenantInput | ModuleUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type SeanceUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput> | SeanceCreateWithoutIntervenantInput[] | SeanceUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutIntervenantInput | SeanceCreateOrConnectWithoutIntervenantInput[]
    upsert?: SeanceUpsertWithWhereUniqueWithoutIntervenantInput | SeanceUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: SeanceCreateManyIntervenantInputEnvelope
    set?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    disconnect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    delete?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    update?: SeanceUpdateWithWhereUniqueWithoutIntervenantInput | SeanceUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: SeanceUpdateManyWithWhereWithoutIntervenantInput | SeanceUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
  }

  export type DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput> | DisponibiliteIntervenantCreateWithoutIntervenantInput[] | DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput | DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput[]
    upsert?: DisponibiliteIntervenantUpsertWithWhereUniqueWithoutIntervenantInput | DisponibiliteIntervenantUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: DisponibiliteIntervenantCreateManyIntervenantInputEnvelope
    set?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    disconnect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    delete?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    connect?: DisponibiliteIntervenantWhereUniqueInput | DisponibiliteIntervenantWhereUniqueInput[]
    update?: DisponibiliteIntervenantUpdateWithWhereUniqueWithoutIntervenantInput | DisponibiliteIntervenantUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: DisponibiliteIntervenantUpdateManyWithWhereWithoutIntervenantInput | DisponibiliteIntervenantUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: DisponibiliteIntervenantScalarWhereInput | DisponibiliteIntervenantScalarWhereInput[]
  }

  export type EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput> | EvaluationEnseignementCreateWithoutIntervenantInput[] | EvaluationEnseignementUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutIntervenantInput | EvaluationEnseignementCreateOrConnectWithoutIntervenantInput[]
    upsert?: EvaluationEnseignementUpsertWithWhereUniqueWithoutIntervenantInput | EvaluationEnseignementUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: EvaluationEnseignementCreateManyIntervenantInputEnvelope
    set?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    disconnect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    delete?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    update?: EvaluationEnseignementUpdateWithWhereUniqueWithoutIntervenantInput | EvaluationEnseignementUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: EvaluationEnseignementUpdateManyWithWhereWithoutIntervenantInput | EvaluationEnseignementUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput> | ModuleCreateWithoutIntervenantInput[] | ModuleUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutIntervenantInput | ModuleCreateOrConnectWithoutIntervenantInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutIntervenantInput | ModuleUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: ModuleCreateManyIntervenantInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutIntervenantInput | ModuleUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutIntervenantInput | ModuleUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type SeanceUncheckedUpdateManyWithoutIntervenantNestedInput = {
    create?: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput> | SeanceCreateWithoutIntervenantInput[] | SeanceUncheckedCreateWithoutIntervenantInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutIntervenantInput | SeanceCreateOrConnectWithoutIntervenantInput[]
    upsert?: SeanceUpsertWithWhereUniqueWithoutIntervenantInput | SeanceUpsertWithWhereUniqueWithoutIntervenantInput[]
    createMany?: SeanceCreateManyIntervenantInputEnvelope
    set?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    disconnect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    delete?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    update?: SeanceUpdateWithWhereUniqueWithoutIntervenantInput | SeanceUpdateWithWhereUniqueWithoutIntervenantInput[]
    updateMany?: SeanceUpdateManyWithWhereWithoutIntervenantInput | SeanceUpdateManyWithWhereWithoutIntervenantInput[]
    deleteMany?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
  }

  export type IntervenantCreateNestedOneWithoutDisponibilitesInput = {
    create?: XOR<IntervenantCreateWithoutDisponibilitesInput, IntervenantUncheckedCreateWithoutDisponibilitesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutDisponibilitesInput
    connect?: IntervenantWhereUniqueInput
  }

  export type EnumTypeDisponibiliteFieldUpdateOperationsInput = {
    set?: $Enums.TypeDisponibilite
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntervenantUpdateOneRequiredWithoutDisponibilitesNestedInput = {
    create?: XOR<IntervenantCreateWithoutDisponibilitesInput, IntervenantUncheckedCreateWithoutDisponibilitesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutDisponibilitesInput
    upsert?: IntervenantUpsertWithoutDisponibilitesInput
    connect?: IntervenantWhereUniqueInput
    update?: XOR<XOR<IntervenantUpdateToOneWithWhereWithoutDisponibilitesInput, IntervenantUpdateWithoutDisponibilitesInput>, IntervenantUncheckedUpdateWithoutDisponibilitesInput>
  }

  export type EvaluationEnseignementCreateNestedManyWithoutModuleInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput> | EvaluationEnseignementCreateWithoutModuleInput[] | EvaluationEnseignementUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutModuleInput | EvaluationEnseignementCreateOrConnectWithoutModuleInput[]
    createMany?: EvaluationEnseignementCreateManyModuleInputEnvelope
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
  }

  export type IntervenantCreateNestedOneWithoutModulesInput = {
    create?: XOR<IntervenantCreateWithoutModulesInput, IntervenantUncheckedCreateWithoutModulesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutModulesInput
    connect?: IntervenantWhereUniqueInput
  }

  export type ProgrammeCreateNestedOneWithoutModulesInput = {
    create?: XOR<ProgrammeCreateWithoutModulesInput, ProgrammeUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutModulesInput
    connect?: ProgrammeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutModulesInput = {
    create?: XOR<UserCreateWithoutModulesInput, UserUncheckedCreateWithoutModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModulesInput
    connect?: UserWhereUniqueInput
  }

  export type ResultatEtudiantCreateNestedManyWithoutModuleInput = {
    create?: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput> | ResultatEtudiantCreateWithoutModuleInput[] | ResultatEtudiantUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ResultatEtudiantCreateOrConnectWithoutModuleInput | ResultatEtudiantCreateOrConnectWithoutModuleInput[]
    createMany?: ResultatEtudiantCreateManyModuleInputEnvelope
    connect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
  }

  export type SeanceCreateNestedManyWithoutModuleInput = {
    create?: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput> | SeanceCreateWithoutModuleInput[] | SeanceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutModuleInput | SeanceCreateOrConnectWithoutModuleInput[]
    createMany?: SeanceCreateManyModuleInputEnvelope
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
  }

  export type EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput> | EvaluationEnseignementCreateWithoutModuleInput[] | EvaluationEnseignementUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutModuleInput | EvaluationEnseignementCreateOrConnectWithoutModuleInput[]
    createMany?: EvaluationEnseignementCreateManyModuleInputEnvelope
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
  }

  export type ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput> | ResultatEtudiantCreateWithoutModuleInput[] | ResultatEtudiantUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ResultatEtudiantCreateOrConnectWithoutModuleInput | ResultatEtudiantCreateOrConnectWithoutModuleInput[]
    createMany?: ResultatEtudiantCreateManyModuleInputEnvelope
    connect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
  }

  export type SeanceUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput> | SeanceCreateWithoutModuleInput[] | SeanceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutModuleInput | SeanceCreateOrConnectWithoutModuleInput[]
    createMany?: SeanceCreateManyModuleInputEnvelope
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
  }

  export type EnumStatusModuleFieldUpdateOperationsInput = {
    set?: $Enums.StatusModule
  }

  export type EvaluationEnseignementUpdateManyWithoutModuleNestedInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput> | EvaluationEnseignementCreateWithoutModuleInput[] | EvaluationEnseignementUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutModuleInput | EvaluationEnseignementCreateOrConnectWithoutModuleInput[]
    upsert?: EvaluationEnseignementUpsertWithWhereUniqueWithoutModuleInput | EvaluationEnseignementUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: EvaluationEnseignementCreateManyModuleInputEnvelope
    set?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    disconnect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    delete?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    update?: EvaluationEnseignementUpdateWithWhereUniqueWithoutModuleInput | EvaluationEnseignementUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: EvaluationEnseignementUpdateManyWithWhereWithoutModuleInput | EvaluationEnseignementUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
  }

  export type IntervenantUpdateOneWithoutModulesNestedInput = {
    create?: XOR<IntervenantCreateWithoutModulesInput, IntervenantUncheckedCreateWithoutModulesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutModulesInput
    upsert?: IntervenantUpsertWithoutModulesInput
    disconnect?: IntervenantWhereInput | boolean
    delete?: IntervenantWhereInput | boolean
    connect?: IntervenantWhereUniqueInput
    update?: XOR<XOR<IntervenantUpdateToOneWithWhereWithoutModulesInput, IntervenantUpdateWithoutModulesInput>, IntervenantUncheckedUpdateWithoutModulesInput>
  }

  export type ProgrammeUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<ProgrammeCreateWithoutModulesInput, ProgrammeUncheckedCreateWithoutModulesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutModulesInput
    upsert?: ProgrammeUpsertWithoutModulesInput
    connect?: ProgrammeWhereUniqueInput
    update?: XOR<XOR<ProgrammeUpdateToOneWithWhereWithoutModulesInput, ProgrammeUpdateWithoutModulesInput>, ProgrammeUncheckedUpdateWithoutModulesInput>
  }

  export type UserUpdateOneRequiredWithoutModulesNestedInput = {
    create?: XOR<UserCreateWithoutModulesInput, UserUncheckedCreateWithoutModulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutModulesInput
    upsert?: UserUpsertWithoutModulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutModulesInput, UserUpdateWithoutModulesInput>, UserUncheckedUpdateWithoutModulesInput>
  }

  export type ResultatEtudiantUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput> | ResultatEtudiantCreateWithoutModuleInput[] | ResultatEtudiantUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ResultatEtudiantCreateOrConnectWithoutModuleInput | ResultatEtudiantCreateOrConnectWithoutModuleInput[]
    upsert?: ResultatEtudiantUpsertWithWhereUniqueWithoutModuleInput | ResultatEtudiantUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ResultatEtudiantCreateManyModuleInputEnvelope
    set?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    disconnect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    delete?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    connect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    update?: ResultatEtudiantUpdateWithWhereUniqueWithoutModuleInput | ResultatEtudiantUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ResultatEtudiantUpdateManyWithWhereWithoutModuleInput | ResultatEtudiantUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ResultatEtudiantScalarWhereInput | ResultatEtudiantScalarWhereInput[]
  }

  export type SeanceUpdateManyWithoutModuleNestedInput = {
    create?: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput> | SeanceCreateWithoutModuleInput[] | SeanceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutModuleInput | SeanceCreateOrConnectWithoutModuleInput[]
    upsert?: SeanceUpsertWithWhereUniqueWithoutModuleInput | SeanceUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: SeanceCreateManyModuleInputEnvelope
    set?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    disconnect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    delete?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    update?: SeanceUpdateWithWhereUniqueWithoutModuleInput | SeanceUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: SeanceUpdateManyWithWhereWithoutModuleInput | SeanceUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
  }

  export type EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput> | EvaluationEnseignementCreateWithoutModuleInput[] | EvaluationEnseignementUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: EvaluationEnseignementCreateOrConnectWithoutModuleInput | EvaluationEnseignementCreateOrConnectWithoutModuleInput[]
    upsert?: EvaluationEnseignementUpsertWithWhereUniqueWithoutModuleInput | EvaluationEnseignementUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: EvaluationEnseignementCreateManyModuleInputEnvelope
    set?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    disconnect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    delete?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    connect?: EvaluationEnseignementWhereUniqueInput | EvaluationEnseignementWhereUniqueInput[]
    update?: EvaluationEnseignementUpdateWithWhereUniqueWithoutModuleInput | EvaluationEnseignementUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: EvaluationEnseignementUpdateManyWithWhereWithoutModuleInput | EvaluationEnseignementUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
  }

  export type ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput> | ResultatEtudiantCreateWithoutModuleInput[] | ResultatEtudiantUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ResultatEtudiantCreateOrConnectWithoutModuleInput | ResultatEtudiantCreateOrConnectWithoutModuleInput[]
    upsert?: ResultatEtudiantUpsertWithWhereUniqueWithoutModuleInput | ResultatEtudiantUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ResultatEtudiantCreateManyModuleInputEnvelope
    set?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    disconnect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    delete?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    connect?: ResultatEtudiantWhereUniqueInput | ResultatEtudiantWhereUniqueInput[]
    update?: ResultatEtudiantUpdateWithWhereUniqueWithoutModuleInput | ResultatEtudiantUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ResultatEtudiantUpdateManyWithWhereWithoutModuleInput | ResultatEtudiantUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ResultatEtudiantScalarWhereInput | ResultatEtudiantScalarWhereInput[]
  }

  export type SeanceUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput> | SeanceCreateWithoutModuleInput[] | SeanceUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: SeanceCreateOrConnectWithoutModuleInput | SeanceCreateOrConnectWithoutModuleInput[]
    upsert?: SeanceUpsertWithWhereUniqueWithoutModuleInput | SeanceUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: SeanceCreateManyModuleInputEnvelope
    set?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    disconnect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    delete?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    connect?: SeanceWhereUniqueInput | SeanceWhereUniqueInput[]
    update?: SeanceUpdateWithWhereUniqueWithoutModuleInput | SeanceUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: SeanceUpdateManyWithWhereWithoutModuleInput | SeanceUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
  }

  export type ConflitCreateNestedManyWithoutSeance1Input = {
    create?: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input> | ConflitCreateWithoutSeance1Input[] | ConflitUncheckedCreateWithoutSeance1Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance1Input | ConflitCreateOrConnectWithoutSeance1Input[]
    createMany?: ConflitCreateManySeance1InputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type ConflitCreateNestedManyWithoutSeance2Input = {
    create?: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input> | ConflitCreateWithoutSeance2Input[] | ConflitUncheckedCreateWithoutSeance2Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance2Input | ConflitCreateOrConnectWithoutSeance2Input[]
    createMany?: ConflitCreateManySeance2InputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type IntervenantCreateNestedOneWithoutSeancesInput = {
    create?: XOR<IntervenantCreateWithoutSeancesInput, IntervenantUncheckedCreateWithoutSeancesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutSeancesInput
    connect?: IntervenantWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutSeancesInput = {
    create?: XOR<ModuleCreateWithoutSeancesInput, ModuleUncheckedCreateWithoutSeancesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSeancesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ConflitUncheckedCreateNestedManyWithoutSeance1Input = {
    create?: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input> | ConflitCreateWithoutSeance1Input[] | ConflitUncheckedCreateWithoutSeance1Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance1Input | ConflitCreateOrConnectWithoutSeance1Input[]
    createMany?: ConflitCreateManySeance1InputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type ConflitUncheckedCreateNestedManyWithoutSeance2Input = {
    create?: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input> | ConflitCreateWithoutSeance2Input[] | ConflitUncheckedCreateWithoutSeance2Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance2Input | ConflitCreateOrConnectWithoutSeance2Input[]
    createMany?: ConflitCreateManySeance2InputEnvelope
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
  }

  export type EnumTypeSeanceFieldUpdateOperationsInput = {
    set?: $Enums.TypeSeance
  }

  export type EnumStatusSeanceFieldUpdateOperationsInput = {
    set?: $Enums.StatusSeance
  }

  export type ConflitUpdateManyWithoutSeance1NestedInput = {
    create?: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input> | ConflitCreateWithoutSeance1Input[] | ConflitUncheckedCreateWithoutSeance1Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance1Input | ConflitCreateOrConnectWithoutSeance1Input[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutSeance1Input | ConflitUpsertWithWhereUniqueWithoutSeance1Input[]
    createMany?: ConflitCreateManySeance1InputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutSeance1Input | ConflitUpdateWithWhereUniqueWithoutSeance1Input[]
    updateMany?: ConflitUpdateManyWithWhereWithoutSeance1Input | ConflitUpdateManyWithWhereWithoutSeance1Input[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type ConflitUpdateManyWithoutSeance2NestedInput = {
    create?: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input> | ConflitCreateWithoutSeance2Input[] | ConflitUncheckedCreateWithoutSeance2Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance2Input | ConflitCreateOrConnectWithoutSeance2Input[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutSeance2Input | ConflitUpsertWithWhereUniqueWithoutSeance2Input[]
    createMany?: ConflitCreateManySeance2InputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutSeance2Input | ConflitUpdateWithWhereUniqueWithoutSeance2Input[]
    updateMany?: ConflitUpdateManyWithWhereWithoutSeance2Input | ConflitUpdateManyWithWhereWithoutSeance2Input[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type IntervenantUpdateOneRequiredWithoutSeancesNestedInput = {
    create?: XOR<IntervenantCreateWithoutSeancesInput, IntervenantUncheckedCreateWithoutSeancesInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutSeancesInput
    upsert?: IntervenantUpsertWithoutSeancesInput
    connect?: IntervenantWhereUniqueInput
    update?: XOR<XOR<IntervenantUpdateToOneWithWhereWithoutSeancesInput, IntervenantUpdateWithoutSeancesInput>, IntervenantUncheckedUpdateWithoutSeancesInput>
  }

  export type ModuleUpdateOneRequiredWithoutSeancesNestedInput = {
    create?: XOR<ModuleCreateWithoutSeancesInput, ModuleUncheckedCreateWithoutSeancesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutSeancesInput
    upsert?: ModuleUpsertWithoutSeancesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutSeancesInput, ModuleUpdateWithoutSeancesInput>, ModuleUncheckedUpdateWithoutSeancesInput>
  }

  export type ConflitUncheckedUpdateManyWithoutSeance1NestedInput = {
    create?: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input> | ConflitCreateWithoutSeance1Input[] | ConflitUncheckedCreateWithoutSeance1Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance1Input | ConflitCreateOrConnectWithoutSeance1Input[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutSeance1Input | ConflitUpsertWithWhereUniqueWithoutSeance1Input[]
    createMany?: ConflitCreateManySeance1InputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutSeance1Input | ConflitUpdateWithWhereUniqueWithoutSeance1Input[]
    updateMany?: ConflitUpdateManyWithWhereWithoutSeance1Input | ConflitUpdateManyWithWhereWithoutSeance1Input[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type ConflitUncheckedUpdateManyWithoutSeance2NestedInput = {
    create?: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input> | ConflitCreateWithoutSeance2Input[] | ConflitUncheckedCreateWithoutSeance2Input[]
    connectOrCreate?: ConflitCreateOrConnectWithoutSeance2Input | ConflitCreateOrConnectWithoutSeance2Input[]
    upsert?: ConflitUpsertWithWhereUniqueWithoutSeance2Input | ConflitUpsertWithWhereUniqueWithoutSeance2Input[]
    createMany?: ConflitCreateManySeance2InputEnvelope
    set?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    disconnect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    delete?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    connect?: ConflitWhereUniqueInput | ConflitWhereUniqueInput[]
    update?: ConflitUpdateWithWhereUniqueWithoutSeance2Input | ConflitUpdateWithWhereUniqueWithoutSeance2Input[]
    updateMany?: ConflitUpdateManyWithWhereWithoutSeance2Input | ConflitUpdateManyWithWhereWithoutSeance2Input[]
    deleteMany?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
  }

  export type SeanceCreateNestedOneWithoutConflitsAsSeance1Input = {
    create?: XOR<SeanceCreateWithoutConflitsAsSeance1Input, SeanceUncheckedCreateWithoutConflitsAsSeance1Input>
    connectOrCreate?: SeanceCreateOrConnectWithoutConflitsAsSeance1Input
    connect?: SeanceWhereUniqueInput
  }

  export type SeanceCreateNestedOneWithoutConflitsAsSeance2Input = {
    create?: XOR<SeanceCreateWithoutConflitsAsSeance2Input, SeanceUncheckedCreateWithoutConflitsAsSeance2Input>
    connectOrCreate?: SeanceCreateOrConnectWithoutConflitsAsSeance2Input
    connect?: SeanceWhereUniqueInput
  }

  export type EnumTypeConflitFieldUpdateOperationsInput = {
    set?: $Enums.TypeConflit
  }

  export type EnumSeveriteConflitFieldUpdateOperationsInput = {
    set?: $Enums.SeveriteConflit
  }

  export type SeanceUpdateOneRequiredWithoutConflitsAsSeance1NestedInput = {
    create?: XOR<SeanceCreateWithoutConflitsAsSeance1Input, SeanceUncheckedCreateWithoutConflitsAsSeance1Input>
    connectOrCreate?: SeanceCreateOrConnectWithoutConflitsAsSeance1Input
    upsert?: SeanceUpsertWithoutConflitsAsSeance1Input
    connect?: SeanceWhereUniqueInput
    update?: XOR<XOR<SeanceUpdateToOneWithWhereWithoutConflitsAsSeance1Input, SeanceUpdateWithoutConflitsAsSeance1Input>, SeanceUncheckedUpdateWithoutConflitsAsSeance1Input>
  }

  export type SeanceUpdateOneWithoutConflitsAsSeance2NestedInput = {
    create?: XOR<SeanceCreateWithoutConflitsAsSeance2Input, SeanceUncheckedCreateWithoutConflitsAsSeance2Input>
    connectOrCreate?: SeanceCreateOrConnectWithoutConflitsAsSeance2Input
    upsert?: SeanceUpsertWithoutConflitsAsSeance2Input
    disconnect?: SeanceWhereInput | boolean
    delete?: SeanceWhereInput | boolean
    connect?: SeanceWhereUniqueInput
    update?: XOR<XOR<SeanceUpdateToOneWithWhereWithoutConflitsAsSeance2Input, SeanceUpdateWithoutConflitsAsSeance2Input>, SeanceUncheckedUpdateWithoutConflitsAsSeance2Input>
  }

  export type ActiviteAcademiqueCreateNestedManyWithoutPeriodeInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput> | ActiviteAcademiqueCreateWithoutPeriodeInput[] | ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput | ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput[]
    createMany?: ActiviteAcademiqueCreateManyPeriodeInputEnvelope
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
  }

  export type IndicateurAcademiqueCreateNestedManyWithoutPeriodeInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput> | IndicateurAcademiqueCreateWithoutPeriodeInput[] | IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput | IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput[]
    createMany?: IndicateurAcademiqueCreateManyPeriodeInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ActiviteAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput> | ActiviteAcademiqueCreateWithoutPeriodeInput[] | ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput | ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput[]
    createMany?: ActiviteAcademiqueCreateManyPeriodeInputEnvelope
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
  }

  export type IndicateurAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput> | IndicateurAcademiqueCreateWithoutPeriodeInput[] | IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput | IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput[]
    createMany?: IndicateurAcademiqueCreateManyPeriodeInputEnvelope
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
  }

  export type ActiviteAcademiqueUpdateManyWithoutPeriodeNestedInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput> | ActiviteAcademiqueCreateWithoutPeriodeInput[] | ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput | ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput[]
    upsert?: ActiviteAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput | ActiviteAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput[]
    createMany?: ActiviteAcademiqueCreateManyPeriodeInputEnvelope
    set?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    disconnect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    delete?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    update?: ActiviteAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput | ActiviteAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput[]
    updateMany?: ActiviteAcademiqueUpdateManyWithWhereWithoutPeriodeInput | ActiviteAcademiqueUpdateManyWithWhereWithoutPeriodeInput[]
    deleteMany?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
  }

  export type IndicateurAcademiqueUpdateManyWithoutPeriodeNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput> | IndicateurAcademiqueCreateWithoutPeriodeInput[] | IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput | IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput[]
    createMany?: IndicateurAcademiqueCreateManyPeriodeInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutPeriodeInput | IndicateurAcademiqueUpdateManyWithWhereWithoutPeriodeInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type ActiviteAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput = {
    create?: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput> | ActiviteAcademiqueCreateWithoutPeriodeInput[] | ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput | ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput[]
    upsert?: ActiviteAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput | ActiviteAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput[]
    createMany?: ActiviteAcademiqueCreateManyPeriodeInputEnvelope
    set?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    disconnect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    delete?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    connect?: ActiviteAcademiqueWhereUniqueInput | ActiviteAcademiqueWhereUniqueInput[]
    update?: ActiviteAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput | ActiviteAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput[]
    updateMany?: ActiviteAcademiqueUpdateManyWithWhereWithoutPeriodeInput | ActiviteAcademiqueUpdateManyWithWhereWithoutPeriodeInput[]
    deleteMany?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput = {
    create?: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput> | IndicateurAcademiqueCreateWithoutPeriodeInput[] | IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput[]
    connectOrCreate?: IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput | IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput[]
    upsert?: IndicateurAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput | IndicateurAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput[]
    createMany?: IndicateurAcademiqueCreateManyPeriodeInputEnvelope
    set?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    disconnect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    delete?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    connect?: IndicateurAcademiqueWhereUniqueInput | IndicateurAcademiqueWhereUniqueInput[]
    update?: IndicateurAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput | IndicateurAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput[]
    updateMany?: IndicateurAcademiqueUpdateManyWithWhereWithoutPeriodeInput | IndicateurAcademiqueUpdateManyWithWhereWithoutPeriodeInput[]
    deleteMany?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type PeriodeAcademiqueCreateNestedOneWithoutActivitesAcademiquesInput = {
    create?: XOR<PeriodeAcademiqueCreateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutActivitesAcademiquesInput>
    connectOrCreate?: PeriodeAcademiqueCreateOrConnectWithoutActivitesAcademiquesInput
    connect?: PeriodeAcademiqueWhereUniqueInput
  }

  export type ProgrammeCreateNestedOneWithoutActivitesAcademiquesInput = {
    create?: XOR<ProgrammeCreateWithoutActivitesAcademiquesInput, ProgrammeUncheckedCreateWithoutActivitesAcademiquesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutActivitesAcademiquesInput
    connect?: ProgrammeWhereUniqueInput
  }

  export type PeriodeAcademiqueUpdateOneRequiredWithoutActivitesAcademiquesNestedInput = {
    create?: XOR<PeriodeAcademiqueCreateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutActivitesAcademiquesInput>
    connectOrCreate?: PeriodeAcademiqueCreateOrConnectWithoutActivitesAcademiquesInput
    upsert?: PeriodeAcademiqueUpsertWithoutActivitesAcademiquesInput
    connect?: PeriodeAcademiqueWhereUniqueInput
    update?: XOR<XOR<PeriodeAcademiqueUpdateToOneWithWhereWithoutActivitesAcademiquesInput, PeriodeAcademiqueUpdateWithoutActivitesAcademiquesInput>, PeriodeAcademiqueUncheckedUpdateWithoutActivitesAcademiquesInput>
  }

  export type ProgrammeUpdateOneRequiredWithoutActivitesAcademiquesNestedInput = {
    create?: XOR<ProgrammeCreateWithoutActivitesAcademiquesInput, ProgrammeUncheckedCreateWithoutActivitesAcademiquesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutActivitesAcademiquesInput
    upsert?: ProgrammeUpsertWithoutActivitesAcademiquesInput
    connect?: ProgrammeWhereUniqueInput
    update?: XOR<XOR<ProgrammeUpdateToOneWithWhereWithoutActivitesAcademiquesInput, ProgrammeUpdateWithoutActivitesAcademiquesInput>, ProgrammeUncheckedUpdateWithoutActivitesAcademiquesInput>
  }

  export type PeriodeAcademiqueCreateNestedOneWithoutIndicateursAcademiquesInput = {
    create?: XOR<PeriodeAcademiqueCreateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: PeriodeAcademiqueCreateOrConnectWithoutIndicateursAcademiquesInput
    connect?: PeriodeAcademiqueWhereUniqueInput
  }

  export type ProgrammeCreateNestedOneWithoutIndicateursAcademiquesInput = {
    create?: XOR<ProgrammeCreateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutIndicateursAcademiquesInput
    connect?: ProgrammeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutIndicateursAcademiquesInput = {
    create?: XOR<UserCreateWithoutIndicateursAcademiquesInput, UserUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndicateursAcademiquesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PeriodeAcademiqueUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput = {
    create?: XOR<PeriodeAcademiqueCreateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: PeriodeAcademiqueCreateOrConnectWithoutIndicateursAcademiquesInput
    upsert?: PeriodeAcademiqueUpsertWithoutIndicateursAcademiquesInput
    connect?: PeriodeAcademiqueWhereUniqueInput
    update?: XOR<XOR<PeriodeAcademiqueUpdateToOneWithWhereWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUpdateWithoutIndicateursAcademiquesInput>, PeriodeAcademiqueUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type ProgrammeUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput = {
    create?: XOR<ProgrammeCreateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: ProgrammeCreateOrConnectWithoutIndicateursAcademiquesInput
    upsert?: ProgrammeUpsertWithoutIndicateursAcademiquesInput
    connect?: ProgrammeWhereUniqueInput
    update?: XOR<XOR<ProgrammeUpdateToOneWithWhereWithoutIndicateursAcademiquesInput, ProgrammeUpdateWithoutIndicateursAcademiquesInput>, ProgrammeUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type UserUpdateOneWithoutIndicateursAcademiquesNestedInput = {
    create?: XOR<UserCreateWithoutIndicateursAcademiquesInput, UserUncheckedCreateWithoutIndicateursAcademiquesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIndicateursAcademiquesInput
    upsert?: UserUpsertWithoutIndicateursAcademiquesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIndicateursAcademiquesInput, UserUpdateWithoutIndicateursAcademiquesInput>, UserUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type ModuleCreateNestedOneWithoutResultatsEtudiantsInput = {
    create?: XOR<ModuleCreateWithoutResultatsEtudiantsInput, ModuleUncheckedCreateWithoutResultatsEtudiantsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutResultatsEtudiantsInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutResultatsEtudiantsNestedInput = {
    create?: XOR<ModuleCreateWithoutResultatsEtudiantsInput, ModuleUncheckedCreateWithoutResultatsEtudiantsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutResultatsEtudiantsInput
    upsert?: ModuleUpsertWithoutResultatsEtudiantsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutResultatsEtudiantsInput, ModuleUpdateWithoutResultatsEtudiantsInput>, ModuleUncheckedUpdateWithoutResultatsEtudiantsInput>
  }

  export type IntervenantCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<IntervenantCreateWithoutEvaluationsInput, IntervenantUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutEvaluationsInput
    connect?: IntervenantWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<ModuleCreateWithoutEvaluationsInput, ModuleUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutEvaluationsInput
    connect?: ModuleWhereUniqueInput
  }

  export type EnumStatutCampagneFieldUpdateOperationsInput = {
    set?: $Enums.StatutCampagne
  }

  export type IntervenantUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<IntervenantCreateWithoutEvaluationsInput, IntervenantUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: IntervenantCreateOrConnectWithoutEvaluationsInput
    upsert?: IntervenantUpsertWithoutEvaluationsInput
    connect?: IntervenantWhereUniqueInput
    update?: XOR<XOR<IntervenantUpdateToOneWithWhereWithoutEvaluationsInput, IntervenantUpdateWithoutEvaluationsInput>, IntervenantUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ModuleUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<ModuleCreateWithoutEvaluationsInput, ModuleUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutEvaluationsInput
    upsert?: ModuleUpsertWithoutEvaluationsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutEvaluationsInput, ModuleUpdateWithoutEvaluationsInput>, ModuleUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EnumTypeNotificationFieldUpdateOperationsInput = {
    set?: $Enums.TypeNotification
  }

  export type EnumPrioriteNotificationFieldUpdateOperationsInput = {
    set?: $Enums.PrioriteNotification
  }

  export type UserCreateNestedOneWithoutRotationsResponsableInput = {
    create?: XOR<UserCreateWithoutRotationsResponsableInput, UserUncheckedCreateWithoutRotationsResponsableInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationsResponsableInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRotationsSubstitutInput = {
    create?: XOR<UserCreateWithoutRotationsSubstitutInput, UserUncheckedCreateWithoutRotationsSubstitutInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationsSubstitutInput
    connect?: UserWhereUniqueInput
  }

  export type RapportSupervisionCreateNestedOneWithoutRotationInput = {
    create?: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
    connectOrCreate?: RapportSupervisionCreateOrConnectWithoutRotationInput
    connect?: RapportSupervisionWhereUniqueInput
  }

  export type RapportSupervisionUncheckedCreateNestedOneWithoutRotationInput = {
    create?: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
    connectOrCreate?: RapportSupervisionCreateOrConnectWithoutRotationInput
    connect?: RapportSupervisionWhereUniqueInput
  }

  export type EnumStatutRotationFieldUpdateOperationsInput = {
    set?: $Enums.StatutRotation
  }

  export type UserUpdateOneRequiredWithoutRotationsResponsableNestedInput = {
    create?: XOR<UserCreateWithoutRotationsResponsableInput, UserUncheckedCreateWithoutRotationsResponsableInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationsResponsableInput
    upsert?: UserUpsertWithoutRotationsResponsableInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRotationsResponsableInput, UserUpdateWithoutRotationsResponsableInput>, UserUncheckedUpdateWithoutRotationsResponsableInput>
  }

  export type UserUpdateOneWithoutRotationsSubstitutNestedInput = {
    create?: XOR<UserCreateWithoutRotationsSubstitutInput, UserUncheckedCreateWithoutRotationsSubstitutInput>
    connectOrCreate?: UserCreateOrConnectWithoutRotationsSubstitutInput
    upsert?: UserUpsertWithoutRotationsSubstitutInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRotationsSubstitutInput, UserUpdateWithoutRotationsSubstitutInput>, UserUncheckedUpdateWithoutRotationsSubstitutInput>
  }

  export type RapportSupervisionUpdateOneWithoutRotationNestedInput = {
    create?: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
    connectOrCreate?: RapportSupervisionCreateOrConnectWithoutRotationInput
    upsert?: RapportSupervisionUpsertWithoutRotationInput
    disconnect?: RapportSupervisionWhereInput | boolean
    delete?: RapportSupervisionWhereInput | boolean
    connect?: RapportSupervisionWhereUniqueInput
    update?: XOR<XOR<RapportSupervisionUpdateToOneWithWhereWithoutRotationInput, RapportSupervisionUpdateWithoutRotationInput>, RapportSupervisionUncheckedUpdateWithoutRotationInput>
  }

  export type RapportSupervisionUncheckedUpdateOneWithoutRotationNestedInput = {
    create?: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
    connectOrCreate?: RapportSupervisionCreateOrConnectWithoutRotationInput
    upsert?: RapportSupervisionUpsertWithoutRotationInput
    disconnect?: RapportSupervisionWhereInput | boolean
    delete?: RapportSupervisionWhereInput | boolean
    connect?: RapportSupervisionWhereUniqueInput
    update?: XOR<XOR<RapportSupervisionUpdateToOneWithWhereWithoutRotationInput, RapportSupervisionUpdateWithoutRotationInput>, RapportSupervisionUncheckedUpdateWithoutRotationInput>
  }

  export type UserCreateNestedOneWithoutDisponibilitesInput = {
    create?: XOR<UserCreateWithoutDisponibilitesInput, UserUncheckedCreateWithoutDisponibilitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisponibilitesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDisponibilitesNestedInput = {
    create?: XOR<UserCreateWithoutDisponibilitesInput, UserUncheckedCreateWithoutDisponibilitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisponibilitesInput
    upsert?: UserUpsertWithoutDisponibilitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisponibilitesInput, UserUpdateWithoutDisponibilitesInput>, UserUncheckedUpdateWithoutDisponibilitesInput>
  }

  export type RotationWeekendCreateNestedOneWithoutRapportSupervisionInput = {
    create?: XOR<RotationWeekendCreateWithoutRapportSupervisionInput, RotationWeekendUncheckedCreateWithoutRapportSupervisionInput>
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutRapportSupervisionInput
    connect?: RotationWeekendWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RotationWeekendUpdateOneRequiredWithoutRapportSupervisionNestedInput = {
    create?: XOR<RotationWeekendCreateWithoutRapportSupervisionInput, RotationWeekendUncheckedCreateWithoutRapportSupervisionInput>
    connectOrCreate?: RotationWeekendCreateOrConnectWithoutRapportSupervisionInput
    upsert?: RotationWeekendUpsertWithoutRapportSupervisionInput
    connect?: RotationWeekendWhereUniqueInput
    update?: XOR<XOR<RotationWeekendUpdateToOneWithWhereWithoutRapportSupervisionInput, RotationWeekendUpdateWithoutRapportSupervisionInput>, RotationWeekendUncheckedUpdateWithoutRapportSupervisionInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumSemestreFilter<$PrismaModel = never> = {
    equals?: $Enums.Semestre | EnumSemestreFieldRefInput<$PrismaModel>
    in?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    not?: NestedEnumSemestreFilter<$PrismaModel> | $Enums.Semestre
  }

  export type NestedEnumStatusProgrammeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusProgramme | EnumStatusProgrammeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusProgrammeFilter<$PrismaModel> | $Enums.StatusProgramme
  }

  export type NestedEnumSemestreWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Semestre | EnumSemestreFieldRefInput<$PrismaModel>
    in?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    notIn?: $Enums.Semestre[] | ListEnumSemestreFieldRefInput<$PrismaModel>
    not?: NestedEnumSemestreWithAggregatesFilter<$PrismaModel> | $Enums.Semestre
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSemestreFilter<$PrismaModel>
    _max?: NestedEnumSemestreFilter<$PrismaModel>
  }

  export type NestedEnumStatusProgrammeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusProgramme | EnumStatusProgrammeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusProgramme[] | ListEnumStatusProgrammeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusProgrammeWithAggregatesFilter<$PrismaModel> | $Enums.StatusProgramme
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusProgrammeFilter<$PrismaModel>
    _max?: NestedEnumStatusProgrammeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTypeDisponibiliteFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDisponibilite | EnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDisponibiliteFilter<$PrismaModel> | $Enums.TypeDisponibilite
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumTypeDisponibiliteWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeDisponibilite | EnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    in?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeDisponibilite[] | ListEnumTypeDisponibiliteFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeDisponibiliteWithAggregatesFilter<$PrismaModel> | $Enums.TypeDisponibilite
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeDisponibiliteFilter<$PrismaModel>
    _max?: NestedEnumTypeDisponibiliteFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusModuleFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusModule | EnumStatusModuleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusModuleFilter<$PrismaModel> | $Enums.StatusModule
  }

  export type NestedEnumStatusModuleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusModule | EnumStatusModuleFieldRefInput<$PrismaModel>
    in?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusModule[] | ListEnumStatusModuleFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusModuleWithAggregatesFilter<$PrismaModel> | $Enums.StatusModule
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusModuleFilter<$PrismaModel>
    _max?: NestedEnumStatusModuleFilter<$PrismaModel>
  }

  export type NestedEnumTypeSeanceFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeSeance | EnumTypeSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeSeanceFilter<$PrismaModel> | $Enums.TypeSeance
  }

  export type NestedEnumStatusSeanceFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusSeance | EnumStatusSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusSeanceFilter<$PrismaModel> | $Enums.StatusSeance
  }

  export type NestedEnumTypeSeanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeSeance | EnumTypeSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeSeance[] | ListEnumTypeSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeSeanceWithAggregatesFilter<$PrismaModel> | $Enums.TypeSeance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeSeanceFilter<$PrismaModel>
    _max?: NestedEnumTypeSeanceFilter<$PrismaModel>
  }

  export type NestedEnumStatusSeanceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusSeance | EnumStatusSeanceFieldRefInput<$PrismaModel>
    in?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusSeance[] | ListEnumStatusSeanceFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusSeanceWithAggregatesFilter<$PrismaModel> | $Enums.StatusSeance
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusSeanceFilter<$PrismaModel>
    _max?: NestedEnumStatusSeanceFilter<$PrismaModel>
  }

  export type NestedEnumTypeConflitFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConflit | EnumTypeConflitFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConflitFilter<$PrismaModel> | $Enums.TypeConflit
  }

  export type NestedEnumSeveriteConflitFilter<$PrismaModel = never> = {
    equals?: $Enums.SeveriteConflit | EnumSeveriteConflitFieldRefInput<$PrismaModel>
    in?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumSeveriteConflitFilter<$PrismaModel> | $Enums.SeveriteConflit
  }

  export type NestedEnumTypeConflitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeConflit | EnumTypeConflitFieldRefInput<$PrismaModel>
    in?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeConflit[] | ListEnumTypeConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeConflitWithAggregatesFilter<$PrismaModel> | $Enums.TypeConflit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeConflitFilter<$PrismaModel>
    _max?: NestedEnumTypeConflitFilter<$PrismaModel>
  }

  export type NestedEnumSeveriteConflitWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeveriteConflit | EnumSeveriteConflitFieldRefInput<$PrismaModel>
    in?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    notIn?: $Enums.SeveriteConflit[] | ListEnumSeveriteConflitFieldRefInput<$PrismaModel>
    not?: NestedEnumSeveriteConflitWithAggregatesFilter<$PrismaModel> | $Enums.SeveriteConflit
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeveriteConflitFilter<$PrismaModel>
    _max?: NestedEnumSeveriteConflitFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatutCampagneFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCampagne | EnumStatutCampagneFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCampagneFilter<$PrismaModel> | $Enums.StatutCampagne
  }

  export type NestedEnumStatutCampagneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutCampagne | EnumStatutCampagneFieldRefInput<$PrismaModel>
    in?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutCampagne[] | ListEnumStatutCampagneFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutCampagneWithAggregatesFilter<$PrismaModel> | $Enums.StatutCampagne
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutCampagneFilter<$PrismaModel>
    _max?: NestedEnumStatutCampagneFilter<$PrismaModel>
  }

  export type NestedEnumTypeNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeNotification | EnumTypeNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeNotificationFilter<$PrismaModel> | $Enums.TypeNotification
  }

  export type NestedEnumPrioriteNotificationFilter<$PrismaModel = never> = {
    equals?: $Enums.PrioriteNotification | EnumPrioriteNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioriteNotificationFilter<$PrismaModel> | $Enums.PrioriteNotification
  }

  export type NestedEnumTypeNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TypeNotification | EnumTypeNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.TypeNotification[] | ListEnumTypeNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumTypeNotificationWithAggregatesFilter<$PrismaModel> | $Enums.TypeNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTypeNotificationFilter<$PrismaModel>
    _max?: NestedEnumTypeNotificationFilter<$PrismaModel>
  }

  export type NestedEnumPrioriteNotificationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrioriteNotification | EnumPrioriteNotificationFieldRefInput<$PrismaModel>
    in?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrioriteNotification[] | ListEnumPrioriteNotificationFieldRefInput<$PrismaModel>
    not?: NestedEnumPrioriteNotificationWithAggregatesFilter<$PrismaModel> | $Enums.PrioriteNotification
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrioriteNotificationFilter<$PrismaModel>
    _max?: NestedEnumPrioriteNotificationFilter<$PrismaModel>
  }

  export type NestedEnumStatutRotationFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutRotation | EnumStatutRotationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutRotationFilter<$PrismaModel> | $Enums.StatutRotation
  }

  export type NestedEnumStatutRotationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatutRotation | EnumStatutRotationFieldRefInput<$PrismaModel>
    in?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatutRotation[] | ListEnumStatutRotationFieldRefInput<$PrismaModel>
    not?: NestedEnumStatutRotationWithAggregatesFilter<$PrismaModel> | $Enums.StatutRotation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatutRotationFilter<$PrismaModel>
    _max?: NestedEnumStatutRotationFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IndicateurAcademiqueCreateWithoutResponsableInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    periode: PeriodeAcademiqueCreateNestedOneWithoutIndicateursAcademiquesInput
    programme: ProgrammeCreateNestedOneWithoutIndicateursAcademiquesInput
  }

  export type IndicateurAcademiqueUncheckedCreateWithoutResponsableInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    periodeId: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueCreateOrConnectWithoutResponsableInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    create: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput>
  }

  export type IndicateurAcademiqueCreateManyResponsableInputEnvelope = {
    data: IndicateurAcademiqueCreateManyResponsableInput | IndicateurAcademiqueCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutUserInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutUserInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput>
  }

  export type ModuleCreateManyUserInputEnvelope = {
    data: ModuleCreateManyUserInput | ModuleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProgrammeCreateWithoutUserInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutProgrammeInput
    modules?: ModuleCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeCreateOrConnectWithoutUserInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput>
  }

  export type ProgrammeCreateManyUserInputEnvelope = {
    data: ProgrammeCreateManyUserInput | ProgrammeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RotationWeekendCreateWithoutResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    substitut?: UserCreateNestedOneWithoutRotationsSubstitutInput
    rapportSupervision?: RapportSupervisionCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendUncheckedCreateWithoutResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    substitutId?: string | null
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    rapportSupervision?: RapportSupervisionUncheckedCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendCreateOrConnectWithoutResponsableInput = {
    where: RotationWeekendWhereUniqueInput
    create: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput>
  }

  export type RotationWeekendCreateManyResponsableInputEnvelope = {
    data: RotationWeekendCreateManyResponsableInput | RotationWeekendCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type RotationWeekendCreateWithoutSubstitutInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    responsable: UserCreateNestedOneWithoutRotationsResponsableInput
    rapportSupervision?: RapportSupervisionCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendUncheckedCreateWithoutSubstitutInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    responsableId: string
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    rapportSupervision?: RapportSupervisionUncheckedCreateNestedOneWithoutRotationInput
  }

  export type RotationWeekendCreateOrConnectWithoutSubstitutInput = {
    where: RotationWeekendWhereUniqueInput
    create: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput>
  }

  export type RotationWeekendCreateManySubstitutInputEnvelope = {
    data: RotationWeekendCreateManySubstitutInput | RotationWeekendCreateManySubstitutInput[]
    skipDuplicates?: boolean
  }

  export type DisponibiliteResponsableCreateWithoutResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteResponsableUncheckedCreateWithoutResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteResponsableCreateOrConnectWithoutResponsableInput = {
    where: DisponibiliteResponsableWhereUniqueInput
    create: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput>
  }

  export type DisponibiliteResponsableCreateManyResponsableInputEnvelope = {
    data: DisponibiliteResponsableCreateManyResponsableInput | DisponibiliteResponsableCreateManyResponsableInput[]
    skipDuplicates?: boolean
  }

  export type IndicateurAcademiqueUpsertWithWhereUniqueWithoutResponsableInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    update: XOR<IndicateurAcademiqueUpdateWithoutResponsableInput, IndicateurAcademiqueUncheckedUpdateWithoutResponsableInput>
    create: XOR<IndicateurAcademiqueCreateWithoutResponsableInput, IndicateurAcademiqueUncheckedCreateWithoutResponsableInput>
  }

  export type IndicateurAcademiqueUpdateWithWhereUniqueWithoutResponsableInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    data: XOR<IndicateurAcademiqueUpdateWithoutResponsableInput, IndicateurAcademiqueUncheckedUpdateWithoutResponsableInput>
  }

  export type IndicateurAcademiqueUpdateManyWithWhereWithoutResponsableInput = {
    where: IndicateurAcademiqueScalarWhereInput
    data: XOR<IndicateurAcademiqueUpdateManyMutationInput, IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableInput>
  }

  export type IndicateurAcademiqueScalarWhereInput = {
    AND?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
    OR?: IndicateurAcademiqueScalarWhereInput[]
    NOT?: IndicateurAcademiqueScalarWhereInput | IndicateurAcademiqueScalarWhereInput[]
    id?: StringFilter<"IndicateurAcademique"> | string
    nom?: StringFilter<"IndicateurAcademique"> | string
    description?: StringNullableFilter<"IndicateurAcademique"> | string | null
    valeurCible?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    valeurReelle?: FloatNullableFilter<"IndicateurAcademique"> | number | null
    periodicite?: StringFilter<"IndicateurAcademique"> | string
    methodeCalcul?: StringNullableFilter<"IndicateurAcademique"> | string | null
    unite?: StringFilter<"IndicateurAcademique"> | string
    type?: StringFilter<"IndicateurAcademique"> | string
    programmeId?: StringFilter<"IndicateurAcademique"> | string
    periodeId?: StringFilter<"IndicateurAcademique"> | string
    responsableId?: StringNullableFilter<"IndicateurAcademique"> | string | null
    dateCollecte?: DateTimeNullableFilter<"IndicateurAcademique"> | Date | string | null
    createdAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"IndicateurAcademique"> | Date | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutUserInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutUserInput, ModuleUncheckedUpdateWithoutUserInput>
    create: XOR<ModuleCreateWithoutUserInput, ModuleUncheckedCreateWithoutUserInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutUserInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutUserInput, ModuleUncheckedUpdateWithoutUserInput>
  }

  export type ModuleUpdateManyWithWhereWithoutUserInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutUserInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: StringFilter<"Module"> | string
    code?: StringFilter<"Module"> | string
    name?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    cm?: IntFilter<"Module"> | number
    td?: IntFilter<"Module"> | number
    tp?: IntFilter<"Module"> | number
    tpe?: IntFilter<"Module"> | number
    vht?: IntFilter<"Module"> | number
    coefficient?: IntFilter<"Module"> | number
    credits?: IntFilter<"Module"> | number
    status?: EnumStatusModuleFilter<"Module"> | $Enums.StatusModule
    progression?: IntFilter<"Module"> | number
    dateDebut?: DateTimeNullableFilter<"Module"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"Module"> | Date | string | null
    programmeId?: StringFilter<"Module"> | string
    intervenantId?: StringNullableFilter<"Module"> | string | null
    userId?: StringFilter<"Module"> | string
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type ProgrammeUpsertWithWhereUniqueWithoutUserInput = {
    where: ProgrammeWhereUniqueInput
    update: XOR<ProgrammeUpdateWithoutUserInput, ProgrammeUncheckedUpdateWithoutUserInput>
    create: XOR<ProgrammeCreateWithoutUserInput, ProgrammeUncheckedCreateWithoutUserInput>
  }

  export type ProgrammeUpdateWithWhereUniqueWithoutUserInput = {
    where: ProgrammeWhereUniqueInput
    data: XOR<ProgrammeUpdateWithoutUserInput, ProgrammeUncheckedUpdateWithoutUserInput>
  }

  export type ProgrammeUpdateManyWithWhereWithoutUserInput = {
    where: ProgrammeScalarWhereInput
    data: XOR<ProgrammeUpdateManyMutationInput, ProgrammeUncheckedUpdateManyWithoutUserInput>
  }

  export type ProgrammeScalarWhereInput = {
    AND?: ProgrammeScalarWhereInput | ProgrammeScalarWhereInput[]
    OR?: ProgrammeScalarWhereInput[]
    NOT?: ProgrammeScalarWhereInput | ProgrammeScalarWhereInput[]
    id?: StringFilter<"Programme"> | string
    name?: StringFilter<"Programme"> | string
    code?: StringFilter<"Programme"> | string
    description?: StringNullableFilter<"Programme"> | string | null
    semestre?: EnumSemestreFilter<"Programme"> | $Enums.Semestre
    niveau?: StringFilter<"Programme"> | string
    dateDebut?: DateTimeFilter<"Programme"> | Date | string
    dateFin?: DateTimeFilter<"Programme"> | Date | string
    status?: EnumStatusProgrammeFilter<"Programme"> | $Enums.StatusProgramme
    progression?: IntFilter<"Programme"> | number
    totalVHT?: IntFilter<"Programme"> | number
    userId?: StringFilter<"Programme"> | string
    createdAt?: DateTimeFilter<"Programme"> | Date | string
    updatedAt?: DateTimeFilter<"Programme"> | Date | string
  }

  export type RotationWeekendUpsertWithWhereUniqueWithoutResponsableInput = {
    where: RotationWeekendWhereUniqueInput
    update: XOR<RotationWeekendUpdateWithoutResponsableInput, RotationWeekendUncheckedUpdateWithoutResponsableInput>
    create: XOR<RotationWeekendCreateWithoutResponsableInput, RotationWeekendUncheckedCreateWithoutResponsableInput>
  }

  export type RotationWeekendUpdateWithWhereUniqueWithoutResponsableInput = {
    where: RotationWeekendWhereUniqueInput
    data: XOR<RotationWeekendUpdateWithoutResponsableInput, RotationWeekendUncheckedUpdateWithoutResponsableInput>
  }

  export type RotationWeekendUpdateManyWithWhereWithoutResponsableInput = {
    where: RotationWeekendScalarWhereInput
    data: XOR<RotationWeekendUpdateManyMutationInput, RotationWeekendUncheckedUpdateManyWithoutResponsableInput>
  }

  export type RotationWeekendScalarWhereInput = {
    AND?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
    OR?: RotationWeekendScalarWhereInput[]
    NOT?: RotationWeekendScalarWhereInput | RotationWeekendScalarWhereInput[]
    id?: StringFilter<"RotationWeekend"> | string
    dateDebut?: DateTimeFilter<"RotationWeekend"> | Date | string
    dateFin?: DateTimeFilter<"RotationWeekend"> | Date | string
    semaineNumero?: IntFilter<"RotationWeekend"> | number
    annee?: IntFilter<"RotationWeekend"> | number
    responsableId?: StringFilter<"RotationWeekend"> | string
    substitutId?: StringNullableFilter<"RotationWeekend"> | string | null
    status?: EnumStatutRotationFilter<"RotationWeekend"> | $Enums.StatutRotation
    nbSeancesTotal?: IntFilter<"RotationWeekend"> | number
    nbSeancesRealisees?: IntFilter<"RotationWeekend"> | number
    commentaire?: StringNullableFilter<"RotationWeekend"> | string | null
    estAbsence?: BoolFilter<"RotationWeekend"> | boolean
    notificationEnvoyee?: BoolFilter<"RotationWeekend"> | boolean
    rappelEnvoye?: BoolFilter<"RotationWeekend"> | boolean
    createdAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    updatedAt?: DateTimeFilter<"RotationWeekend"> | Date | string
    createdBy?: StringNullableFilter<"RotationWeekend"> | string | null
  }

  export type RotationWeekendUpsertWithWhereUniqueWithoutSubstitutInput = {
    where: RotationWeekendWhereUniqueInput
    update: XOR<RotationWeekendUpdateWithoutSubstitutInput, RotationWeekendUncheckedUpdateWithoutSubstitutInput>
    create: XOR<RotationWeekendCreateWithoutSubstitutInput, RotationWeekendUncheckedCreateWithoutSubstitutInput>
  }

  export type RotationWeekendUpdateWithWhereUniqueWithoutSubstitutInput = {
    where: RotationWeekendWhereUniqueInput
    data: XOR<RotationWeekendUpdateWithoutSubstitutInput, RotationWeekendUncheckedUpdateWithoutSubstitutInput>
  }

  export type RotationWeekendUpdateManyWithWhereWithoutSubstitutInput = {
    where: RotationWeekendScalarWhereInput
    data: XOR<RotationWeekendUpdateManyMutationInput, RotationWeekendUncheckedUpdateManyWithoutSubstitutInput>
  }

  export type DisponibiliteResponsableUpsertWithWhereUniqueWithoutResponsableInput = {
    where: DisponibiliteResponsableWhereUniqueInput
    update: XOR<DisponibiliteResponsableUpdateWithoutResponsableInput, DisponibiliteResponsableUncheckedUpdateWithoutResponsableInput>
    create: XOR<DisponibiliteResponsableCreateWithoutResponsableInput, DisponibiliteResponsableUncheckedCreateWithoutResponsableInput>
  }

  export type DisponibiliteResponsableUpdateWithWhereUniqueWithoutResponsableInput = {
    where: DisponibiliteResponsableWhereUniqueInput
    data: XOR<DisponibiliteResponsableUpdateWithoutResponsableInput, DisponibiliteResponsableUncheckedUpdateWithoutResponsableInput>
  }

  export type DisponibiliteResponsableUpdateManyWithWhereWithoutResponsableInput = {
    where: DisponibiliteResponsableScalarWhereInput
    data: XOR<DisponibiliteResponsableUpdateManyMutationInput, DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableInput>
  }

  export type DisponibiliteResponsableScalarWhereInput = {
    AND?: DisponibiliteResponsableScalarWhereInput | DisponibiliteResponsableScalarWhereInput[]
    OR?: DisponibiliteResponsableScalarWhereInput[]
    NOT?: DisponibiliteResponsableScalarWhereInput | DisponibiliteResponsableScalarWhereInput[]
    id?: StringFilter<"DisponibiliteResponsable"> | string
    responsableId?: StringFilter<"DisponibiliteResponsable"> | string
    dateDebut?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    dateFin?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    disponible?: BoolFilter<"DisponibiliteResponsable"> | boolean
    raison?: StringNullableFilter<"DisponibiliteResponsable"> | string | null
    createdAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteResponsable"> | Date | string
  }

  export type ActiviteAcademiqueCreateWithoutProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    periode: PeriodeAcademiqueCreateNestedOneWithoutActivitesAcademiquesInput
  }

  export type ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    periodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueCreateOrConnectWithoutProgrammeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    create: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput>
  }

  export type ActiviteAcademiqueCreateManyProgrammeInputEnvelope = {
    data: ActiviteAcademiqueCreateManyProgrammeInput | ActiviteAcademiqueCreateManyProgrammeInput[]
    skipDuplicates?: boolean
  }

  export type IndicateurAcademiqueCreateWithoutProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    periode: PeriodeAcademiqueCreateNestedOneWithoutIndicateursAcademiquesInput
    responsable?: UserCreateNestedOneWithoutIndicateursAcademiquesInput
  }

  export type IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    periodeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueCreateOrConnectWithoutProgrammeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    create: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput>
  }

  export type IndicateurAcademiqueCreateManyProgrammeInputEnvelope = {
    data: IndicateurAcademiqueCreateManyProgrammeInput | IndicateurAcademiqueCreateManyProgrammeInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutProgrammeInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutProgrammeInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutProgrammeInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput>
  }

  export type ModuleCreateManyProgrammeInputEnvelope = {
    data: ModuleCreateManyProgrammeInput | ModuleCreateManyProgrammeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutProgrammesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    modules?: ModuleCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateWithoutProgrammesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserCreateOrConnectWithoutProgrammesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgrammesInput, UserUncheckedCreateWithoutProgrammesInput>
  }

  export type ActiviteAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    update: XOR<ActiviteAcademiqueUpdateWithoutProgrammeInput, ActiviteAcademiqueUncheckedUpdateWithoutProgrammeInput>
    create: XOR<ActiviteAcademiqueCreateWithoutProgrammeInput, ActiviteAcademiqueUncheckedCreateWithoutProgrammeInput>
  }

  export type ActiviteAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    data: XOR<ActiviteAcademiqueUpdateWithoutProgrammeInput, ActiviteAcademiqueUncheckedUpdateWithoutProgrammeInput>
  }

  export type ActiviteAcademiqueUpdateManyWithWhereWithoutProgrammeInput = {
    where: ActiviteAcademiqueScalarWhereInput
    data: XOR<ActiviteAcademiqueUpdateManyMutationInput, ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeInput>
  }

  export type ActiviteAcademiqueScalarWhereInput = {
    AND?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
    OR?: ActiviteAcademiqueScalarWhereInput[]
    NOT?: ActiviteAcademiqueScalarWhereInput | ActiviteAcademiqueScalarWhereInput[]
    id?: StringFilter<"ActiviteAcademique"> | string
    nom?: StringFilter<"ActiviteAcademique"> | string
    description?: StringNullableFilter<"ActiviteAcademique"> | string | null
    datePrevue?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    dateReelle?: DateTimeNullableFilter<"ActiviteAcademique"> | Date | string | null
    type?: StringFilter<"ActiviteAcademique"> | string
    programmeId?: StringFilter<"ActiviteAcademique"> | string
    periodeId?: StringFilter<"ActiviteAcademique"> | string
    createdAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
    updatedAt?: DateTimeFilter<"ActiviteAcademique"> | Date | string
  }

  export type IndicateurAcademiqueUpsertWithWhereUniqueWithoutProgrammeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    update: XOR<IndicateurAcademiqueUpdateWithoutProgrammeInput, IndicateurAcademiqueUncheckedUpdateWithoutProgrammeInput>
    create: XOR<IndicateurAcademiqueCreateWithoutProgrammeInput, IndicateurAcademiqueUncheckedCreateWithoutProgrammeInput>
  }

  export type IndicateurAcademiqueUpdateWithWhereUniqueWithoutProgrammeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    data: XOR<IndicateurAcademiqueUpdateWithoutProgrammeInput, IndicateurAcademiqueUncheckedUpdateWithoutProgrammeInput>
  }

  export type IndicateurAcademiqueUpdateManyWithWhereWithoutProgrammeInput = {
    where: IndicateurAcademiqueScalarWhereInput
    data: XOR<IndicateurAcademiqueUpdateManyMutationInput, IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeInput>
  }

  export type ModuleUpsertWithWhereUniqueWithoutProgrammeInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutProgrammeInput, ModuleUncheckedUpdateWithoutProgrammeInput>
    create: XOR<ModuleCreateWithoutProgrammeInput, ModuleUncheckedCreateWithoutProgrammeInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutProgrammeInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutProgrammeInput, ModuleUncheckedUpdateWithoutProgrammeInput>
  }

  export type ModuleUpdateManyWithWhereWithoutProgrammeInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutProgrammeInput>
  }

  export type UserUpsertWithoutProgrammesInput = {
    update: XOR<UserUpdateWithoutProgrammesInput, UserUncheckedUpdateWithoutProgrammesInput>
    create: XOR<UserCreateWithoutProgrammesInput, UserUncheckedCreateWithoutProgrammesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgrammesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgrammesInput, UserUncheckedUpdateWithoutProgrammesInput>
  }

  export type UserUpdateWithoutProgrammesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateWithoutProgrammesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type DisponibiliteIntervenantCreateWithoutIntervenantInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisponibiliteIntervenantCreateOrConnectWithoutIntervenantInput = {
    where: DisponibiliteIntervenantWhereUniqueInput
    create: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput>
  }

  export type DisponibiliteIntervenantCreateManyIntervenantInputEnvelope = {
    data: DisponibiliteIntervenantCreateManyIntervenantInput | DisponibiliteIntervenantCreateManyIntervenantInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationEnseignementCreateWithoutIntervenantInput = {
    id?: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
    module: ModuleCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationEnseignementUncheckedCreateWithoutIntervenantInput = {
    id?: string
    moduleId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationEnseignementCreateOrConnectWithoutIntervenantInput = {
    where: EvaluationEnseignementWhereUniqueInput
    create: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput>
  }

  export type EvaluationEnseignementCreateManyIntervenantInputEnvelope = {
    data: EvaluationEnseignementCreateManyIntervenantInput | EvaluationEnseignementCreateManyIntervenantInput[]
    skipDuplicates?: boolean
  }

  export type ModuleCreateWithoutIntervenantInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutIntervenantInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutIntervenantInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput>
  }

  export type ModuleCreateManyIntervenantInputEnvelope = {
    data: ModuleCreateManyIntervenantInput | ModuleCreateManyIntervenantInput[]
    skipDuplicates?: boolean
  }

  export type SeanceCreateWithoutIntervenantInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitCreateNestedManyWithoutSeance2Input
    module: ModuleCreateNestedOneWithoutSeancesInput
  }

  export type SeanceUncheckedCreateWithoutIntervenantInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitUncheckedCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitUncheckedCreateNestedManyWithoutSeance2Input
  }

  export type SeanceCreateOrConnectWithoutIntervenantInput = {
    where: SeanceWhereUniqueInput
    create: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput>
  }

  export type SeanceCreateManyIntervenantInputEnvelope = {
    data: SeanceCreateManyIntervenantInput | SeanceCreateManyIntervenantInput[]
    skipDuplicates?: boolean
  }

  export type DisponibiliteIntervenantUpsertWithWhereUniqueWithoutIntervenantInput = {
    where: DisponibiliteIntervenantWhereUniqueInput
    update: XOR<DisponibiliteIntervenantUpdateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedUpdateWithoutIntervenantInput>
    create: XOR<DisponibiliteIntervenantCreateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedCreateWithoutIntervenantInput>
  }

  export type DisponibiliteIntervenantUpdateWithWhereUniqueWithoutIntervenantInput = {
    where: DisponibiliteIntervenantWhereUniqueInput
    data: XOR<DisponibiliteIntervenantUpdateWithoutIntervenantInput, DisponibiliteIntervenantUncheckedUpdateWithoutIntervenantInput>
  }

  export type DisponibiliteIntervenantUpdateManyWithWhereWithoutIntervenantInput = {
    where: DisponibiliteIntervenantScalarWhereInput
    data: XOR<DisponibiliteIntervenantUpdateManyMutationInput, DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantInput>
  }

  export type DisponibiliteIntervenantScalarWhereInput = {
    AND?: DisponibiliteIntervenantScalarWhereInput | DisponibiliteIntervenantScalarWhereInput[]
    OR?: DisponibiliteIntervenantScalarWhereInput[]
    NOT?: DisponibiliteIntervenantScalarWhereInput | DisponibiliteIntervenantScalarWhereInput[]
    id?: StringFilter<"DisponibiliteIntervenant"> | string
    jourSemaine?: IntFilter<"DisponibiliteIntervenant"> | number
    heureDebut?: StringFilter<"DisponibiliteIntervenant"> | string
    heureFin?: StringFilter<"DisponibiliteIntervenant"> | string
    type?: EnumTypeDisponibiliteFilter<"DisponibiliteIntervenant"> | $Enums.TypeDisponibilite
    dateDebut?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"DisponibiliteIntervenant"> | Date | string | null
    recurrent?: BoolFilter<"DisponibiliteIntervenant"> | boolean
    intervenantId?: StringFilter<"DisponibiliteIntervenant"> | string
    createdAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
    updatedAt?: DateTimeFilter<"DisponibiliteIntervenant"> | Date | string
  }

  export type EvaluationEnseignementUpsertWithWhereUniqueWithoutIntervenantInput = {
    where: EvaluationEnseignementWhereUniqueInput
    update: XOR<EvaluationEnseignementUpdateWithoutIntervenantInput, EvaluationEnseignementUncheckedUpdateWithoutIntervenantInput>
    create: XOR<EvaluationEnseignementCreateWithoutIntervenantInput, EvaluationEnseignementUncheckedCreateWithoutIntervenantInput>
  }

  export type EvaluationEnseignementUpdateWithWhereUniqueWithoutIntervenantInput = {
    where: EvaluationEnseignementWhereUniqueInput
    data: XOR<EvaluationEnseignementUpdateWithoutIntervenantInput, EvaluationEnseignementUncheckedUpdateWithoutIntervenantInput>
  }

  export type EvaluationEnseignementUpdateManyWithWhereWithoutIntervenantInput = {
    where: EvaluationEnseignementScalarWhereInput
    data: XOR<EvaluationEnseignementUpdateManyMutationInput, EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantInput>
  }

  export type EvaluationEnseignementScalarWhereInput = {
    AND?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
    OR?: EvaluationEnseignementScalarWhereInput[]
    NOT?: EvaluationEnseignementScalarWhereInput | EvaluationEnseignementScalarWhereInput[]
    id?: StringFilter<"EvaluationEnseignement"> | string
    moduleId?: StringFilter<"EvaluationEnseignement"> | string
    intervenantId?: StringFilter<"EvaluationEnseignement"> | string
    dateEnvoi?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateDebut?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    dateFin?: DateTimeNullableFilter<"EvaluationEnseignement"> | Date | string | null
    lienEvaluation?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    noteQualiteCours?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteQualitePedagogie?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteDisponibilite?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    noteMoyenne?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    nombreReponses?: IntFilter<"EvaluationEnseignement"> | number
    nombreInvitations?: IntFilter<"EvaluationEnseignement"> | number
    tauxParticipation?: FloatNullableFilter<"EvaluationEnseignement"> | number | null
    commentaires?: StringNullableFilter<"EvaluationEnseignement"> | string | null
    statut?: EnumStatutCampagneFilter<"EvaluationEnseignement"> | $Enums.StatutCampagne
    createdAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
    updatedAt?: DateTimeFilter<"EvaluationEnseignement"> | Date | string
  }

  export type ModuleUpsertWithWhereUniqueWithoutIntervenantInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutIntervenantInput, ModuleUncheckedUpdateWithoutIntervenantInput>
    create: XOR<ModuleCreateWithoutIntervenantInput, ModuleUncheckedCreateWithoutIntervenantInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutIntervenantInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutIntervenantInput, ModuleUncheckedUpdateWithoutIntervenantInput>
  }

  export type ModuleUpdateManyWithWhereWithoutIntervenantInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutIntervenantInput>
  }

  export type SeanceUpsertWithWhereUniqueWithoutIntervenantInput = {
    where: SeanceWhereUniqueInput
    update: XOR<SeanceUpdateWithoutIntervenantInput, SeanceUncheckedUpdateWithoutIntervenantInput>
    create: XOR<SeanceCreateWithoutIntervenantInput, SeanceUncheckedCreateWithoutIntervenantInput>
  }

  export type SeanceUpdateWithWhereUniqueWithoutIntervenantInput = {
    where: SeanceWhereUniqueInput
    data: XOR<SeanceUpdateWithoutIntervenantInput, SeanceUncheckedUpdateWithoutIntervenantInput>
  }

  export type SeanceUpdateManyWithWhereWithoutIntervenantInput = {
    where: SeanceScalarWhereInput
    data: XOR<SeanceUpdateManyMutationInput, SeanceUncheckedUpdateManyWithoutIntervenantInput>
  }

  export type SeanceScalarWhereInput = {
    AND?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
    OR?: SeanceScalarWhereInput[]
    NOT?: SeanceScalarWhereInput | SeanceScalarWhereInput[]
    id?: StringFilter<"Seance"> | string
    dateSeance?: DateTimeFilter<"Seance"> | Date | string
    heureDebut?: StringFilter<"Seance"> | string
    heureFin?: StringFilter<"Seance"> | string
    duree?: IntFilter<"Seance"> | number
    typeSeance?: EnumTypeSeanceFilter<"Seance"> | $Enums.TypeSeance
    salle?: StringNullableFilter<"Seance"> | string | null
    batiment?: StringNullableFilter<"Seance"> | string | null
    status?: EnumStatusSeanceFilter<"Seance"> | $Enums.StatusSeance
    moduleId?: StringFilter<"Seance"> | string
    intervenantId?: StringFilter<"Seance"> | string
    createdAt?: DateTimeFilter<"Seance"> | Date | string
    updatedAt?: DateTimeFilter<"Seance"> | Date | string
    notes?: StringNullableFilter<"Seance"> | string | null
    objectifs?: StringNullableFilter<"Seance"> | string | null
  }

  export type IntervenantCreateWithoutDisponibilitesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutIntervenantInput
    modules?: ModuleCreateNestedManyWithoutIntervenantInput
    seances?: SeanceCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUncheckedCreateWithoutDisponibilitesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutIntervenantInput
    modules?: ModuleUncheckedCreateNestedManyWithoutIntervenantInput
    seances?: SeanceUncheckedCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantCreateOrConnectWithoutDisponibilitesInput = {
    where: IntervenantWhereUniqueInput
    create: XOR<IntervenantCreateWithoutDisponibilitesInput, IntervenantUncheckedCreateWithoutDisponibilitesInput>
  }

  export type IntervenantUpsertWithoutDisponibilitesInput = {
    update: XOR<IntervenantUpdateWithoutDisponibilitesInput, IntervenantUncheckedUpdateWithoutDisponibilitesInput>
    create: XOR<IntervenantCreateWithoutDisponibilitesInput, IntervenantUncheckedCreateWithoutDisponibilitesInput>
    where?: IntervenantWhereInput
  }

  export type IntervenantUpdateToOneWithWhereWithoutDisponibilitesInput = {
    where?: IntervenantWhereInput
    data: XOR<IntervenantUpdateWithoutDisponibilitesInput, IntervenantUncheckedUpdateWithoutDisponibilitesInput>
  }

  export type IntervenantUpdateWithoutDisponibilitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationEnseignementUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantUncheckedUpdateWithoutDisponibilitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutIntervenantNestedInput
  }

  export type EvaluationEnseignementCreateWithoutModuleInput = {
    id?: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
    intervenant: IntervenantCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationEnseignementUncheckedCreateWithoutModuleInput = {
    id?: string
    intervenantId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationEnseignementCreateOrConnectWithoutModuleInput = {
    where: EvaluationEnseignementWhereUniqueInput
    create: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput>
  }

  export type EvaluationEnseignementCreateManyModuleInputEnvelope = {
    data: EvaluationEnseignementCreateManyModuleInput | EvaluationEnseignementCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type IntervenantCreateWithoutModulesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutIntervenantInput
    seances?: SeanceCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUncheckedCreateWithoutModulesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantUncheckedCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutIntervenantInput
    seances?: SeanceUncheckedCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantCreateOrConnectWithoutModulesInput = {
    where: IntervenantWhereUniqueInput
    create: XOR<IntervenantCreateWithoutModulesInput, IntervenantUncheckedCreateWithoutModulesInput>
  }

  export type ProgrammeCreateWithoutModulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutProgrammeInput
    user: UserCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateWithoutModulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeCreateOrConnectWithoutModulesInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutModulesInput, ProgrammeUncheckedCreateWithoutModulesInput>
  }

  export type UserCreateWithoutModulesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateWithoutModulesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserCreateOrConnectWithoutModulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutModulesInput, UserUncheckedCreateWithoutModulesInput>
  }

  export type ResultatEtudiantCreateWithoutModuleInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatEtudiantUncheckedCreateWithoutModuleInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatEtudiantCreateOrConnectWithoutModuleInput = {
    where: ResultatEtudiantWhereUniqueInput
    create: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput>
  }

  export type ResultatEtudiantCreateManyModuleInputEnvelope = {
    data: ResultatEtudiantCreateManyModuleInput | ResultatEtudiantCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type SeanceCreateWithoutModuleInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitCreateNestedManyWithoutSeance2Input
    intervenant: IntervenantCreateNestedOneWithoutSeancesInput
  }

  export type SeanceUncheckedCreateWithoutModuleInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitUncheckedCreateNestedManyWithoutSeance1Input
    conflitsAsSeance2?: ConflitUncheckedCreateNestedManyWithoutSeance2Input
  }

  export type SeanceCreateOrConnectWithoutModuleInput = {
    where: SeanceWhereUniqueInput
    create: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput>
  }

  export type SeanceCreateManyModuleInputEnvelope = {
    data: SeanceCreateManyModuleInput | SeanceCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type EvaluationEnseignementUpsertWithWhereUniqueWithoutModuleInput = {
    where: EvaluationEnseignementWhereUniqueInput
    update: XOR<EvaluationEnseignementUpdateWithoutModuleInput, EvaluationEnseignementUncheckedUpdateWithoutModuleInput>
    create: XOR<EvaluationEnseignementCreateWithoutModuleInput, EvaluationEnseignementUncheckedCreateWithoutModuleInput>
  }

  export type EvaluationEnseignementUpdateWithWhereUniqueWithoutModuleInput = {
    where: EvaluationEnseignementWhereUniqueInput
    data: XOR<EvaluationEnseignementUpdateWithoutModuleInput, EvaluationEnseignementUncheckedUpdateWithoutModuleInput>
  }

  export type EvaluationEnseignementUpdateManyWithWhereWithoutModuleInput = {
    where: EvaluationEnseignementScalarWhereInput
    data: XOR<EvaluationEnseignementUpdateManyMutationInput, EvaluationEnseignementUncheckedUpdateManyWithoutModuleInput>
  }

  export type IntervenantUpsertWithoutModulesInput = {
    update: XOR<IntervenantUpdateWithoutModulesInput, IntervenantUncheckedUpdateWithoutModulesInput>
    create: XOR<IntervenantCreateWithoutModulesInput, IntervenantUncheckedCreateWithoutModulesInput>
    where?: IntervenantWhereInput
  }

  export type IntervenantUpdateToOneWithWhereWithoutModulesInput = {
    where?: IntervenantWhereInput
    data: XOR<IntervenantUpdateWithoutModulesInput, IntervenantUncheckedUpdateWithoutModulesInput>
  }

  export type IntervenantUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutIntervenantNestedInput
  }

  export type ProgrammeUpsertWithoutModulesInput = {
    update: XOR<ProgrammeUpdateWithoutModulesInput, ProgrammeUncheckedUpdateWithoutModulesInput>
    create: XOR<ProgrammeCreateWithoutModulesInput, ProgrammeUncheckedCreateWithoutModulesInput>
    where?: ProgrammeWhereInput
  }

  export type ProgrammeUpdateToOneWithWhereWithoutModulesInput = {
    where?: ProgrammeWhereInput
    data: XOR<ProgrammeUpdateWithoutModulesInput, ProgrammeUncheckedUpdateWithoutModulesInput>
  }

  export type ProgrammeUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutProgrammeNestedInput
    user?: UserUpdateOneRequiredWithoutProgrammesNestedInput
  }

  export type ProgrammeUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
  }

  export type UserUpsertWithoutModulesInput = {
    update: XOR<UserUpdateWithoutModulesInput, UserUncheckedUpdateWithoutModulesInput>
    create: XOR<UserCreateWithoutModulesInput, UserUncheckedCreateWithoutModulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutModulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutModulesInput, UserUncheckedUpdateWithoutModulesInput>
  }

  export type UserUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateWithoutModulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type ResultatEtudiantUpsertWithWhereUniqueWithoutModuleInput = {
    where: ResultatEtudiantWhereUniqueInput
    update: XOR<ResultatEtudiantUpdateWithoutModuleInput, ResultatEtudiantUncheckedUpdateWithoutModuleInput>
    create: XOR<ResultatEtudiantCreateWithoutModuleInput, ResultatEtudiantUncheckedCreateWithoutModuleInput>
  }

  export type ResultatEtudiantUpdateWithWhereUniqueWithoutModuleInput = {
    where: ResultatEtudiantWhereUniqueInput
    data: XOR<ResultatEtudiantUpdateWithoutModuleInput, ResultatEtudiantUncheckedUpdateWithoutModuleInput>
  }

  export type ResultatEtudiantUpdateManyWithWhereWithoutModuleInput = {
    where: ResultatEtudiantScalarWhereInput
    data: XOR<ResultatEtudiantUpdateManyMutationInput, ResultatEtudiantUncheckedUpdateManyWithoutModuleInput>
  }

  export type ResultatEtudiantScalarWhereInput = {
    AND?: ResultatEtudiantScalarWhereInput | ResultatEtudiantScalarWhereInput[]
    OR?: ResultatEtudiantScalarWhereInput[]
    NOT?: ResultatEtudiantScalarWhereInput | ResultatEtudiantScalarWhereInput[]
    id?: StringFilter<"ResultatEtudiant"> | string
    numeroEtudiant?: StringFilter<"ResultatEtudiant"> | string
    nomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    prenomEtudiant?: StringFilter<"ResultatEtudiant"> | string
    emailEtudiant?: StringNullableFilter<"ResultatEtudiant"> | string | null
    moduleId?: StringFilter<"ResultatEtudiant"> | string
    noteCC?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteExamen?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    noteFinale?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    statut?: StringFilter<"ResultatEtudiant"> | string
    mention?: StringNullableFilter<"ResultatEtudiant"> | string | null
    vhDeroule?: IntFilter<"ResultatEtudiant"> | number
    progressionPct?: IntFilter<"ResultatEtudiant"> | number
    presences?: IntFilter<"ResultatEtudiant"> | number
    absences?: IntFilter<"ResultatEtudiant"> | number
    tauxPresence?: FloatNullableFilter<"ResultatEtudiant"> | number | null
    createdAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
    updatedAt?: DateTimeFilter<"ResultatEtudiant"> | Date | string
  }

  export type SeanceUpsertWithWhereUniqueWithoutModuleInput = {
    where: SeanceWhereUniqueInput
    update: XOR<SeanceUpdateWithoutModuleInput, SeanceUncheckedUpdateWithoutModuleInput>
    create: XOR<SeanceCreateWithoutModuleInput, SeanceUncheckedCreateWithoutModuleInput>
  }

  export type SeanceUpdateWithWhereUniqueWithoutModuleInput = {
    where: SeanceWhereUniqueInput
    data: XOR<SeanceUpdateWithoutModuleInput, SeanceUncheckedUpdateWithoutModuleInput>
  }

  export type SeanceUpdateManyWithWhereWithoutModuleInput = {
    where: SeanceScalarWhereInput
    data: XOR<SeanceUpdateManyMutationInput, SeanceUncheckedUpdateManyWithoutModuleInput>
  }

  export type ConflitCreateWithoutSeance1Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
    seance2?: SeanceCreateNestedOneWithoutConflitsAsSeance2Input
  }

  export type ConflitUncheckedCreateWithoutSeance1Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId2?: string | null
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitCreateOrConnectWithoutSeance1Input = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input>
  }

  export type ConflitCreateManySeance1InputEnvelope = {
    data: ConflitCreateManySeance1Input | ConflitCreateManySeance1Input[]
    skipDuplicates?: boolean
  }

  export type ConflitCreateWithoutSeance2Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
    seance1: SeanceCreateNestedOneWithoutConflitsAsSeance1Input
  }

  export type ConflitUncheckedCreateWithoutSeance2Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId1: string
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitCreateOrConnectWithoutSeance2Input = {
    where: ConflitWhereUniqueInput
    create: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input>
  }

  export type ConflitCreateManySeance2InputEnvelope = {
    data: ConflitCreateManySeance2Input | ConflitCreateManySeance2Input[]
    skipDuplicates?: boolean
  }

  export type IntervenantCreateWithoutSeancesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutIntervenantInput
    modules?: ModuleCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUncheckedCreateWithoutSeancesInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantUncheckedCreateNestedManyWithoutIntervenantInput
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutIntervenantInput
    modules?: ModuleUncheckedCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantCreateOrConnectWithoutSeancesInput = {
    where: IntervenantWhereUniqueInput
    create: XOR<IntervenantCreateWithoutSeancesInput, IntervenantUncheckedCreateWithoutSeancesInput>
  }

  export type ModuleCreateWithoutSeancesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutSeancesInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutSeancesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutSeancesInput, ModuleUncheckedCreateWithoutSeancesInput>
  }

  export type ConflitUpsertWithWhereUniqueWithoutSeance1Input = {
    where: ConflitWhereUniqueInput
    update: XOR<ConflitUpdateWithoutSeance1Input, ConflitUncheckedUpdateWithoutSeance1Input>
    create: XOR<ConflitCreateWithoutSeance1Input, ConflitUncheckedCreateWithoutSeance1Input>
  }

  export type ConflitUpdateWithWhereUniqueWithoutSeance1Input = {
    where: ConflitWhereUniqueInput
    data: XOR<ConflitUpdateWithoutSeance1Input, ConflitUncheckedUpdateWithoutSeance1Input>
  }

  export type ConflitUpdateManyWithWhereWithoutSeance1Input = {
    where: ConflitScalarWhereInput
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyWithoutSeance1Input>
  }

  export type ConflitScalarWhereInput = {
    AND?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
    OR?: ConflitScalarWhereInput[]
    NOT?: ConflitScalarWhereInput | ConflitScalarWhereInput[]
    id?: StringFilter<"Conflit"> | string
    type?: EnumTypeConflitFilter<"Conflit"> | $Enums.TypeConflit
    description?: StringFilter<"Conflit"> | string
    seanceId1?: StringFilter<"Conflit"> | string
    seanceId2?: StringNullableFilter<"Conflit"> | string | null
    ressourceType?: StringFilter<"Conflit"> | string
    ressourceId?: StringFilter<"Conflit"> | string
    resolu?: BoolFilter<"Conflit"> | boolean
    resolution?: StringNullableFilter<"Conflit"> | string | null
    createdAt?: DateTimeFilter<"Conflit"> | Date | string
    updatedAt?: DateTimeFilter<"Conflit"> | Date | string
    resoluLe?: DateTimeNullableFilter<"Conflit"> | Date | string | null
    resoluPar?: StringNullableFilter<"Conflit"> | string | null
    severite?: EnumSeveriteConflitFilter<"Conflit"> | $Enums.SeveriteConflit
  }

  export type ConflitUpsertWithWhereUniqueWithoutSeance2Input = {
    where: ConflitWhereUniqueInput
    update: XOR<ConflitUpdateWithoutSeance2Input, ConflitUncheckedUpdateWithoutSeance2Input>
    create: XOR<ConflitCreateWithoutSeance2Input, ConflitUncheckedCreateWithoutSeance2Input>
  }

  export type ConflitUpdateWithWhereUniqueWithoutSeance2Input = {
    where: ConflitWhereUniqueInput
    data: XOR<ConflitUpdateWithoutSeance2Input, ConflitUncheckedUpdateWithoutSeance2Input>
  }

  export type ConflitUpdateManyWithWhereWithoutSeance2Input = {
    where: ConflitScalarWhereInput
    data: XOR<ConflitUpdateManyMutationInput, ConflitUncheckedUpdateManyWithoutSeance2Input>
  }

  export type IntervenantUpsertWithoutSeancesInput = {
    update: XOR<IntervenantUpdateWithoutSeancesInput, IntervenantUncheckedUpdateWithoutSeancesInput>
    create: XOR<IntervenantCreateWithoutSeancesInput, IntervenantUncheckedCreateWithoutSeancesInput>
    where?: IntervenantWhereInput
  }

  export type IntervenantUpdateToOneWithWhereWithoutSeancesInput = {
    where?: IntervenantWhereInput
    data: XOR<IntervenantUpdateWithoutSeancesInput, IntervenantUncheckedUpdateWithoutSeancesInput>
  }

  export type IntervenantUpdateWithoutSeancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantUncheckedUpdateWithoutSeancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantNestedInput
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutIntervenantNestedInput
  }

  export type ModuleUpsertWithoutSeancesInput = {
    update: XOR<ModuleUpdateWithoutSeancesInput, ModuleUncheckedUpdateWithoutSeancesInput>
    create: XOR<ModuleCreateWithoutSeancesInput, ModuleUncheckedCreateWithoutSeancesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutSeancesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutSeancesInput, ModuleUncheckedUpdateWithoutSeancesInput>
  }

  export type ModuleUpdateWithoutSeancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutSeancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type SeanceCreateWithoutConflitsAsSeance1Input = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance2?: ConflitCreateNestedManyWithoutSeance2Input
    intervenant: IntervenantCreateNestedOneWithoutSeancesInput
    module: ModuleCreateNestedOneWithoutSeancesInput
  }

  export type SeanceUncheckedCreateWithoutConflitsAsSeance1Input = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance2?: ConflitUncheckedCreateNestedManyWithoutSeance2Input
  }

  export type SeanceCreateOrConnectWithoutConflitsAsSeance1Input = {
    where: SeanceWhereUniqueInput
    create: XOR<SeanceCreateWithoutConflitsAsSeance1Input, SeanceUncheckedCreateWithoutConflitsAsSeance1Input>
  }

  export type SeanceCreateWithoutConflitsAsSeance2Input = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitCreateNestedManyWithoutSeance1Input
    intervenant: IntervenantCreateNestedOneWithoutSeancesInput
    module: ModuleCreateNestedOneWithoutSeancesInput
  }

  export type SeanceUncheckedCreateWithoutConflitsAsSeance2Input = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
    conflitsAsSeance1?: ConflitUncheckedCreateNestedManyWithoutSeance1Input
  }

  export type SeanceCreateOrConnectWithoutConflitsAsSeance2Input = {
    where: SeanceWhereUniqueInput
    create: XOR<SeanceCreateWithoutConflitsAsSeance2Input, SeanceUncheckedCreateWithoutConflitsAsSeance2Input>
  }

  export type SeanceUpsertWithoutConflitsAsSeance1Input = {
    update: XOR<SeanceUpdateWithoutConflitsAsSeance1Input, SeanceUncheckedUpdateWithoutConflitsAsSeance1Input>
    create: XOR<SeanceCreateWithoutConflitsAsSeance1Input, SeanceUncheckedCreateWithoutConflitsAsSeance1Input>
    where?: SeanceWhereInput
  }

  export type SeanceUpdateToOneWithWhereWithoutConflitsAsSeance1Input = {
    where?: SeanceWhereInput
    data: XOR<SeanceUpdateWithoutConflitsAsSeance1Input, SeanceUncheckedUpdateWithoutConflitsAsSeance1Input>
  }

  export type SeanceUpdateWithoutConflitsAsSeance1Input = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance2?: ConflitUpdateManyWithoutSeance2NestedInput
    intervenant?: IntervenantUpdateOneRequiredWithoutSeancesNestedInput
    module?: ModuleUpdateOneRequiredWithoutSeancesNestedInput
  }

  export type SeanceUncheckedUpdateWithoutConflitsAsSeance1Input = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance2?: ConflitUncheckedUpdateManyWithoutSeance2NestedInput
  }

  export type SeanceUpsertWithoutConflitsAsSeance2Input = {
    update: XOR<SeanceUpdateWithoutConflitsAsSeance2Input, SeanceUncheckedUpdateWithoutConflitsAsSeance2Input>
    create: XOR<SeanceCreateWithoutConflitsAsSeance2Input, SeanceUncheckedCreateWithoutConflitsAsSeance2Input>
    where?: SeanceWhereInput
  }

  export type SeanceUpdateToOneWithWhereWithoutConflitsAsSeance2Input = {
    where?: SeanceWhereInput
    data: XOR<SeanceUpdateWithoutConflitsAsSeance2Input, SeanceUncheckedUpdateWithoutConflitsAsSeance2Input>
  }

  export type SeanceUpdateWithoutConflitsAsSeance2Input = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUpdateManyWithoutSeance1NestedInput
    intervenant?: IntervenantUpdateOneRequiredWithoutSeancesNestedInput
    module?: ModuleUpdateOneRequiredWithoutSeancesNestedInput
  }

  export type SeanceUncheckedUpdateWithoutConflitsAsSeance2Input = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUncheckedUpdateManyWithoutSeance1NestedInput
  }

  export type ActiviteAcademiqueCreateWithoutPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    programme: ProgrammeCreateNestedOneWithoutActivitesAcademiquesInput
  }

  export type ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    programmeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueCreateOrConnectWithoutPeriodeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    create: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput>
  }

  export type ActiviteAcademiqueCreateManyPeriodeInputEnvelope = {
    data: ActiviteAcademiqueCreateManyPeriodeInput | ActiviteAcademiqueCreateManyPeriodeInput[]
    skipDuplicates?: boolean
  }

  export type IndicateurAcademiqueCreateWithoutPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    programme: ProgrammeCreateNestedOneWithoutIndicateursAcademiquesInput
    responsable?: UserCreateNestedOneWithoutIndicateursAcademiquesInput
  }

  export type IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueCreateOrConnectWithoutPeriodeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    create: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput>
  }

  export type IndicateurAcademiqueCreateManyPeriodeInputEnvelope = {
    data: IndicateurAcademiqueCreateManyPeriodeInput | IndicateurAcademiqueCreateManyPeriodeInput[]
    skipDuplicates?: boolean
  }

  export type ActiviteAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    update: XOR<ActiviteAcademiqueUpdateWithoutPeriodeInput, ActiviteAcademiqueUncheckedUpdateWithoutPeriodeInput>
    create: XOR<ActiviteAcademiqueCreateWithoutPeriodeInput, ActiviteAcademiqueUncheckedCreateWithoutPeriodeInput>
  }

  export type ActiviteAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput = {
    where: ActiviteAcademiqueWhereUniqueInput
    data: XOR<ActiviteAcademiqueUpdateWithoutPeriodeInput, ActiviteAcademiqueUncheckedUpdateWithoutPeriodeInput>
  }

  export type ActiviteAcademiqueUpdateManyWithWhereWithoutPeriodeInput = {
    where: ActiviteAcademiqueScalarWhereInput
    data: XOR<ActiviteAcademiqueUpdateManyMutationInput, ActiviteAcademiqueUncheckedUpdateManyWithoutPeriodeInput>
  }

  export type IndicateurAcademiqueUpsertWithWhereUniqueWithoutPeriodeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    update: XOR<IndicateurAcademiqueUpdateWithoutPeriodeInput, IndicateurAcademiqueUncheckedUpdateWithoutPeriodeInput>
    create: XOR<IndicateurAcademiqueCreateWithoutPeriodeInput, IndicateurAcademiqueUncheckedCreateWithoutPeriodeInput>
  }

  export type IndicateurAcademiqueUpdateWithWhereUniqueWithoutPeriodeInput = {
    where: IndicateurAcademiqueWhereUniqueInput
    data: XOR<IndicateurAcademiqueUpdateWithoutPeriodeInput, IndicateurAcademiqueUncheckedUpdateWithoutPeriodeInput>
  }

  export type IndicateurAcademiqueUpdateManyWithWhereWithoutPeriodeInput = {
    where: IndicateurAcademiqueScalarWhereInput
    data: XOR<IndicateurAcademiqueUpdateManyMutationInput, IndicateurAcademiqueUncheckedUpdateManyWithoutPeriodeInput>
  }

  export type PeriodeAcademiqueCreateWithoutActivitesAcademiquesInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueUncheckedCreateWithoutActivitesAcademiquesInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueCreateOrConnectWithoutActivitesAcademiquesInput = {
    where: PeriodeAcademiqueWhereUniqueInput
    create: XOR<PeriodeAcademiqueCreateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutActivitesAcademiquesInput>
  }

  export type ProgrammeCreateWithoutActivitesAcademiquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutProgrammeInput
    modules?: ModuleCreateNestedManyWithoutProgrammeInput
    user: UserCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateWithoutActivitesAcademiquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeCreateOrConnectWithoutActivitesAcademiquesInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutActivitesAcademiquesInput, ProgrammeUncheckedCreateWithoutActivitesAcademiquesInput>
  }

  export type PeriodeAcademiqueUpsertWithoutActivitesAcademiquesInput = {
    update: XOR<PeriodeAcademiqueUpdateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedUpdateWithoutActivitesAcademiquesInput>
    create: XOR<PeriodeAcademiqueCreateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutActivitesAcademiquesInput>
    where?: PeriodeAcademiqueWhereInput
  }

  export type PeriodeAcademiqueUpdateToOneWithWhereWithoutActivitesAcademiquesInput = {
    where?: PeriodeAcademiqueWhereInput
    data: XOR<PeriodeAcademiqueUpdateWithoutActivitesAcademiquesInput, PeriodeAcademiqueUncheckedUpdateWithoutActivitesAcademiquesInput>
  }

  export type PeriodeAcademiqueUpdateWithoutActivitesAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutPeriodeNestedInput
  }

  export type PeriodeAcademiqueUncheckedUpdateWithoutActivitesAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput
  }

  export type ProgrammeUpsertWithoutActivitesAcademiquesInput = {
    update: XOR<ProgrammeUpdateWithoutActivitesAcademiquesInput, ProgrammeUncheckedUpdateWithoutActivitesAcademiquesInput>
    create: XOR<ProgrammeCreateWithoutActivitesAcademiquesInput, ProgrammeUncheckedCreateWithoutActivitesAcademiquesInput>
    where?: ProgrammeWhereInput
  }

  export type ProgrammeUpdateToOneWithWhereWithoutActivitesAcademiquesInput = {
    where?: ProgrammeWhereInput
    data: XOR<ProgrammeUpdateWithoutActivitesAcademiquesInput, ProgrammeUncheckedUpdateWithoutActivitesAcademiquesInput>
  }

  export type ProgrammeUpdateWithoutActivitesAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUpdateManyWithoutProgrammeNestedInput
    user?: UserUpdateOneRequiredWithoutProgrammesNestedInput
  }

  export type ProgrammeUncheckedUpdateWithoutActivitesAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProgrammeNestedInput
  }

  export type PeriodeAcademiqueCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueUncheckedCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    nom: string
    annee: string
    debutS1: Date | string
    finS1: Date | string
    debutS2: Date | string
    finS2: Date | string
    vacancesNoel: Date | string
    finVacancesNoel: Date | string
    vacancesPaques?: Date | string | null
    finVacancesPaques?: Date | string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutPeriodeInput
  }

  export type PeriodeAcademiqueCreateOrConnectWithoutIndicateursAcademiquesInput = {
    where: PeriodeAcademiqueWhereUniqueInput
    create: XOR<PeriodeAcademiqueCreateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutIndicateursAcademiquesInput>
  }

  export type ProgrammeCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueCreateNestedManyWithoutProgrammeInput
    modules?: ModuleCreateNestedManyWithoutProgrammeInput
    user: UserCreateNestedOneWithoutProgrammesInput
  }

  export type ProgrammeUncheckedCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedCreateNestedManyWithoutProgrammeInput
    modules?: ModuleUncheckedCreateNestedManyWithoutProgrammeInput
  }

  export type ProgrammeCreateOrConnectWithoutIndicateursAcademiquesInput = {
    where: ProgrammeWhereUniqueInput
    create: XOR<ProgrammeCreateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedCreateWithoutIndicateursAcademiquesInput>
  }

  export type UserCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    modules?: ModuleCreateNestedManyWithoutUserInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateWithoutIndicateursAcademiquesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserCreateOrConnectWithoutIndicateursAcademiquesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIndicateursAcademiquesInput, UserUncheckedCreateWithoutIndicateursAcademiquesInput>
  }

  export type PeriodeAcademiqueUpsertWithoutIndicateursAcademiquesInput = {
    update: XOR<PeriodeAcademiqueUpdateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedUpdateWithoutIndicateursAcademiquesInput>
    create: XOR<PeriodeAcademiqueCreateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedCreateWithoutIndicateursAcademiquesInput>
    where?: PeriodeAcademiqueWhereInput
  }

  export type PeriodeAcademiqueUpdateToOneWithWhereWithoutIndicateursAcademiquesInput = {
    where?: PeriodeAcademiqueWhereInput
    data: XOR<PeriodeAcademiqueUpdateWithoutIndicateursAcademiquesInput, PeriodeAcademiqueUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type PeriodeAcademiqueUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutPeriodeNestedInput
  }

  export type PeriodeAcademiqueUncheckedUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    annee?: StringFieldUpdateOperationsInput | string
    debutS1?: DateTimeFieldUpdateOperationsInput | Date | string
    finS1?: DateTimeFieldUpdateOperationsInput | Date | string
    debutS2?: DateTimeFieldUpdateOperationsInput | Date | string
    finS2?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    finVacancesNoel?: DateTimeFieldUpdateOperationsInput | Date | string
    vacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finVacancesPaques?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutPeriodeNestedInput
  }

  export type ProgrammeUpsertWithoutIndicateursAcademiquesInput = {
    update: XOR<ProgrammeUpdateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedUpdateWithoutIndicateursAcademiquesInput>
    create: XOR<ProgrammeCreateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedCreateWithoutIndicateursAcademiquesInput>
    where?: ProgrammeWhereInput
  }

  export type ProgrammeUpdateToOneWithWhereWithoutIndicateursAcademiquesInput = {
    where?: ProgrammeWhereInput
    data: XOR<ProgrammeUpdateWithoutIndicateursAcademiquesInput, ProgrammeUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type ProgrammeUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUpdateManyWithoutProgrammeNestedInput
    user?: UserUpdateOneRequiredWithoutProgrammesNestedInput
  }

  export type ProgrammeUncheckedUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProgrammeNestedInput
  }

  export type UserUpsertWithoutIndicateursAcademiquesInput = {
    update: XOR<UserUpdateWithoutIndicateursAcademiquesInput, UserUncheckedUpdateWithoutIndicateursAcademiquesInput>
    create: XOR<UserCreateWithoutIndicateursAcademiquesInput, UserUncheckedCreateWithoutIndicateursAcademiquesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIndicateursAcademiquesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIndicateursAcademiquesInput, UserUncheckedUpdateWithoutIndicateursAcademiquesInput>
  }

  export type UserUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    modules?: ModuleUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateWithoutIndicateursAcademiquesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type ModuleCreateWithoutResultatsEtudiantsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementCreateNestedManyWithoutModuleInput
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutResultatsEtudiantsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: EvaluationEnseignementUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutResultatsEtudiantsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutResultatsEtudiantsInput, ModuleUncheckedCreateWithoutResultatsEtudiantsInput>
  }

  export type ModuleUpsertWithoutResultatsEtudiantsInput = {
    update: XOR<ModuleUpdateWithoutResultatsEtudiantsInput, ModuleUncheckedUpdateWithoutResultatsEtudiantsInput>
    create: XOR<ModuleCreateWithoutResultatsEtudiantsInput, ModuleUncheckedCreateWithoutResultatsEtudiantsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutResultatsEtudiantsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutResultatsEtudiantsInput, ModuleUncheckedUpdateWithoutResultatsEtudiantsInput>
  }

  export type ModuleUpdateWithoutResultatsEtudiantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutResultatsEtudiantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type IntervenantCreateWithoutEvaluationsInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantCreateNestedManyWithoutIntervenantInput
    modules?: ModuleCreateNestedManyWithoutIntervenantInput
    seances?: SeanceCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    civilite: string
    nom: string
    prenom: string
    email: string
    telephone?: string | null
    grade?: string | null
    specialite?: string | null
    etablissement?: string | null
    disponible?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creneauxPreferences?: string | null
    heuresMaxJour?: number
    heuresMaxSemaine?: number
    joursPreferences?: string | null
    disponibilites?: DisponibiliteIntervenantUncheckedCreateNestedManyWithoutIntervenantInput
    modules?: ModuleUncheckedCreateNestedManyWithoutIntervenantInput
    seances?: SeanceUncheckedCreateNestedManyWithoutIntervenantInput
  }

  export type IntervenantCreateOrConnectWithoutEvaluationsInput = {
    where: IntervenantWhereUniqueInput
    create: XOR<IntervenantCreateWithoutEvaluationsInput, IntervenantUncheckedCreateWithoutEvaluationsInput>
  }

  export type ModuleCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    intervenant?: IntervenantCreateNestedOneWithoutModulesInput
    programme: ProgrammeCreateNestedOneWithoutModulesInput
    user: UserCreateNestedOneWithoutModulesInput
    resultatsEtudiants?: ResultatEtudiantCreateNestedManyWithoutModuleInput
    seances?: SeanceCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    resultatsEtudiants?: ResultatEtudiantUncheckedCreateNestedManyWithoutModuleInput
    seances?: SeanceUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutEvaluationsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutEvaluationsInput, ModuleUncheckedCreateWithoutEvaluationsInput>
  }

  export type IntervenantUpsertWithoutEvaluationsInput = {
    update: XOR<IntervenantUpdateWithoutEvaluationsInput, IntervenantUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<IntervenantCreateWithoutEvaluationsInput, IntervenantUncheckedCreateWithoutEvaluationsInput>
    where?: IntervenantWhereInput
  }

  export type IntervenantUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: IntervenantWhereInput
    data: XOR<IntervenantUpdateWithoutEvaluationsInput, IntervenantUncheckedUpdateWithoutEvaluationsInput>
  }

  export type IntervenantUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUpdateManyWithoutIntervenantNestedInput
  }

  export type IntervenantUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    civilite?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    prenom?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    telephone?: NullableStringFieldUpdateOperationsInput | string | null
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    specialite?: NullableStringFieldUpdateOperationsInput | string | null
    etablissement?: NullableStringFieldUpdateOperationsInput | string | null
    disponible?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creneauxPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    heuresMaxJour?: IntFieldUpdateOperationsInput | number
    heuresMaxSemaine?: IntFieldUpdateOperationsInput | number
    joursPreferences?: NullableStringFieldUpdateOperationsInput | string | null
    disponibilites?: DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutIntervenantNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutIntervenantNestedInput
  }

  export type ModuleUpsertWithoutEvaluationsInput = {
    update: XOR<ModuleUpdateWithoutEvaluationsInput, ModuleUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<ModuleCreateWithoutEvaluationsInput, ModuleUncheckedCreateWithoutEvaluationsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutEvaluationsInput, ModuleUncheckedUpdateWithoutEvaluationsInput>
  }

  export type ModuleUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type UserCreateWithoutRotationsResponsableInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    modules?: ModuleCreateNestedManyWithoutUserInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateWithoutRotationsResponsableInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserCreateOrConnectWithoutRotationsResponsableInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRotationsResponsableInput, UserUncheckedCreateWithoutRotationsResponsableInput>
  }

  export type UserCreateWithoutRotationsSubstitutInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    modules?: ModuleCreateNestedManyWithoutUserInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    disponibilites?: DisponibiliteResponsableCreateNestedManyWithoutResponsableInput
  }

  export type UserUncheckedCreateWithoutRotationsSubstitutInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    disponibilites?: DisponibiliteResponsableUncheckedCreateNestedManyWithoutResponsableInput
  }

  export type UserCreateOrConnectWithoutRotationsSubstitutInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRotationsSubstitutInput, UserUncheckedCreateWithoutRotationsSubstitutInput>
  }

  export type RapportSupervisionCreateWithoutRotationInput = {
    id?: string
    heureArrivee?: string | null
    heureDepart?: string | null
    nbSeancesVisitees?: number
    incidents?: string | null
    observations?: string | null
    recommandations?: string | null
    satisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportSupervisionUncheckedCreateWithoutRotationInput = {
    id?: string
    heureArrivee?: string | null
    heureDepart?: string | null
    nbSeancesVisitees?: number
    incidents?: string | null
    observations?: string | null
    recommandations?: string | null
    satisfaction?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RapportSupervisionCreateOrConnectWithoutRotationInput = {
    where: RapportSupervisionWhereUniqueInput
    create: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
  }

  export type UserUpsertWithoutRotationsResponsableInput = {
    update: XOR<UserUpdateWithoutRotationsResponsableInput, UserUncheckedUpdateWithoutRotationsResponsableInput>
    create: XOR<UserCreateWithoutRotationsResponsableInput, UserUncheckedCreateWithoutRotationsResponsableInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRotationsResponsableInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRotationsResponsableInput, UserUncheckedUpdateWithoutRotationsResponsableInput>
  }

  export type UserUpdateWithoutRotationsResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateWithoutRotationsResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type UserUpsertWithoutRotationsSubstitutInput = {
    update: XOR<UserUpdateWithoutRotationsSubstitutInput, UserUncheckedUpdateWithoutRotationsSubstitutInput>
    create: XOR<UserCreateWithoutRotationsSubstitutInput, UserUncheckedCreateWithoutRotationsSubstitutInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRotationsSubstitutInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRotationsSubstitutInput, UserUncheckedUpdateWithoutRotationsSubstitutInput>
  }

  export type UserUpdateWithoutRotationsSubstitutInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    disponibilites?: DisponibiliteResponsableUpdateManyWithoutResponsableNestedInput
  }

  export type UserUncheckedUpdateWithoutRotationsSubstitutInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    disponibilites?: DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableNestedInput
  }

  export type RapportSupervisionUpsertWithoutRotationInput = {
    update: XOR<RapportSupervisionUpdateWithoutRotationInput, RapportSupervisionUncheckedUpdateWithoutRotationInput>
    create: XOR<RapportSupervisionCreateWithoutRotationInput, RapportSupervisionUncheckedCreateWithoutRotationInput>
    where?: RapportSupervisionWhereInput
  }

  export type RapportSupervisionUpdateToOneWithWhereWithoutRotationInput = {
    where?: RapportSupervisionWhereInput
    data: XOR<RapportSupervisionUpdateWithoutRotationInput, RapportSupervisionUncheckedUpdateWithoutRotationInput>
  }

  export type RapportSupervisionUpdateWithoutRotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RapportSupervisionUncheckedUpdateWithoutRotationInput = {
    id?: StringFieldUpdateOperationsInput | string
    heureArrivee?: NullableStringFieldUpdateOperationsInput | string | null
    heureDepart?: NullableStringFieldUpdateOperationsInput | string | null
    nbSeancesVisitees?: IntFieldUpdateOperationsInput | number
    incidents?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    recommandations?: NullableStringFieldUpdateOperationsInput | string | null
    satisfaction?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDisponibilitesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueCreateNestedManyWithoutResponsableInput
    modules?: ModuleCreateNestedManyWithoutUserInput
    programmes?: ProgrammeCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendCreateNestedManyWithoutSubstitutInput
  }

  export type UserUncheckedCreateWithoutDisponibilitesInput = {
    id?: string
    email: string
    name?: string | null
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    password: string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedCreateNestedManyWithoutResponsableInput
    modules?: ModuleUncheckedCreateNestedManyWithoutUserInput
    programmes?: ProgrammeUncheckedCreateNestedManyWithoutUserInput
    rotationsResponsable?: RotationWeekendUncheckedCreateNestedManyWithoutResponsableInput
    rotationsSubstitut?: RotationWeekendUncheckedCreateNestedManyWithoutSubstitutInput
  }

  export type UserCreateOrConnectWithoutDisponibilitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisponibilitesInput, UserUncheckedCreateWithoutDisponibilitesInput>
  }

  export type UserUpsertWithoutDisponibilitesInput = {
    update: XOR<UserUpdateWithoutDisponibilitesInput, UserUncheckedUpdateWithoutDisponibilitesInput>
    create: XOR<UserCreateWithoutDisponibilitesInput, UserUncheckedCreateWithoutDisponibilitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisponibilitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisponibilitesInput, UserUncheckedUpdateWithoutDisponibilitesInput>
  }

  export type UserUpdateWithoutDisponibilitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUpdateManyWithoutSubstitutNestedInput
  }

  export type UserUncheckedUpdateWithoutDisponibilitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    password?: StringFieldUpdateOperationsInput | string
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutUserNestedInput
    programmes?: ProgrammeUncheckedUpdateManyWithoutUserNestedInput
    rotationsResponsable?: RotationWeekendUncheckedUpdateManyWithoutResponsableNestedInput
    rotationsSubstitut?: RotationWeekendUncheckedUpdateManyWithoutSubstitutNestedInput
  }

  export type RotationWeekendCreateWithoutRapportSupervisionInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    responsable: UserCreateNestedOneWithoutRotationsResponsableInput
    substitut?: UserCreateNestedOneWithoutRotationsSubstitutInput
  }

  export type RotationWeekendUncheckedCreateWithoutRapportSupervisionInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    responsableId: string
    substitutId?: string | null
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RotationWeekendCreateOrConnectWithoutRapportSupervisionInput = {
    where: RotationWeekendWhereUniqueInput
    create: XOR<RotationWeekendCreateWithoutRapportSupervisionInput, RotationWeekendUncheckedCreateWithoutRapportSupervisionInput>
  }

  export type RotationWeekendUpsertWithoutRapportSupervisionInput = {
    update: XOR<RotationWeekendUpdateWithoutRapportSupervisionInput, RotationWeekendUncheckedUpdateWithoutRapportSupervisionInput>
    create: XOR<RotationWeekendCreateWithoutRapportSupervisionInput, RotationWeekendUncheckedCreateWithoutRapportSupervisionInput>
    where?: RotationWeekendWhereInput
  }

  export type RotationWeekendUpdateToOneWithWhereWithoutRapportSupervisionInput = {
    where?: RotationWeekendWhereInput
    data: XOR<RotationWeekendUpdateWithoutRapportSupervisionInput, RotationWeekendUncheckedUpdateWithoutRapportSupervisionInput>
  }

  export type RotationWeekendUpdateWithoutRapportSupervisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: UserUpdateOneRequiredWithoutRotationsResponsableNestedInput
    substitut?: UserUpdateOneWithoutRotationsSubstitutNestedInput
  }

  export type RotationWeekendUncheckedUpdateWithoutRapportSupervisionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    responsableId?: StringFieldUpdateOperationsInput | string
    substitutId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IndicateurAcademiqueCreateManyResponsableInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    periodeId: string
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateManyUserInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    intervenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProgrammeCreateManyUserInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    semestre: $Enums.Semestre
    niveau: string
    dateDebut: Date | string
    dateFin: Date | string
    status?: $Enums.StatusProgramme
    progression?: number
    totalVHT: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RotationWeekendCreateManyResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    substitutId?: string | null
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type RotationWeekendCreateManySubstitutInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    semaineNumero: number
    annee: number
    responsableId: string
    status?: $Enums.StatutRotation
    nbSeancesTotal?: number
    nbSeancesRealisees?: number
    commentaire?: string | null
    estAbsence?: boolean
    notificationEnvoyee?: boolean
    rappelEnvoye?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type DisponibiliteResponsableCreateManyResponsableInput = {
    id?: string
    dateDebut: Date | string
    dateFin: Date | string
    disponible?: boolean
    raison?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periode?: PeriodeAcademiqueUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
  }

  export type IndicateurAcademiqueUncheckedUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgrammeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUpdateManyWithoutProgrammeNestedInput
  }

  export type ProgrammeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activitesAcademiques?: ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    indicateursAcademiques?: IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeNestedInput
    modules?: ModuleUncheckedUpdateManyWithoutProgrammeNestedInput
  }

  export type ProgrammeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    semestre?: EnumSemestreFieldUpdateOperationsInput | $Enums.Semestre
    niveau?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusProgrammeFieldUpdateOperationsInput | $Enums.StatusProgramme
    progression?: IntFieldUpdateOperationsInput | number
    totalVHT?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RotationWeekendUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    substitut?: UserUpdateOneWithoutRotationsSubstitutNestedInput
    rapportSupervision?: RapportSupervisionUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendUncheckedUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    substitutId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    rapportSupervision?: RapportSupervisionUncheckedUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendUncheckedUpdateManyWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    substitutId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RotationWeekendUpdateWithoutSubstitutInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    responsable?: UserUpdateOneRequiredWithoutRotationsResponsableNestedInput
    rapportSupervision?: RapportSupervisionUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendUncheckedUpdateWithoutSubstitutInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    responsableId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    rapportSupervision?: RapportSupervisionUncheckedUpdateOneWithoutRotationNestedInput
  }

  export type RotationWeekendUncheckedUpdateManyWithoutSubstitutInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    semaineNumero?: IntFieldUpdateOperationsInput | number
    annee?: IntFieldUpdateOperationsInput | number
    responsableId?: StringFieldUpdateOperationsInput | string
    status?: EnumStatutRotationFieldUpdateOperationsInput | $Enums.StatutRotation
    nbSeancesTotal?: IntFieldUpdateOperationsInput | number
    nbSeancesRealisees?: IntFieldUpdateOperationsInput | number
    commentaire?: NullableStringFieldUpdateOperationsInput | string | null
    estAbsence?: BoolFieldUpdateOperationsInput | boolean
    notificationEnvoyee?: BoolFieldUpdateOperationsInput | boolean
    rappelEnvoye?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DisponibiliteResponsableUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteResponsableUncheckedUpdateWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteResponsableUncheckedUpdateManyWithoutResponsableInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateDebut?: DateTimeFieldUpdateOperationsInput | Date | string
    dateFin?: DateTimeFieldUpdateOperationsInput | Date | string
    disponible?: BoolFieldUpdateOperationsInput | boolean
    raison?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueCreateManyProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    periodeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueCreateManyProgrammeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    periodeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateManyProgrammeInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    intervenantId?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periode?: PeriodeAcademiqueUpdateOneRequiredWithoutActivitesAcademiquesNestedInput
  }

  export type ActiviteAcademiqueUncheckedUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueUncheckedUpdateManyWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    periode?: PeriodeAcademiqueUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
    responsable?: UserUpdateOneWithoutIndicateursAcademiquesNestedInput
  }

  export type IndicateurAcademiqueUncheckedUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    periodeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    intervenant?: IntervenantUpdateOneWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutProgrammeInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    intervenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteIntervenantCreateManyIntervenantInput = {
    id?: string
    jourSemaine: number
    heureDebut: string
    heureFin: string
    type?: $Enums.TypeDisponibilite
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    recurrent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvaluationEnseignementCreateManyIntervenantInput = {
    id?: string
    moduleId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleCreateManyIntervenantInput = {
    id?: string
    code: string
    name: string
    description?: string | null
    cm?: number
    td?: number
    tp?: number
    tpe?: number
    vht: number
    coefficient?: number
    credits?: number
    status?: $Enums.StatusModule
    progression?: number
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    programmeId: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeanceCreateManyIntervenantInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    moduleId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
  }

  export type DisponibiliteIntervenantUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteIntervenantUncheckedUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisponibiliteIntervenantUncheckedUpdateManyWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    jourSemaine?: IntFieldUpdateOperationsInput | number
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeDisponibiliteFieldUpdateOperationsInput | $Enums.TypeDisponibilite
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recurrent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    module?: ModuleUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationEnseignementUncheckedUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementUncheckedUpdateManyWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    moduleId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUpdateManyWithoutModuleNestedInput
    programme?: ProgrammeUpdateOneRequiredWithoutModulesNestedInput
    user?: UserUpdateOneRequiredWithoutModulesNestedInput
    resultatsEtudiants?: ResultatEtudiantUpdateManyWithoutModuleNestedInput
    seances?: SeanceUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: EvaluationEnseignementUncheckedUpdateManyWithoutModuleNestedInput
    resultatsEtudiants?: ResultatEtudiantUncheckedUpdateManyWithoutModuleNestedInput
    seances?: SeanceUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    cm?: IntFieldUpdateOperationsInput | number
    td?: IntFieldUpdateOperationsInput | number
    tp?: IntFieldUpdateOperationsInput | number
    tpe?: IntFieldUpdateOperationsInput | number
    vht?: IntFieldUpdateOperationsInput | number
    coefficient?: IntFieldUpdateOperationsInput | number
    credits?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusModuleFieldUpdateOperationsInput | $Enums.StatusModule
    progression?: IntFieldUpdateOperationsInput | number
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    programmeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeanceUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUpdateManyWithoutSeance2NestedInput
    module?: ModuleUpdateOneRequiredWithoutSeancesNestedInput
  }

  export type SeanceUncheckedUpdateWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUncheckedUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUncheckedUpdateManyWithoutSeance2NestedInput
  }

  export type SeanceUncheckedUpdateManyWithoutIntervenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    moduleId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationEnseignementCreateManyModuleInput = {
    id?: string
    intervenantId: string
    dateEnvoi?: Date | string | null
    dateDebut?: Date | string | null
    dateFin?: Date | string | null
    lienEvaluation?: string | null
    noteQualiteCours?: number | null
    noteQualitePedagogie?: number | null
    noteDisponibilite?: number | null
    noteMoyenne?: number | null
    nombreReponses?: number
    nombreInvitations?: number
    tauxParticipation?: number | null
    commentaires?: string | null
    statut?: $Enums.StatutCampagne
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResultatEtudiantCreateManyModuleInput = {
    id?: string
    numeroEtudiant: string
    nomEtudiant: string
    prenomEtudiant: string
    emailEtudiant?: string | null
    noteCC?: number | null
    noteExamen?: number | null
    noteFinale?: number | null
    statut: string
    mention?: string | null
    vhDeroule?: number
    progressionPct?: number
    presences?: number
    absences?: number
    tauxPresence?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeanceCreateManyModuleInput = {
    id?: string
    dateSeance: Date | string
    heureDebut: string
    heureFin: string
    duree: number
    typeSeance: $Enums.TypeSeance
    salle?: string | null
    batiment?: string | null
    status?: $Enums.StatusSeance
    intervenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notes?: string | null
    objectifs?: string | null
  }

  export type EvaluationEnseignementUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    intervenant?: IntervenantUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationEnseignementUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationEnseignementUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    intervenantId?: StringFieldUpdateOperationsInput | string
    dateEnvoi?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateDebut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateFin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lienEvaluation?: NullableStringFieldUpdateOperationsInput | string | null
    noteQualiteCours?: NullableFloatFieldUpdateOperationsInput | number | null
    noteQualitePedagogie?: NullableFloatFieldUpdateOperationsInput | number | null
    noteDisponibilite?: NullableFloatFieldUpdateOperationsInput | number | null
    noteMoyenne?: NullableFloatFieldUpdateOperationsInput | number | null
    nombreReponses?: IntFieldUpdateOperationsInput | number
    nombreInvitations?: IntFieldUpdateOperationsInput | number
    tauxParticipation?: NullableFloatFieldUpdateOperationsInput | number | null
    commentaires?: NullableStringFieldUpdateOperationsInput | string | null
    statut?: EnumStatutCampagneFieldUpdateOperationsInput | $Enums.StatutCampagne
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResultatEtudiantUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    numeroEtudiant?: StringFieldUpdateOperationsInput | string
    nomEtudiant?: StringFieldUpdateOperationsInput | string
    prenomEtudiant?: StringFieldUpdateOperationsInput | string
    emailEtudiant?: NullableStringFieldUpdateOperationsInput | string | null
    noteCC?: NullableFloatFieldUpdateOperationsInput | number | null
    noteExamen?: NullableFloatFieldUpdateOperationsInput | number | null
    noteFinale?: NullableFloatFieldUpdateOperationsInput | number | null
    statut?: StringFieldUpdateOperationsInput | string
    mention?: NullableStringFieldUpdateOperationsInput | string | null
    vhDeroule?: IntFieldUpdateOperationsInput | number
    progressionPct?: IntFieldUpdateOperationsInput | number
    presences?: IntFieldUpdateOperationsInput | number
    absences?: IntFieldUpdateOperationsInput | number
    tauxPresence?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeanceUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUpdateManyWithoutSeance2NestedInput
    intervenant?: IntervenantUpdateOneRequiredWithoutSeancesNestedInput
  }

  export type SeanceUncheckedUpdateWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
    conflitsAsSeance1?: ConflitUncheckedUpdateManyWithoutSeance1NestedInput
    conflitsAsSeance2?: ConflitUncheckedUpdateManyWithoutSeance2NestedInput
  }

  export type SeanceUncheckedUpdateManyWithoutModuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    dateSeance?: DateTimeFieldUpdateOperationsInput | Date | string
    heureDebut?: StringFieldUpdateOperationsInput | string
    heureFin?: StringFieldUpdateOperationsInput | string
    duree?: IntFieldUpdateOperationsInput | number
    typeSeance?: EnumTypeSeanceFieldUpdateOperationsInput | $Enums.TypeSeance
    salle?: NullableStringFieldUpdateOperationsInput | string | null
    batiment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusSeanceFieldUpdateOperationsInput | $Enums.StatusSeance
    intervenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    objectifs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConflitCreateManySeance1Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId2?: string | null
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitCreateManySeance2Input = {
    id?: string
    type: $Enums.TypeConflit
    description: string
    seanceId1: string
    ressourceType: string
    ressourceId: string
    resolu?: boolean
    resolution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resoluLe?: Date | string | null
    resoluPar?: string | null
    severite?: $Enums.SeveriteConflit
  }

  export type ConflitUpdateWithoutSeance1Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
    seance2?: SeanceUpdateOneWithoutConflitsAsSeance2NestedInput
  }

  export type ConflitUncheckedUpdateWithoutSeance1Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId2?: NullableStringFieldUpdateOperationsInput | string | null
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ConflitUncheckedUpdateManyWithoutSeance1Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId2?: NullableStringFieldUpdateOperationsInput | string | null
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ConflitUpdateWithoutSeance2Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
    seance1?: SeanceUpdateOneRequiredWithoutConflitsAsSeance1NestedInput
  }

  export type ConflitUncheckedUpdateWithoutSeance2Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId1?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ConflitUncheckedUpdateManyWithoutSeance2Input = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTypeConflitFieldUpdateOperationsInput | $Enums.TypeConflit
    description?: StringFieldUpdateOperationsInput | string
    seanceId1?: StringFieldUpdateOperationsInput | string
    ressourceType?: StringFieldUpdateOperationsInput | string
    ressourceId?: StringFieldUpdateOperationsInput | string
    resolu?: BoolFieldUpdateOperationsInput | boolean
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resoluLe?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resoluPar?: NullableStringFieldUpdateOperationsInput | string | null
    severite?: EnumSeveriteConflitFieldUpdateOperationsInput | $Enums.SeveriteConflit
  }

  export type ActiviteAcademiqueCreateManyPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    datePrevue?: Date | string | null
    dateReelle?: Date | string | null
    type: string
    programmeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IndicateurAcademiqueCreateManyPeriodeInput = {
    id?: string
    nom: string
    description?: string | null
    valeurCible?: number | null
    valeurReelle?: number | null
    periodicite: string
    methodeCalcul?: string | null
    unite?: string
    type: string
    programmeId: string
    responsableId?: string | null
    dateCollecte?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActiviteAcademiqueUpdateWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programme?: ProgrammeUpdateOneRequiredWithoutActivitesAcademiquesNestedInput
  }

  export type ActiviteAcademiqueUncheckedUpdateWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActiviteAcademiqueUncheckedUpdateManyWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    datePrevue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dateReelle?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUpdateWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    programme?: ProgrammeUpdateOneRequiredWithoutIndicateursAcademiquesNestedInput
    responsable?: UserUpdateOneWithoutIndicateursAcademiquesNestedInput
  }

  export type IndicateurAcademiqueUncheckedUpdateWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IndicateurAcademiqueUncheckedUpdateManyWithoutPeriodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    nom?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    valeurCible?: NullableFloatFieldUpdateOperationsInput | number | null
    valeurReelle?: NullableFloatFieldUpdateOperationsInput | number | null
    periodicite?: StringFieldUpdateOperationsInput | string
    methodeCalcul?: NullableStringFieldUpdateOperationsInput | string | null
    unite?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    programmeId?: StringFieldUpdateOperationsInput | string
    responsableId?: NullableStringFieldUpdateOperationsInput | string | null
    dateCollecte?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgrammeCountOutputTypeDefaultArgs instead
     */
    export type ProgrammeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgrammeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntervenantCountOutputTypeDefaultArgs instead
     */
    export type IntervenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntervenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleCountOutputTypeDefaultArgs instead
     */
    export type ModuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeanceCountOutputTypeDefaultArgs instead
     */
    export type SeanceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeanceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeriodeAcademiqueCountOutputTypeDefaultArgs instead
     */
    export type PeriodeAcademiqueCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PeriodeAcademiqueCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgrammeDefaultArgs instead
     */
    export type ProgrammeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgrammeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntervenantDefaultArgs instead
     */
    export type IntervenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntervenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisponibiliteIntervenantDefaultArgs instead
     */
    export type DisponibiliteIntervenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisponibiliteIntervenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ModuleDefaultArgs instead
     */
    export type ModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ModuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalleDefaultArgs instead
     */
    export type SalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeanceDefaultArgs instead
     */
    export type SeanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConflitDefaultArgs instead
     */
    export type ConflitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConflitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeriodeAcademiqueDefaultArgs instead
     */
    export type PeriodeAcademiqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PeriodeAcademiqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JournalActiviteDefaultArgs instead
     */
    export type JournalActiviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JournalActiviteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActiviteAcademiqueDefaultArgs instead
     */
    export type ActiviteAcademiqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActiviteAcademiqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IndicateurAcademiqueDefaultArgs instead
     */
    export type IndicateurAcademiqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IndicateurAcademiqueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResultatEtudiantDefaultArgs instead
     */
    export type ResultatEtudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResultatEtudiantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationEnseignementDefaultArgs instead
     */
    export type EvaluationEnseignementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationEnseignementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RotationWeekendDefaultArgs instead
     */
    export type RotationWeekendArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RotationWeekendDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DisponibiliteResponsableDefaultArgs instead
     */
    export type DisponibiliteResponsableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DisponibiliteResponsableDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RapportSupervisionDefaultArgs instead
     */
    export type RapportSupervisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RapportSupervisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StatistiqueRotationDefaultArgs instead
     */
    export type StatistiqueRotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StatistiqueRotationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}